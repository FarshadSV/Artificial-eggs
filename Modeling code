#Upload packages 
library(ggplot2)
library(ggeffects)
library(effects)
library(lme4)
library(lmerTest)
library(glmmTMB)
library(emmeans)
library(Matrix)
library(lmerTest)
library(dplyr)
library(writexl)
library(DHARMa)
library(performance)
library(car)
library(Hmisc)
library(MASS)
library(betareg)
library(lmtest)
library(MuMIn)
library(rptR)
library(boot)
#R.version.string
#citation()
#Upload datasets 
ED1 <- ED1_Modeling
ED2 <- ED2_Modeling
GD1 <- GD1_Final
GD2 <- GD2_Final

#Creating a column for T4:T3 ratio: 
GD1 <- GD1%>%
  mutate("T3_T4"= `T3 (pg.ul)`/`T4 (pg.ul)`)
GD2 <- GD2%>%
  mutate("T3_T4"= `T3 (pg.ul)`/`T4 (pg.ul)`)

ED1 <- ED1%>%
  mutate("T3_T4"= `T3 (pg.ul)` /`T4 (pg.ul)`)
ED2 <- ED2%>%
  mutate("T3_T4"= `T3 (pg.ul)`/`T4 (pg.ul)`)

#Renaming columns for simplicity 
GD1 <- GD1%>%
  rename( PFAS_SUM = `PFAS(SUM)`,
          AVG_Temp_egg_Hour = `AVG.Temp.egg (Hour)`,
          AVG_Temp_out_Hour= `AVG.Temp.out (Hour)`,
          T3= `T3 (pg.ul)`, 
          T4= `T4 (pg.ul)`,
    AVG_turns_hour=`AVG.Egg turning frequency (Overall/Hour)`,
    Day_turns =`Day/Hr egg turning`,
    Night_turns=`Night/Hr egg turning`,
    Overal_angularChange_mean=`Overall mean angular change`
  )

ED1 <- ED1%>%
  rename( PFAS_SUM = `PFAS(Sum)`,
          AVG_Temp_egg_Hour = `AVG.Temp.egg (Hour)`,
          AVG_Temp_out_Hour= `AVG.Temp.out (Hour)`,
          T3= `T3 (pg.ul)`, 
          T4= `T4 (pg.ul)`,
          AVG_turns_hour=`AVG.Egg turning frequency (Overall/Hour)`,
          Incubation_stage =`Incubation stage`, 
          Day_turns =`Day/Hr egg turning`,
          Night_turns=`Night/Hr egg turning`,
          Overal_angularChange_mean=`Overall mean angular change`,
          PRL= `PRL (ng/ml)`,
  )
#Data exploration 
#Making the weighted average for the egg attendance for the nests with 2 loggers 
#Weighted average egg turning rate= (Egg turning all*recorded hours)1 + (Egg turning all* recorded hours)2 / Recorded hours 1+ Recorded hours 2
#1) K26 (Overall turns divided by overall recorded hours)
eggTurn1 <- 33/668
eggTurn2 <- 48/75
AVG_egg_turns_weighted1 <- (eggTurn1 * 668 + eggTurn2 * 75) / (668 + 75)
GD1$AVG_turns_hour[7] <- 0.109

eggTemp1 <- 41.98
eggTemp2 <- 37.50
AVG_egg_Temp_weighted1 <- (eggTemp1 * 668 + eggTemp2 * 75) / (668 + 75)
GD1$AVG_Temp_egg_Hour[7] <- 41.527
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 0.052
Euler_night1 <- 0.041
Euler_day2 <- 0.741
Euler_night2 <- 0.277
Day_turn_weighted <- (Euler_day1 * 668 + Euler_day2 * 75) / (668 + 75)
Night_turn_weighted <- (Euler_night1 * 668 + Euler_night2 * 75) / (668 + 75)
GD1$Day_turns[7]<- 0.121
GD1$Night_turns[7]<- 0.064

# K22
eggTurn1 <- 771/567
eggTurn2 <- 103/85
AVG_egg_turns_weighted1 <- (eggTurn1 * 567 + eggTurn2 * 85) / (567 + 85)
GD1$AVG_turns_hour[6] <- 1.340

eggTemp1 <- 39.865
eggTemp2 <- 41.526
AVG_egg_Temp_weighted1 <- (eggTemp1 * 567 + eggTemp2 * 85) / (567 + 85)
GD1$AVG_Temp_egg_Hour[6] <- 40.081
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 1.410
Euler_night1 <- 1.215
Euler_day2 <- 1.440
Euler_night2 <- 0.625
Day_turn_weighted <- (Euler_day1 * 567 + Euler_day2 * 85) / (567 + 85)
Night_turn_weighted <- (Euler_night1 * 567 + Euler_night2 * 85) / (567 + 85)
GD1$Day_turns[6]<- 1.413
GD1$Night_turns[6]<- 1.138

# K23
eggTurn1 <- 49/80
eggTurn2 <- 50/78
AVG_egg_turns_weighted1 <- (eggTurn1 * 80 + eggTurn2 * 78) / (80 + 78)
GD1$AVG_turns_hour[17] <- 0.626

eggTemp1 <- 40.911
eggTemp2 <- 40.974
AVG_egg_Temp_weighted1 <- (eggTemp1 * 80 + eggTemp2 * 78) / (80 + 78)
GD1$AVG_Temp_egg_Hour[17] <- 40.942
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 0.716
Euler_night1 <- 0.265
Euler_day2 <- 0.726
Euler_night2 <- 0.333
Day_turn_weighted <- (Euler_day1 * 80 + Euler_day2 * 78) / (80 + 78)
Night_turn_weighted <- (Euler_night1 * 80 + Euler_night2 * 78) / (80 + 78)
GD1$Day_turns[17]<- 0.720
GD1$Night_turns[17]<- 0.298


## Species data summary
## Species data summary
mean(GD1$ClutchSize)
sd(GD1$ClutchSize)
mean(ED1$ClutchSize, na.rm=TRUE)
sd(ED1$ClutchSize, na.rm = TRUE)

mean(ED1$AVG_turns_hour, na.rm=TRUE)
range(GD1$AVG_Angular, na.rm=TRUE)
sd(GD1$AVG_Temp_egg_Hour, na.rm=TRUE)/sqrt(sum(GD1$AVG_Temp_egg_Hour, na.rm=TRUE))
#
sum(!is.na(ED1$PFAS_SUM))
mean(ED1$PFAS_SUM, na.rm=TRUE)
sd(ED1$PFAS_SUM, na.rm=TRUE)/sqrt(sum(ED1$PFAS_SUM, na.rm=TRUE))
# 
sum(!is.na(GD1$T4))
mean(GD1$T4, na.rm=TRUE)
sd(GD1$T4, na.rm=TRUE)/sqrt(sum(GD1$T4, na.rm=TRUE))
#-----Goldeneye vs. eider egg attendance -----
#Identifying outliers#
  identify_outliers_iqr <- function(data, column) {
    Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
    Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
    IQR_value <- Q3 - Q1
    lower_bound <- Q1 - 1.5 * IQR_value
    upper_bound <- Q3 + 1.5 * IQR_value
    
    # Return a logical vector where TRUE indicates an outlier
    data[[column]] < lower_bound | data[[column]] > upper_bound
  }

outliers_GD2 <- identify_outliers_iqr(GD2,"BodyCondition")
outliers_GD2
outliers_GD1 <- identify_outliers_iqr(GD1, "AVG_turns_hour")
outliers_GD1

#1.4) Across-species comparison
# First, across incubation stages in common eider
table(ED1$Incubation_stage)
ED1$`AVG.Temp.egg (Day)`
ED1$Incubation_stage <- factor(
  ED1$Incubation_stage,
  levels = c("Early.breeder", "Peak.incubation", "Late.breeder")
)

EggTempStage <- aov(AVG_Temp_egg_Hour ~ Incubation_stage, data = ED1)
EggTempStage <- aov(`AVG.Temp.egg (Day)` ~ Incubation_stage, data = ED1)
summary(EggTempStage)
pairs(emmeans(Lm_eider_stage, ~ Incubation_stage), adjust="tukey")
#OR
kruskal.test(`AVG.Temp.egg (Day)` ~ Incubation_stage, data = ED1)
#Body condition across incubation stages 
anova_Body <- aov(ClutchSize ~ Incubation_stage, data = ED1)
summary(anova_Body)
TukeyHSD(anova_Body)
boxplot(ClutchSize ~ Incubation_stage, data = ED1)
#Plotting 
ggplot(ED1, aes(x = Incubation_stage, y = AVG_Temp_egg_Hour)) +
  geom_violin(trim = FALSE, fill = "cornflowerblue", alpha = 0.5) +
  geom_boxplot(width = 0.1, fill = "cornflowerblue", outlier.shape = NA)+
  geom_jitter(width = 0.2, size = 2, shape=21, fill = "skyblue", color = "blue", alpha = 0.9) +
  theme( 
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.9, 0.9),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  guides(color = guide_legend(title = "Time"), fill = FALSE)+
  labs(
    x = "Incubation Stage",
    y = "Average Egg Turning Frequency (Overall/Hour)")
#Eider hatching success across breeding period 
#EDHatch <- betareg(HatchingSuccess_adj ~ Incubation_stage, data = ED1)
#emmeans(EDHatch, ~ Incubation_stage)
#pairs(emmeans(EDHatch, ~ Incubation_stage))
#2) Average turning rate
# Normality testing 

Shapiro <- shapiro.test(GD1$AVG_turns_hour)
Shapiro
Shapiro <- shapiro.test(ED1$AVG_turns_hour)
Shapiro

#Histogram 
hist(ED1$AVG_Temp_egg_Hour)
hist(GD1$AVG_Temp_egg_Hour)
#qq plot
qqnorm(ED1$AVG_Temp_egg_Hour)
qqline(ED1$AVG_Temp_egg_Hour)
qqnorm(GD1$AVG_Temp_egg_Hour)
qqline(GD1$AVG_Temp_egg_Hour)

#2.5) Average turning rate 
mean(GD1$AVG_turns_hour)
mean(ED1$AVG_turns_hour)
#2.5.1) Average hourly turns
var.test(GD1$AVG_turns_hour, ED1$AVG_turns_hour)

T_test <- t.test(na.omit(GD1$AVG_turns_hour), na.omit(ED1$AVG_turns_hour), var.equal = FALSE)
T_test
# Plot 

boxplot(GD1$AVG_turns_hour,ED1$AVG_turns_hour,
        names=c("Goldeneye", "Eider"),
        main=NA, 
        ylab= "Average hourly egg turning frequency",
        col=c("gold", "cornflowerblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE)
jitter <- 0.2
points(jitter(rep(1,length(GD1$AVG_turns_hour)), amount = jitter), GD1$AVG_turns_hour, pch=16, col="black", cex=0.8)
points(jitter(rep(2,length(ED1$AVG_turns_hour)), amount = jitter), ED1$AVG_turns_hour, pch=16, col="black", cex=0.8)

#2.5.1.2) Average daily turns 
Shapiro <- shapiro.test(GD1Daily$Daily_avg_turn)
Shapiro
Shapiro <- shapiro.test(ED1Daily$Daily_avg_turn)
Shapiro

mean(GD1Daily$Daily_avg_turn)
mean(ED1Daily$Daily_avg_turn)
var.test(GD1Daily$Daily_avg_turn, ED1Daily$Daily_avg_turn)

T_test <- t.test(na.omit(GD1Daily$Daily_avg_turn), na.omit(ED1Daily$Daily_avg_turn), var.equal = FALSE)
T_test

#combined <- data.frame(
 # Daily_avg_turn = c(GD1Daily$Daily_avg_turn, ED1Daily$Daily_avg_turn),
  #Species = factor(c(rep("Goldeneye", nrow(GD1Daily)),
   #                  rep("Eider", nrow(ED1Daily))))
#)
#t.test(Daily_avg_turn ~ Species, data = combined, var.equal = FALSE)
#2.5.2) Average turning rate during day/night hours 
#GD_Clean <- na.omit(GD1$`Day/Hr egg turning` & GD1$`Night/Hr egg turning`)
Shapiro <- shapiro.test(GD1$Day_turns)
Shapiro
Shapiro <- shapiro.test(GD1$Night_turns)
Shapiro
var.test(GD1$Night_turns, GD1$Day_turns)

T_test <- t.test(ED1$Night_turns, ED1$Day_turns, paired= TRUE)
T_test
mean(ED1$Night_turns)
mean(ED1$Day_turns)

#Plot
boxplot(ED1$Day_turns,ED1$Night_turns,
        names=c("4:00-22:00", "22:00-4:00"),
        main=NA, 
        ylab= "Average hourly egg turning frequency",
        col=c("powderblue", "cornflowerblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE,
        ylim = c(min(ED1$Day_turns, ED1$Night_turns) - 0.1, 
                 max(ED1$Day_turns, ED1$Night_turns) + 0.3),
        cex.axis=1,
        cex.lab=1) # More space

jitter <- 0.2
points(jitter(rep(1,length(ED1$Day_turns)), amount = jitter), ED1$Day_turns, pch=16, cex=0.6, col="black", alpha.f = 1.5)
points(jitter(rep(2,length(ED1$Night_turns)), amount = jitter), ED1$Night_turns, pch=16, cex=0.6, col="black", alpha.f = 1.5)
#Adding significany sign
text(x = 2, y = max(ED1$Day_turns, ED1$Night_turns) + 0.1, labels = "***", cex=2)
#text(x=0.6, y= max(ED1$Day_turns, ED1$Night_turns) + 0.2, labels= "(B)", front=2, cex=1.8)

#2.5.3) Average egg temperature 
GD1 <- GD1%>%
  rename(AVG_Temp_out_Day = `AVG.Temp.out (Day)`,
         DeltaTemp_eggOut=`AVG.Delta.Tem/hr(Out-Egg)`)
ED1 <- ED1%>%
  rename(AVG_Temp_out_Day = `AVG.Temp.out (Day)`,
         DeltaTemp_eggOut=`Delta.avgTem/hr(Out-Egg)`)

var.test(GD1$AVG_Temp_out_Hour, ED1$AVG_Temp_out_Hour)
mean(GD1$AVG_Temp_out_Hour)
mean(ED1$AVG_Temp_out_Hour, na.rm=TRUE)

mean(GD1$AVG_Temp_egg_Hour)
#mean(GD1Daily$AVG_Temp_day)
shapiro.test(GD1$AVG_Temp_egg_Hour)
#shapiro.test(GD1Daily$AVG_Temp_day)
mean(ED1$AVG_Temp_egg_Hour)
#mean(ED1Daily$AVG_Temp_day)
shapiro.test(ED1$AVG_Temp_egg_Hour)
#shapiro.test(ED1Daily$AVG_Temp_day)
var.test(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour)
#var.test(GD1Daily$AVG_Temp_day, ED1Daily$AVG_Temp_day)

T_test <- t.test(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour, var.equal = TRUE)
T_test
#T_test <- t.test(GD1Daily$AVG_Temp_day, ED1Daily$AVG_Temp_day, var.equal = TRUE)
#T_test
sum(!is.na(GD1$AVG_Temp_out_Hour))

#wilcox.test(GD1$AVG_Temp_out_Hour, ED1$AVG_Temp_out_Hour, exact = FALSE)

#Plot
boxplot(GD1$AVG_Temp_egg_Hour,ED1$AVG_Temp_egg_Hour,
        names=c("Goldeneye", "Eider"),
        main=NA, 
        ylab= "Average hourly egg temperature (°)",
        col=c("gold", "cornflowerblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE,
        cex.axis=1,
        cex.lab=1)
jitter <- 0.2
points(jitter(rep(1,length(GD1$AVG_Temp_egg_Hour)), amount = jitter), GD1$AVG_Temp_egg_Hour, pch=16, cex=0.6, col="black")
points(jitter(rep(2,length(ED1$AVG_Temp_egg_Hour)), amount = jitter), ED1$AVG_Temp_egg_Hour, pch=16, cex=0.6, col="black")
text(x = 1, y = max(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour) + 0.2, labels = "*", cex=2)

# ----Q1) Truning and Temp in relation to Incubation day----
# ------In goldeneyes------ 

#There are zero's in GD2. I make a subset with only above zero values. 
GD2Final <- subset(GD2, turns_per_day > 0)

### Checking correlations 
GD2Final$turns_per_day<- as.integer(GD2Final$turns_per_day)
GD2Final$AVG.EggTem.Per.IncDay <- as.numeric(GD2Final$AVG.EggTem.Per.IncDay)
COR <- GD2Final[, c("Fullday.Incubation","ClutchSize", "BodyCondition","AVG.EggTem.Per.IncDay")] 
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#Model selection 
GD2_complete <- na.omit(GD2Final[, c("Fullday.Incubation","turns_per_day","ClutchSize","BodyCondition",
                                     "FemaleID")])

Dredge_GLMM_turnPerDay=dredge(glmmTMB(turns_per_day ~  Fullday.Incubation +
                                        ClutchSize+
                                        #BodyCondition+
                                        (1|FemaleID),
                                      family=nbinom1(),
                                      data=GD2_complete,
                                      na.action = "na.fail"),
                              fixed = c("Fullday.Incubation")
)

View(Dredge_GLMM_turnPerDay)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_GLMM_turnPerDay, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_GLMM_turnPerDay, subset = 2)[[1]])

#Selected model
IncDayGold <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1| FemaleID), family=nbinom1(),data = GD2Final)
#IncDayGold <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1+Fullday.Incubation| FemaleID), family=nbinom1(),data = GD2Final)
#IncDayGold <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1| FemaleID), family=poisson(),data = GD2Final)
#IncDayGold <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1| FemaleID), family=nbinom2(),data = GD2Final)
summary(IncDayGold)
IncNULL <- glmmTMB(turns_per_day ~ 1+ (1|FemaleID),family=nbinom1(), data= GD2Final)
AIC(IncDayGold, IncNULL)

#Predicting the changes in turns/day to evaluate whether or not including it as covariate in the other analyses. 
range(GD2Final$Fullday.Incubation)
newdat <- data.frame(
  Fullday.Incubation = c(1, 30),
  FemaleID = NA   # NA because we only want population-level predictions
)

pred <- predict(IncDayGold, newdata = newdat, type = "response", re.form = NA)
pred
diff(pred)#predicted on day 1 vs. day 30
#Also, the model including random slope of incubation day does not show signicance= females vary in whether incubation day affects turning rates at all. Thus, population level slope is week. 
#Checking over dispersion 
overdisp_fun <- function(model) {
  rdf <- df.residual(model)
  rp <- residuals(model, type="pearson")
  sum(rp^2)/rdf
}
overdisp_fun(IncDayGold)
#Model fit 
sim_res <- simulateResiduals(IncDayGold)
plot(sim_res)
testDispersion(sim_res)
testZeroInflation(sim_res)

#Plotting 
pred <- ggpredict(IncDayGold, terms = "Fullday.Incubation")  

ggplot()+
  geom_point(data=GD2Final, aes(x = Fullday.Incubation, y = turns_per_day,color=factor(FemaleID)), alpha=0.6) +      
  geom_line(data = pred, aes(x = x, y = predicted), color = "#B8800B", size = 1) +
  geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high), alpha = 0.2, fill = "#B8800B") +
  labs(x = "Incubation day", y = "Turns per day") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#AND
ggplot(GD2Final, aes(x = Fullday.Incubation, y = turns_per_day, color = FemaleID)) +
  geom_point(alpha = 0.5) +
  geom_line(aes(group = FemaleID), size = 0.6) +
  labs(x = "Incubation day", y = "Turns per day", color = "Female ID") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")

#####Repeatability####
IncDayGold <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1| FemaleID), family=nbinom1(),data = GD2Final)
#ICC with performance::icc()
icc_val <- icc(IncDayGold)
print(icc_val)
# RPT
rpt_result <- rpt(turns_per_day ~ Fullday.Incubation + (1|FemaleID),
                  grname = "FemaleID",  
                  data = GD2Final,
                  datatype = "Poisson",
                  nboot = 1000,
                  npermut = 0)
summary(rpt_result)

#For R2
r2_vals <- r2_nakagawa(IncDayGold)
print(r2_vals)

#
## Temp and Incubation day ## 
#There are zero's in GD2. I make a subset with only above zero values. 
GD2 <- GD2%>%
  rename(AVG_Daily_Tem = `AVG.EggTem.Per.IncDay`)
GD2$AVG_Daily_Tem <- as.numeric(GD2$AVG_Daily_Tem)

### Checking correlations 
COR <- GD2[, c("Fullday.Incubation","ClutchSize", "BodyCondition","AVG_Daily_Tem")] 
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#Model selection 
GD2_complete <- na.omit(GD2[, c("Fullday.Incubation","turns_per_day","ClutchSize","AVG_Daily_Tem",
                                     "FemaleID")])

Dredge_GLMM_tempPerDay=dredge(glmmTMB(AVG_Daily_Tem ~  Fullday.Incubation +
                                        ClutchSize+
                                        #turns_per_day+ Not significant in the selected model
                                        (1|FemaleID),
                                      data=GD2_complete,
                                      na.action = "na.fail"),
                              fixed = c("Fullday.Incubation")
)

View(Dredge_GLMM_tempPerDay)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_GLMM_tempPerDay, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_GLMM_tempPerDay, subset = 2)[[1]])

#Selected model
IncDayGoldTemp <- glmmTMB(AVG_Daily_Tem ~ Fullday.Incubation + (1| FemaleID),data = GD2)
IncDayGoldTemp <- glmmTMB(AVG_Daily_Tem ~ Fullday.Incubation + (1+Fullday.Incubation| FemaleID),data = GD2)
summary(IncDayGoldTemp)

IncNULL <- glmmTMB(AVG_Daily_Tem ~ 1+ (1|FemaleID), data= GD2)
AIC(IncDayGoldTemp , IncNULL)
##Checking over dispersion 
overdisp_fun <- function(model) {
  rdf <- df.residual(model)
  rp <- residuals(model, type="pearson")
  sum(rp^2)/rdf
}
overdisp_fun(IncDayGoldTemp)
#Model fit 
sim_res <- simulateResiduals(IncDayGoldTemp)
plot(sim_res)
testDispersion(sim_res)
testZeroInflation(sim_res)
# Predicting the magnitude of change 
range(GD2$Fullday.Incubation)
newdat <- data.frame(Fullday.Incubation = c(1, 30),
                     FemaleID = NA)  # fixed effects only
pred <- predict(IncDayGoldTemp, newdata = newdat, re.form = NA)
pred
diff(pred)

#Plotting 
pred <- ggpredict(IncDayGoldTemp, terms = "Fullday.Incubation")  

ggplot()+
  geom_point(data=GD2, aes(x = Fullday.Incubation, y = AVG_Daily_Tem,color=factor(FemaleID)), alpha=0.6) +      
  geom_line(data = pred, aes(x = x, y = predicted), color = "#B8800B", size = 1) +
  geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high), alpha = 0.2, fill = "#B8800B") +
  labs(x = "Incubation day", y = "Average daily egg temperature") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#AND
ggplot(GD2, aes(x = Fullday.Incubation, y = AVG_Daily_Tem, color = FemaleID)) +
  geom_point(alpha = 0.5) +
  geom_line(aes(group = FemaleID), size = 0.6) +
  labs(x = "Incubation day", y = "Average daily egg temperature", color = "Female ID") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#
#####Repeatability####
IncDayGoldTemp <- glmmTMB(AVG_Daily_Tem ~ Fullday.Incubation + (1+Fullday.Incubation| FemaleID),data = GD2)
#ICC with rptR
TEMrpt_result <- rpt(
  AVG_Daily_Tem ~ Fullday.Incubation + (1| FemaleID),
  grname = "FemaleID",
  data = GD2,
  datatype = "Gaussian",
  nboot = 1000,
  npermut = 0
)

summary(TEMrpt_result)

#R2
library(performance)
r2_vals <- r2_nakagawa(IncDayGoldTemp)
print(r2_vals)

#
# -------In Eiders------ 
#Correlations 
COR <- ED2[, c("Fullday.Incubation", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
print(correlation_matrix)

#Model selection
ED2$turns_per_day<- as.integer(ED2$turns_per_day)

ED2_complete <- na.omit(ED2[, c("Fullday.Incubation","turns_per_day","ClutchSize","FemaleID")])

Dredge_GLMM_turnPerDay=dredge(glmmTMB(turns_per_day ~  Fullday.Incubation +
                                        ClutchSize+
                                        (1|FemaleID),
                                      data=ED2_complete,
                                      na.action = "na.fail"),
                              fixed = c("Fullday.Incubation")
)

View(Dredge_GLMM_turnPerDay)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_GLMM_turnPerDay, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_GLMM_turnPerDay, subset = 2)[[1]])
#NULL
IncNULL <- glmmTMB(turns_per_day ~ 1 + (1|FemaleID), family=nbinom2(), data=ED2FULL)

#Selected model
IncDayEider <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1|FemaleID), family=poisson(),data=ED2)
#IncDayEider <- glmmTMB(turns_per_day ~ scale(Fullday.Incubation) + (1+Fullday.Incubation|FemaleID), family=poisson(),data=ED2)
summary(IncDayEider)
length(unique(ED2$FemaleID))
IncNULL <- glmmTMB(turns_per_day ~ 1 + (1|FemaleID), data=ED2)
AIC(IncDayEider, IncNULL)
#Checking the model fit 
sim_res <- simulateResiduals(IncDayEider)
plot(sim_res)

#Plotting 
ggplot(ED2, aes(x = Fullday.Incubation, y = turns_per_day, color = FemaleID)) +
  geom_point(alpha = 0.5) +
  geom_line(aes(group = FemaleID), size = 0.6) +
  labs(x = "Incubation day", y = "Turns per day", color = "Female ID") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")

#####Repeatability####
IncDayEider <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1|FemaleID), family=poisson(),data=ED2)
#ICC with performance::icc()
icc_val <- icc(IncDayEider)
print(icc_val)
# RPT
EDrpt_result <- rpt(turns_per_day ~ Fullday.Incubation + (1|FemaleID),
                  grname = "FemaleID",  
                  data = ED2,
                  datatype = "Poisson",
                  nboot = 1000,
                  npermut = 0)
summary(EDrpt_result)

#For R2
r2_vals <- r2_nakagawa(IncDayEider)
print(r2_vals)
#
## Temp and Incubation day ## 
ED2 <- ED2%>%
  rename(AVG_Daily_Tem = `AVG.Egg.Tem.FullDay`)
ED2$AVG_Daily_Tem <- as.numeric(ED2$AVG_Daily_Tem)
### Checking correlations 
COR <- ED2[, c("Fullday.Incubation","ClutchSize", "BodyCondition","AVG_Daily_Tem")] 
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#Model selection 
ED2_complete <- na.omit(ED2[, c("Fullday.Incubation","turns_per_day","AVG_Daily_Tem",
                                "FemaleID")])

Dredge_GLMM_tempPerDay=dredge(glmmTMB(AVG_Daily_Tem ~  Fullday.Incubation +
                                        turns_per_day+
                                        (1|FemaleID),
                                      data=ED2_complete,
                                      na.action = "na.fail"),
                              fixed = c("Fullday.Incubation")
)

View(Dredge_GLMM_tempPerDay)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_GLMM_tempPerDay, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_GLMM_tempPerDay, subset = 2)[[1]])

#Selected model
IncDayEDTemp <- glmmTMB(log(AVG_Daily_Tem+1) ~ Fullday.Incubation + (1| FemaleID),data = ED2_complete)
#IncDayEDTemp <- glmmTMB(log(AVG_Daily_Tem+1) ~ Fullday.Incubation +(1+Fullday.Incubation| FemaleID),data = ED2_complete)
summary(IncDayEDTemp)
unique(ED2_complete$FemaleID)
IncNULL <- glmmTMB(AVG_Daily_Tem ~ 1+ (1|FemaleID), data= ED2_complete)
AIC(IncDayEDTemp1 , IncDayEDTemp2)
##Checking over dispersion 
overdisp_fun <- function(model) {
  rdf <- df.residual(model)
  rp <- residuals(model, type="pearson")
  sum(rp^2)/rdf
}
overdisp_fun(IncDayEDTemp)
#Model fit 
sim_res <- simulateResiduals(IncDayEDTemp)
plot(sim_res)
testDispersion(sim_res)
testZeroInflation(sim_res)
testOutliers(sim_res)
# Predicting the magnitude of change 
range(ED2_complete$Fullday.Incubation)

newdat <- data.frame(Fullday.Incubation = c(1, 28),
                     FemaleID = NA)  # fixed effects only
pred_log <- predict(IncDayEDTemp, newdata = newdat, re.form = NA)
pred_orig <- exp(pred_log) - 1
pred_orig
diff(pred_orig)
##Checking influential points 
outlierIndex <- which(res$scaledResiduals < 0.025 | res$scaledResiduals > 0.975)
outlier_data <- ED2_complete[outlierIndex, ]

outlier_data$residual <- sim_res$scaledResiduals[outlierIndex]

outlier_summary <- outlier_data %>%
  group_by(FemaleID) %>%
  summarise(
    n_points = n(),
    avg_residual = mean(residual)
  ) %>%
  arrange(desc(n_points))

outlier_summary
##Running the model without them
ED2_noOut <- subset(ED2_complete, !(FemaleID %in% c("DT081394","DT081224")))
IncDayEDTemp <- glmmTMB(log(AVG_Daily_Tem+1) ~ Fullday.Incubation + (1| FemaleID),data = ED2_noOut)
summary(IncDayEDTemp)
#Plotting 
pred <- ggpredict(IncDayEDTemp, terms = "Fullday.Incubation")  

ggplot()+
  geom_point(data=ED2_complete, aes(x = Fullday.Incubation, y = AVG_Daily_Tem,color=factor(FemaleID)), alpha=0.6) +      
  geom_line(data = pred, aes(x = x, y = predicted), color = "cornflowerblue", size = 1) +
  geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high), alpha = 0.2, fill = "cornflowerblue") +
  labs(x = "Incubation day", y = "Average daily egg temperature") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#AND
ggplot(ED2_complete, aes(x = Fullday.Incubation, y = AVG_Daily_Tem, color = FemaleID)) +
  geom_point(alpha = 0.5) +
  geom_line(aes(group = FemaleID), size = 0.6) +
  labs(x = "Incubation day", y = "Average daily egg temperature", color = "Female ID") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#
#####Repeatability####
IncDayEDTemp <- glmmTMB(log(AVG_Daily_Tem+1) ~ Fullday.Incubation +(1| FemaleID),data = ED2_complete)
#ICC with rptR
TEMrpt_result <- rpt(
  log(AVG_Daily_Tem+1) ~ Fullday.Incubation + (1| FemaleID),
  grname = "FemaleID",
  data = ED2_complete,
  datatype = "Gaussian",
  nboot = 1000,
  npermut = 0
)

summary(TEMrpt_result)

#R2
library(performance)
r2_vals <- r2_nakagawa(IncDayEDTemp)
print(r2_vals)

#
# ---- Q2) Egg attendance----
##Goldeneye####
GD1_scaled <- GD1
GD1_scaled$PFAS_SUM <- as.numeric(scale(GD1$PFAS_SUM))
GD1_scaled$PFOS <- as.numeric(scale(GD1$PFOS))
GD1_scaled$PFUnA <- as.numeric(scale(GD1$PFUnA))
GD1_scaled$PFDoDA <- as.numeric(scale(GD1$PFDoDA))
GD1_scaled$PFNA <- as.numeric(scale(GD1$PFNA))
GD1_scaled$T3 <- as.numeric(scale(GD1$T3))
GD1_scaled$T4 <- as.numeric(scale(GD1$T4))
GD1_scaled$T3_T4 <- as.numeric(scale(GD1$T3_T4))
GD1_scaled$ClutchSize <- as.numeric(scale(GD1$ClutchSize))
GD1_scaled$AVG_Temp_egg_Hour <- as.numeric(scale(GD1$AVG_Temp_egg_Hour))
GD1_scaled$BodyCondition <- as.numeric(scale(GD1$BodyCondition))


#Testing whether or not to add clutch size for each species 
summary(GD1$ClutchSize)
sd(GD1$ClutchSize)
#
summary(ED1$ClutchSize)
sd(ED1$ClutchSize, na.rm = TRUE)
table(ED1$ClutchSize)
total_nests <- sum(!is.na(ED1$ClutchSize))
n_3_5 <- sum(ED1$ClutchSize >= 3 & ED1$ClutchSize <= 5, na.rm = TRUE)
prop_3_5 <- n_3_5 / total_nests
prop_3_5
## 
COR <- GD1_scaled[, c("AVG_turns_hour","T3_T4","T3","PFAS_SUM", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
res <- rcorr(as.matrix(COR), type = "spearman")
res$r   
res$P 
# Egg turning rates
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFAS_SUM","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFUnA","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFOS","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFDoDA","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFNA","BodyCondition","ClutchSize")])


Dredge_LM_GD_Turns=dredge(lm(AVG_turns_hour ~ T3+
                               PFAS_SUM+
                               PFAS_SUM:T3+
                               ClutchSize+
                               BodyCondition+
                               #ClutchSize:T3_T4+
                               BodyCondition:T3+
                               BodyCondition:PFAS_SUM,
                             data=GD1_complete,
                             na.action = "na.fail"),
                          fixed = c(),
)

View(Dredge_LM_GD_Turns)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_GD_Turns, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_GD_Turns, subset = 2)[[1]])
summary(get.models(Dredge_LM_GD_Turns, subset = 3)[[1]])
#Model output
#1)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFAS_SUM","BodyCondition","ClutchSize")])
GD_AvgTURNS<- lm(AVG_turns_hour~ PFAS_SUM, data=GD1_complete)
summary(GD_AvgTURNS)
nobs(GD_AvgTURNS)
#
par(mfrow = c(2, 2))  
plot(GD_AvgTURNS)  
shapiro.test(residuals(GD_AvgTURNS))
hist(residuals(GD_AvgTURNS), breaks = 20, main = "Histogram of Residuals")
##Plot##
library(effects)
pfas_eff <- allEffects(GD_AvgTURNS)
pfas_df <- as.data.frame(pfas_eff[["PFAS_SUM"]])

ggplot(pfas_df, aes(x = PFAS_SUM, y = fit)) +
  geom_line(color = "#B8923B", size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              fill = "#B8923B", alpha = 0.15) +
  geom_point(data = GD1_complete, aes(x = PFAS_SUM, y = AVG_turns_hour),
             color = "#B8923B", alpha = 0.5, size = 3) +
  labs(x = "∑PFAS(scaled)",
       y = "Average hourly turning rate(scaled)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )
#2)
#GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T4","PFAS_SUM","BodyCondition","ClutchSize")])
#LM_AVG_TURN <- lm(AVG_turns_hour~ PFAS_SUM, data=GD1_complete)
#summary(LM_AVG_TURN )
#nobs(LM_AVG_TURN )
#
#3)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFUnA","BodyCondition","ClutchSize")])
PFUnA_AvgTURNS <- lm(AVG_turns_hour~ PFUnA, data=GD1_complete)
summary(PFUnA_AvgTURNS)
nobs(PFUnA_AvgTURNS)
#4)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFOS","BodyCondition","ClutchSize")])
PFOS_AvgTURNS <- lm(AVG_turns_hour~ PFOS, data=GD1_complete)
summary(PFOS_AvgTURNS)
nobs(PFOS_AvgTURNS)
#5)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFNA","BodyCondition","ClutchSize")])
PFNA_AvgTURNS <- lm(AVG_turns_hour~ PFNA+BodyCondition, data=GD1_complete)
summary(PFNA_AvgTURNS)
nobs(PFNA_AvgTURNS)
confint(PFNA_AvgTURNS)
#
##Plot##
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3_T4","PFDoDA","BodyCondition","ClutchSize")])
PFDoDA_AvgTURNS <- lm(AVG_turns_hour~ PFDoDA, data=GD1_complete)
library(broom)
coefs <- bind_rows(
  tidy(PFUnA_AvgTURNS, conf.int = TRUE) %>% filter(term == "PFUnA") %>% mutate(compound = "PFUnA"),
  tidy(PFNA_AvgTURNS, conf.int = TRUE) %>% filter(term == "PFNA") %>% mutate(compound = "PFNA"),
  tidy(PFDoDA_AvgTURNS, conf.int = TRUE) %>% filter(term == "PFDoDA") %>% mutate(compound = "PFDoDA"),
  tidy(PFOS_AvgTURNS, conf.int = TRUE) %>% filter(term == "PFOS") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFDoDA", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "#FFE8B8",
    high = "#9B5E3C",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Average hourly turning rate",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "right")
#
#Egg Temp
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFAS_SUM","BodyCondition","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFUnA","BodyCondition","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFOS","BodyCondition","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFDoDA","BodyCondition","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFNA","BodyCondition","AVG_turns_hour")])


Dredge_LM_GD_Temp=dredge(lm(AVG_Temp_egg_Hour ~ T3+
                               PFAS_SUM+
                               PFAS_SUM:T3+
                               #ClutchSize+
                               BodyCondition+
                               BodyCondition:T3+
                               AVG_turns_hour+
                               BodyCondition:PFAS_SUM,
                             data=GD1_complete,
                             na.action = "na.fail"),
                          fixed = c(),
)

View(Dredge_LM_GD_Temp)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_GD_Temp, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_GD_Temp, subset = 2)[[1]])
summary(get.models(Dredge_LM_GD_Temp, subset = 3)[[1]])
summary(get.models(Dredge_LM_GD_Temp, subset = 4)[[1]])
##Model outputs
#6) Temp
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFUnA","BodyCondition","AVG_turns_hour")])
PFUnA_AVGTemp <- lm(AVG_Temp_egg_Hour~ PFUnA, data=GD1_complete)
#OR
#PFUnA_AVGTemp <- lm(AVG_Temp_egg_Hour~ PFUnA, data=GD1_scaled)
summary(PFUnA_AVGTemp)
nobs(PFUnA_AVGTemp)

par(mfrow = c(2, 2))  
plot(PFUnA_AVGTemp)  
shapiro.test(residuals(PFUnA_AVGTemp))
hist(residuals(PFUnA_AVGTemp), breaks = 20, main = "Histogram of Residuals")

##Mediator analysis for PFUnA
#library(mediation)
#GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","AVG_Temp_egg_Hour","T3","PFUnA","BodyCondition", "ClutchSize")])
#m_model <- lm(AVG_turns_hour ~ PFUnA, data = GD1_complete)
#summary(m_model)
#y_model_med <- lm(AVG_Temp_egg_Hour ~ PFUnA + AVG_turns_hour, data = GD1_complete)
#summary(y_model_med)
#med_out <- mediate(m_model, y_model_med, treat = "PFUnA", mediator = "AVG_turns_hour",
#                   boot = TRUE, sims = 5000)

#summary(med_out) I won't present it, due to wide CIs= small sample size
#
##Plot##
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFOS","BodyCondition","AVG_turns_hour")])
PFNA_AVGTemp <- lm(AVG_Temp_egg_Hour~ PFNA, data=GD1_complete)
PFDoDA_AVGTemp <- lm(AVG_Temp_egg_Hour~ PFDoDA, data=GD1_complete)
PFOS_AVGTemp <- lm(AVG_Temp_egg_Hour~ PFOS, data=GD1_complete)

coefs <- bind_rows(
  tidy(PFUnA_AVGTemp, conf.int = TRUE) %>% filter(term == "PFUnA") %>% mutate(compound = "PFUnA"),
  tidy(PFNA_AVGTemp, conf.int = TRUE) %>% filter(term == "PFNA") %>% mutate(compound = "PFNA"),
  tidy(PFDoDA_AVGTemp, conf.int = TRUE) %>% filter(term == "PFDoDA") %>% mutate(compound = "PFDoDA"),
  tidy(PFOS_AVGTemp, conf.int = TRUE) %>% filter(term == "PFOS") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFDoDA", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "#FFE8B8",
    high = "#9B5E3C",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "",
    title = "Average hourly egg temperature",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "right")
#
## Daily turning rates
#For daily turns#
GD1Daily <- GD1
#
GD1Daily <- GD1Daily %>%
  rename(Total_record_hr= `Total record (Hour)`)
GD1Daily <- GD1Daily %>%
  rename(AVG_Temp_day= `AVG.Temp.egg (Day)`)

GD1Daily$Total_record_hr <- as.numeric(GD1Daily$Total_record_hr)
GD1Daily$RecordedDays <- as.numeric(GD1Daily$RecordedDays)
GD1Daily$AVG_Temp_day <- as.numeric(GD1Daily$AVG_Temp_day)
# Only keeping days with at least 19 hours of record
GD1Daily$DecimalPart <- GD1Daily$RecordedDays - floor(GD1Daily$RecordedDays)
# Step 2: Apply the condition: Remove decimals if < 0.70
GD1Daily$AdjustedRecordedDays <- ifelse(GD1Daily$DecimalPart < 0.70, 
                                        floor(GD1Daily$RecordedDays), 
                                        GD1Daily$RecordedDays)
GD1Daily$newTotalHours <- GD1Daily$AdjustedRecordedDays*24

#Re-calculating the average hourly turn
GD1Daily$NewHourlyTurns <- GD1Daily$AVG_turns_hour * (GD1Daily$Total_record_hr / GD1Daily$newTotalHours)

#Getting the average daily turn
GD1Daily$Daily_avg_turn <- GD1Daily$NewHourlyTurns*24
GD1Daily$Daily_avg_turn <- round(GD1Daily$Daily_avg_turn, 3)
#
GD1Daily$PFAS_SUM <- as.numeric(scale(GD1Daily$PFAS_SUM))
GD1Daily$PFUnA <- as.numeric(scale(GD1Daily$PFUnA))
GD1Daily$PFOS <- as.numeric(scale(GD1Daily$PFOS))
GD1Daily$PFDoDA <- as.numeric(scale(GD1Daily$PFDoDA))
GD1Daily$BodyCondition <- as.numeric(scale(GD1Daily$BodyCondition))
GD1Daily$ClutchSize <- as.numeric(scale(GD1Daily$ClutchSize))
GD1Daily$T3 <- as.numeric(scale(GD1Daily$T3))
#
GD1_complete <- na.omit(GD1Daily[, c("Daily_avg_turn","T3","PFAS_SUM","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1Daily[, c("Daily_avg_turn","T3","PFUnA","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1Daily[, c("Daily_avg_turn","T3","PFOS","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1Daily[, c("Daily_avg_turn","T3","PFDoDA","BodyCondition","ClutchSize")])
GD1_complete <- na.omit(GD1Daily[, c("Daily_avg_turn","T3","PFNA","BodyCondition","ClutchSize")])


Dredge_GD_DailyTurns=dredge(lm(Daily_avg_turn ~ T3+
                               PFUnA+
                               PFUnA:T3+
                               ClutchSize+
                               BodyCondition+
                               #ClutchSize:T3_T4+
                               BodyCondition:T3+
                               BodyCondition:PFUnA,
                             data=GD1_complete,
                             na.action = "na.fail"),
                          fixed = c(),
)

View(Dredge_GD_DailyTurns)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_GD_DailyTurns, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_GD_DailyTurns, subset = 2)[[1]])
summary(get.models(Dredge_GD_DailyTurns, subset = 3)[[1]])
#
#Output 
GD1_complete <- na.omit(GD1Daily[, c("Daily_avg_turn","T3","PFUnA","BodyCondition","ClutchSize")])
PFUnA_GD_DailyTurn<- lm(Daily_avg_turn~ PFUnA, data=GD1_complete)
summary(PFUnA_GD_DailyTurn)
nobs(PFUnA_GD_DailyTurn)

par(mfrow = c(2, 2))  
plot(PFUnA_GD_DailyTurn)  
shapiro.test(residuals(PFUnA_GD_DailyTurn))
hist(residuals(PFUnA_GD_DailyTurn), breaks = 20, main = "Histogram of Residuals")

# Daily average temperature 
GD1Daily$Daily_avg_turn <- as.numeric(scale(GD1Daily$Daily_avg_turn))

GD1_complete <- na.omit(GD1Daily[, c("AVG_Temp_day","Daily_avg_turn","T3","PFAS_SUM","BodyCondition")])
GD1_complete <- na.omit(GD1Daily[, c("AVG_Temp_day","Daily_avg_turn","T3","PFUnA","BodyCondition")])
GD1_complete <- na.omit(GD1Daily[, c("AVG_Temp_day","Daily_avg_turn","T3","PFOS","BodyCondition")])
GD1_complete <- na.omit(GD1Daily[, c("AVG_Temp_day","Daily_avg_turn","T3","PFDoDA","BodyCondition")])
GD1_complete <- na.omit(GD1Daily[, c("AVG_Temp_day","Daily_avg_turn","T3","PFNA","BodyCondition")])


Dredge_LM_GD_Temp=dredge(lm(AVG_Temp_day ~ T3+
                              PFUnA+
                              PFUnA:T3+
                              #ClutchSize+
                              BodyCondition+
                              BodyCondition:T3+
                              Daily_avg_turn+
                              BodyCondition:PFUnA,
                            data=GD1_complete,
                            na.action = "na.fail"),
                         fixed = c(),
)

View(Dredge_LM_GD_Temp)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_GD_Temp, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_GD_Temp, subset = 2)[[1]])
summary(get.models(Dredge_LM_GD_Temp, subset = 3)[[1]])
summary(get.models(Dredge_LM_GD_Temp, subset = 4)[[1]])
##Model outputs
GD1_complete <- na.omit(GD1Daily[, c("AVG_Temp_day","Daily_avg_turn","T3","PFUnA","BodyCondition")])
PFUnA_AVGTemp <- lm(AVG_Temp_day ~ PFUnA+Daily_avg_turn , data=GD1_complete)
#OR
PFUnA_AVGTemp <- lm(AVG_Temp_day ~ PFUnA+Daily_avg_turn , data=GD1Daily)
summary(PFUnA_AVGTemp)
nobs(PFUnA_AVGTemp)

par(mfrow = c(2, 2))  
plot(PFUnA_AVGTemp)  
shapiro.test(residuals(PFUnA_AVGTemp))
hist(residuals(PFUnA_AVGTemp), breaks = 20, main = "Histogram of Residuals")
#
# Mediation analysis for PFUnA (Positive effect both on daily egg turnig and daily egg temperature)
#library(mediation)
#GD1_complete <- na.omit(GD1Daily[, c("Daily_avg_turn","T3","PFUnA","BodyCondition","ClutchSize","AVG_Temp_day")])
#PFUnA_GD_DailyTurn<- lm(Daily_avg_turn~ PFUnA, data=GD1_complete)
#m_model <- lm(Daily_avg_turn~ PFUnA, data=GD1_complete)
#summary(m_model)
#PFUnA_AVGTemp <- lm(AVG_Temp_day ~ PFUnA, data=GD1_complete)
#y_model_med <- lm(AVG_Temp_day ~ PFUnA+Daily_avg_turn, data=GD1_complete)
#summary(y_model_med)
#med_out <- mediate(m_model, y_model_med, treat = "PFUnA", mediator = "Daily_avg_turn",
 #                  boot = TRUE, sims = 5000)
#summary(med_out) I won't present it, due to wide CIs= small sample size 

#
##PFAS-THs####
#
class(GD1$Hatch_Date)
class(GD1$Blood)
GD1$Days_to_Hatch <- as.numeric(difftime(GD1$Hatch_Date, GD1$Blood, units = "days"))
#
GD1_scaled <- GD1
GD1_scaled$PFAS_SUM <- as.numeric(scale(GD1$PFAS_SUM))
GD1_scaled$PFOS <- as.numeric(scale(GD1$PFOS))
GD1_scaled$PFUnA <- as.numeric(scale(GD1$PFUnA))
GD1_scaled$PFDoDA <- as.numeric(scale(GD1$PFDoDA))
GD1_scaled$PFNA <- as.numeric(scale(GD1$PFNA))
GD1_scaled$T3 <- as.numeric(scale(GD1$T3))
GD1_scaled$T4 <- as.numeric(scale(GD1$T4))
GD1_scaled$T3_T4 <- as.numeric(scale(GD1$T3_T4))
GD1_scaled$BodyCondition <- as.numeric(scale(GD1$BodyCondition))
GD1_scaled$Days_to_Hatch <- as.numeric(scale(GD1$Days_to_Hatch))

#
GD1_complete <- na.omit(GD1_scaled[, c("T3","PFAS_SUM","BodyCondition","Days_to_Hatch")])
GD1_complete <- na.omit(GD1_scaled[, c("T3_T4","PFUnA","BodyCondition","Days_to_Hatch")])
GD1_complete <- na.omit(GD1_scaled[, c("T3","PFOS","BodyCondition","Days_to_Hatch")])
GD1_complete <- na.omit(GD1_scaled[, c("T4","PFNA","BodyCondition","Days_to_Hatch")])
GD1_complete <- na.omit(GD1_scaled[, c("T3_T4","PFDoDA","BodyCondition","Days_to_Hatch")])

Dredge_LM_PFAS_THs=dredge(lm(T4 ~ PFNA+
                               PFNA:BodyCondition+
                               Days_to_Hatch+
                               BodyCondition,
                             data=GD1_complete,
                             na.action = "na.fail"),
                          fixed = c(),
)

View(Dredge_LM_PFAS_THs)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_PFAS_THs, subset = 1)[[1]])
summary(get.models(Dredge_LM_PFAS_THs, subset = 2)[[1]])
summary(get.models(Dredge_LM_PFAS_THs, subset = 3)[[1]])
summary(get.models(Dredge_LM_PFAS_THs, subset = 4)[[1]])
summary(get.models(Dredge_LM_PFAS_THs, subset = 5)[[1]])
#Output 1) T4
GD1_complete <- na.omit(GD1_scaled[, c("T4","PFNA","BodyCondition","Days_to_Hatch")])
PFAS_T4 <- lm(T4~ PFNA+BodyCondition, data=GD1_complete)
summary(PFAS_T4)
nobs(PFAS_T4)

par(mfrow = c(2, 2))  
plot(PFAS_T4)  
shapiro.test(residuals(PFAS_T4))
hist(residuals(PFAS_T4), breaks = 20, main = "Histogram of Residuals")
#
#Influential points 
library(car)
influencePlot(PFAS_T4)
# OR
cooksd <- cooks.distance(PFAS_T4)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_complete) - length(coef(PFAS_T4)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(GD1_complete) - length(coef(PFAS_T4)) - 1))
infl_obs
as.numeric(rownames(PFAS_T4$model)[infl_obs])

#Re-running without influential points 
GD1_sub <- GD1_complete[-c(4,6),]
PFAS_T4 <- lm(T4~ PFNA+BodyCondition, data=GD1_sub)
summary(PFAS_T4)
nobs(PFAS_T4)
#
##Plot#
PFNA_grid <- data.frame(
  PFNA = seq(min(GD1_complete$PFNA), max(GD1_complete$PFNA), length.out = 100),
  BodyCondition = mean(GD1_complete$BodyCondition, na.rm = TRUE)
)

PFNA_preds <- predict(PFAS_T4, newdata = PFNA_grid, interval = "confidence")
PFNA_grid$fit <- PFNA_preds[, "fit"]
PFNA_grid$lwr <- PFNA_preds[, "lwr"]
PFNA_grid$upr <- PFNA_preds[, "upr"]


ggplot(PFNA_grid, aes(x = PFNA, y = fit)) +
  geom_line(color = "#B8923B", size = 1.2) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), 
              fill = "#B8923B", alpha = 0.15) +
  geom_point(data = GD1_complete, aes(x = PFNA, y = T4),
             color = "#B8923B", alpha = 0.5, size = 3) +
  labs(x = "PFNA(scaled)",
       y = "T4 (scaled)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )
#

#
###Eider#####
#names(ED1)[names(ED1)== "Total record (Hour)"] <- "Total_record_hr"
ED1$Days.recorded <- as.numeric(ED1$Days.recorded)
ED1_scaled <- ED1
ED1_scaled$PFAS_SUM <- as.numeric(scale(ED1$PFAS_SUM))
ED1_scaled$PFOS <- as.numeric(scale(ED1$PFOS))
ED1_scaled$PFUnA <- as.numeric(scale(ED1$PFUnA))
ED1_scaled$PFHxS <- as.numeric(scale(ED1$PFHxS))
ED1_scaled$PFNA <- as.numeric(scale(ED1$PFNA))
ED1_scaled$T3 <- as.numeric(scale(ED1$T3))
ED1_scaled$T4 <- as.numeric(scale(ED1$T4))
ED1_scaled$T3_T4 <- as.numeric(scale(ED1$T3_T4))
ED1_scaled$ClutchSize <- as.numeric(scale(ED1$ClutchSize))
ED1_scaled$AVG_Temp_egg_Hour <- as.numeric(scale(ED1$AVG_Temp_egg_Hour))
ED1_scaled$BodyCondition <- as.numeric(scale(ED1$BodyCondition))
ED1_scaled$Days.recorded <- as.numeric(scale(ED1$Days.recorded))
## 
COR <- ED1[, c("T3","PFAS_SUM", "BodyCondition", "AVG_turns_hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
res <- rcorr(as.matrix(COR), type = "spearman")
res$r   
res$P 
#Egg turning
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFAS_SUM","BodyCondition","T3")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFOS","BodyCondition","T3")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFNA","BodyCondition","T3")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFHxS","BodyCondition","T3")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFUnA","BodyCondition","T3")])


Dredge_LM_ED_Turn=dredge(lm(AVG_turns_hour ~  PFAS_SUM+
                               T3+
                               BodyCondition+
                               PFAS_SUM:T3+
                              Days.recorded+
                               PFAS_SUM:BodyCondition,
                             data=ED1_complete,
                             na.action = "na.fail"),
                          fixed = c()
)

View(Dredge_LM_ED_Turn)
# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_ED_Turn, subset = 1)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 2)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 3)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 4)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 5)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 6)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 7)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 8)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 9)[[1]])
summary(get.models(Dredge_LM_ED_Turn, subset = 10)[[1]])

#Model averaging 
avg_model <- model.avg(Dredge_LM_ED_Turn, subset = delta < 4)
summary(avg_model)
sw(avg_model)
#
#Possible influential points 
#cooksd <- cooks.distance(LM_AVG_TURN)
#plot(cooksd, type = "h", main = "Cook's Distance")
#abline(h = 4/(nrow(ED1_scaled) - length(coef(LM_AVG_TURN)) - 1), col = "red", lty = 2)
#infl_obs <- which(cooksd > 4/(nrow(ED1_scaled) - length(coef(LM_AVG_TURN)) - 1))
#as.numeric(rownames(LM_AVG_TURN$model)[infl_obs])
#
#Output 
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFAS_SUM","BodyCondition","T3","Days.recorded")])
LM_EDTurn<- lm(AVG_turns_hour~ PFAS_SUM, data=ED1_scaled)
summary(LM_EDTurn)
nobs(LM_EDTurn)

par(mfrow = c(2, 2))  
plot(LM_EDTurn)  
shapiro.test(residuals(LM_EDTurn))
hist(residuals(LM_EDTurn), breaks = 20, main = "Histogram of Residuals")
#
#
#Egg Temperature 
ED1_scaled <- ED1
ED1_scaled$PFAS_SUM <- as.numeric(scale(ED1$PFAS_SUM))
ED1_scaled$PFOS <- as.numeric(scale(ED1$PFOS))
ED1_scaled$PFUnA <- as.numeric(scale(ED1$PFUnA))
ED1_scaled$PFHxS <- as.numeric(scale(ED1$PFHxS))
ED1_scaled$PFNA <- as.numeric(scale(ED1$PFNA))
ED1_scaled$T3 <- as.numeric(scale(ED1$T3))
ED1_scaled$T4 <- as.numeric(scale(ED1$T4))
ED1_scaled$T3_T4 <- as.numeric(scale(ED1$T3_T4))
#ED1_scaled$ClutchSize <- as.numeric(scale(ED1$ClutchSize))
ED1_scaled$BodyCondition <- as.numeric(scale(ED1$BodyCondition))
ED1_scaled$AVG_turns_hour <- as.numeric(scale(ED1$AVG_turns_hour))
ED1_scaled$Days.recorded <- as.numeric(scale(ED1$Days.recorded))

COR <- ED1[, c("T3","PFAS_SUM","BodyCondition","AVG_turns_hour","AVG_Temp_egg_Hour","Days.recorded")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
res <- rcorr(as.matrix(COR), type = "spearman")
res$r   
res$P 
#
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFAS_SUM","BodyCondition","T3","Days.recorded")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFOS","BodyCondition","T3","Days.recorded")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFNA","BodyCondition","T3","Days.recorded")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFHxS","BodyCondition","T3","Days.recorded")])
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFUnA","BodyCondition","T3","Days.recorded")])

Dredge_LM_ED_Temp=dredge(lm(AVG_Temp_egg_Hour ~  AVG_turns_hour+
                              PFAS_SUM+
                              T3+
                              BodyCondition+
                              PFAS_SUM:T3+
                              PFAS_SUM:BodyCondition+
                              Days.recorded,
                            data=ED1_complete,
                            na.action = "na.fail"),
                         fixed = c("PFAS_SUM")
)

View(Dredge_LM_ED_Temp)
# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_ED_Temp, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_ED_Temp, subset = 2)[[1]])
summary(get.models(Dredge_LM_ED_Temp, subset = 3)[[1]])
summary(get.models(Dredge_LM_ED_Temp, subset = 4)[[1]])
summary(get.models(Dredge_LM_ED_Temp, subset = 5)[[1]])

#Model averaging 
avg_model <- model.avg(Dredge_LM_ED_Temp, subset = delta < 4)
summary(avg_model)
sw(avg_model)
#Temp
#Output1) 
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFAS_SUM","BodyCondition","T3","Days.recorded")])
LM_EDTemp<- lm(AVG_Temp_egg_Hour~ PFAS_SUM+AVG_turns_hour, data=ED1_complete)
#OR: since the output remains the same on the full data set, we can report this one: 
LM_EDTemp<- lm(AVG_Temp_egg_Hour~ PFAS_SUM+AVG_turns_hour, data=ED1_scaled)
summary(LM_EDTemp)
nobs(LM_EDTemp)

par(mfrow = c(2, 2))  
plot(LM_EDTemp)  
shapiro.test(residuals(LM_EDTemp))
hist(residuals(LM_EDTemp), breaks = 20, main = "Histogram of Residuals")
#
#Influential points
library(car)
cooksd <- cooks.distance(LM_EDTemp)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_scaled) - length(coef(LM_EDTemp)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(ED1_scaled) - length(coef(LM_EDTemp)) - 1))
infl_obs
#To make sure which observation is the influential 
as.numeric(rownames(LM_EDTemp$model)[infl_obs])

#IF needed! Re-running the model with the subset, excluding the influential points: 
ED1scaled_sub<- ED1_scaled[-25, ]  # Removes the second row
#MODEL
LM_EDTemp<- lm(AVG_Temp_egg_Hour~ PFAS_SUM+AVG_turns_hour, data=ED1scaled_sub)
summary(LM_EDTemp)
nobs(LM_EDTemp)
#
#Output2)
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFOS","BodyCondition","T3","Days.recorded")])
PFOS_AVGTemp<-  lm(AVG_Temp_egg_Hour~ PFOS+AVG_turns_hour, data=ED1_complete)
#PFOS_AVGTemp1<-  lm(AVG_Temp_egg_Hour~ PFOS, data=ED1_complete)
#OR
#PFOS_AVGTemp<-  lm(AVG_Temp_egg_Hour~ PFOS+AVG_turns_hour, data=ED1_scaled)
PFOS_AVGTemp<-  lm(AVG_Temp_egg_Hour~ PFOS, data=ED1_scaled)
summary(PFOS_AVGTemp)
nobs(PFOS_AVGTemp)
#AICc(PFOS_AVGTemp,PFOS_AVGTemp1)
#
#
##Plot#
turns_grid <- data.frame(
  PFAS_SUM = seq(min(ED1_scaled$PFAS_SUM, na.rm = TRUE), max(ED1_scaled$PFAS_SUM, na.rm = TRUE), length.out = 100),
  AVG_turns_hour = mean(ED1_scaled$AVG_turns_hour, na.rm = TRUE)
)

turns_preds <- predict(LM_EDTemp, newdata = turns_grid, interval = "confidence")
turns_grid$fit <- turns_preds[, "fit"]
turns_grid$lwr <- turns_preds[, "lwr"]
turns_grid$upr <- turns_preds[, "upr"]

ggplot(turns_grid, aes(x = PFAS_SUM, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "cornflowerblue", alpha = 0.15) +
  geom_line(color = "#6495ED", size = 1.2) +
  geom_point(data = ED1_scaled, aes(x = PFAS_SUM, y = AVG_Temp_egg_Hour),
             alpha = 0.5, size = 3, color = "cornflowerblue") +
  labs(x = "∑PFAS (scaled)", y = "Scaled average hourly egg temperature (°C)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )
##AND
turns_grid <- data.frame(
  AVG_turns_hour = seq(min(ED1_scaled$AVG_turns_hour, na.rm = TRUE), max(ED1_scaled$AVG_turns_hour, na.rm = TRUE), length.out = 100),
  PFAS_SUM = mean(ED1_scaled$PFAS_SUM, na.rm = TRUE)
)

turns_preds <- predict(LM_EDTemp, newdata = turns_grid, interval = "confidence")
turns_grid$fit <- turns_preds[, "fit"]
turns_grid$lwr <- turns_preds[, "lwr"]
turns_grid$upr <- turns_preds[, "upr"]

ggplot(turns_grid, aes(x = AVG_turns_hour, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "cornflowerblue", alpha = 0.15) +
  geom_line(color = "#6495ED", size = 1.2) +
  geom_point(data = ED1_scaled, aes(x = AVG_turns_hour, y = AVG_Temp_egg_Hour),
             alpha = 0.5, size = 3, color = "cornflowerblue") +
  labs(x = "Average hourly turning rate (scaled)", y = "Scaled average hourly egg temperature (°C)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )
#
#AND
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFOS","BodyCondition","T3", "Days.recorded")])
PFHxS_AVGTemp<- lm(AVG_Temp_egg_Hour~ PFHxS, data=ED1_scaled)
PFNA_AVGTemp<- lm(AVG_Temp_egg_Hour~ PFNA, data=ED1_scaled)
PFUnA_AVGTemp<- lm(AVG_Temp_egg_Hour~ PFUnA, data=ED1_scaled)

coefs <- bind_rows(
  tidy(PFUnA_AVGTemp, conf.int = TRUE) %>% filter(term == "PFUnA") %>% mutate(compound = "PFUnA"),
  tidy(PFNA_AVGTemp, conf.int = TRUE) %>% filter(term == "PFNA") %>% mutate(compound = "PFNA"),
  tidy(PFHxS_AVGTemp, conf.int = TRUE) %>% filter(term == "PFHxS") %>% mutate(compound = "PFHxS"),
  tidy(PFOS_AVGTemp, conf.int = TRUE) %>% filter(term == "PFOS") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFHxS", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "#B0C4DE",  
    high = "#4169E9", 
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Average hourly egg temperature",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "right")
#
#
## Average daily turning 
# For daily turning
ED1Daily <- ED1
#
ED1Daily <- ED1Daily%>%
  rename(AVG_Temp_day= `AVG.Temp.egg (Day)`)
#class(GD1Daily$Total_record_hr)
#ED1Daily$AVG_turns_hour <- as.numeric(scale(ED1Daily$AVG_turns_hour))
ED1Daily$Total_record_hr <- as.numeric(ED1Daily$Total_record_hr)
ED1Daily$Days.recorded <- as.numeric(ED1Daily$Days.recorded)
ED1Daily$AVG_Temp_day <- as.numeric(ED1Daily$AVG_Temp_day)
# Only keeping days with at least 19 hours of record
ED1Daily$DecimalPart <- ED1Daily$Days.recorded- floor(ED1Daily$Days.recorded)
# Step 2: Apply the condition: Remove decimals if < 0.70
ED1Daily$AdjustedRecordedDays <- ifelse(ED1Daily$DecimalPart < 0.70, 
                                        floor(ED1Daily$Days.recorded), 
                                        ED1Daily$Days.recorded)
ED1Daily$newTotalHours <- ED1Daily$AdjustedRecordedDays*24

#Re-calculating the average hourly turn
ED1Daily$NewHourlyTurns <- ED1Daily$AVG_turns_hour * (ED1Daily$Total_record_hr / ED1Daily$newTotalHours)

#Getting the average daily turn
ED1Daily$Daily_avg_turn <- ED1Daily$NewHourlyTurns*24
ED1Daily$Daily_avg_turn <- round(ED1Daily$Daily_avg_turn, 3)
#
ED1Daily$Daily_avg_turn <- as.numeric(ED1Daily$Daily_avg_turn)
#
ED1Daily$PFAS_SUM <- as.numeric(scale(ED1$PFAS_SUM))
ED1Daily$PFOS <- as.numeric(scale(ED1$PFOS))
ED1Daily$PFUnA <- as.numeric(scale(ED1$PFUnA))
ED1Daily$PFHxS <- as.numeric(scale(ED1$PFHxS))
ED1Daily$PFNA <- as.numeric(scale(ED1$PFNA))
ED1Daily$T3 <- as.numeric(scale(ED1$T3))
ED1Daily$T4 <- as.numeric(scale(ED1$T4))
ED1Daily$T3_T4 <- as.numeric(scale(ED1$T3_T4))
ED1Daily$ClutchSize <- as.numeric(scale(ED1$ClutchSize))
ED1Daily$BodyCondition <- as.numeric(scale(ED1$BodyCondition))
ED1Daily$AdjustedRecordedDays <- as.numeric(scale(ED1Daily$AdjustedRecordedDays))

ED1_complete <- na.omit(ED1Daily[, c("Daily_avg_turn","PFAS_SUM","BodyCondition","T3")])
ED1_complete <- na.omit(ED1Daily[, c("Daily_avg_turn","PFOS","BodyCondition","T3")])
ED1_complete <- na.omit(ED1Daily[, c("Daily_avg_turn","PFNA","BodyCondition","T3")])
ED1_complete <- na.omit(ED1Daily[, c("Daily_avg_turn","PFHxS","BodyCondition","T3")])
ED1_complete <- na.omit(ED1Daily[, c("Daily_avg_turn","PFUnA","BodyCondition","T3")])

Dredge_ED_AVGDailyTurn=dredge(lm(Daily_avg_turn ~ PFOS+
                                   T3+
                                   BodyCondition+
                                   PFOS:T3+
                                   PFOS:BodyCondition,
                                 data=ED1_complete,
                                 na.action = "na.fail"),
                              fixed = c()
)

View(Dredge_ED_AVGDailyTurn)
# summary() of the model with the lowest AICc
summary(get.models(Dredge_ED_AVGDailyTurn, subset = 1)[[1]])
summary(get.models(Dredge_ED_AVGDailyTurn, subset = 2)[[1]])
summary(get.models(Dredge_ED_AVGDailyTurn, subset = 3)[[1]])
summary(get.models(Dredge_ED_AVGDailyTurn, subset = 4)[[1]])
summary(get.models(Dredge_ED_AVGDailyTurn, subset = 5)[[1]])
#

## Average daily egg temperature 
ED1Daily$PFAS_SUM <- as.numeric(scale(ED1$PFAS_SUM))
ED1Daily$PFOS <- as.numeric(scale(ED1$PFOS))
ED1Daily$PFUnA <- as.numeric(scale(ED1$PFUnA))
ED1Daily$PFHxS <- as.numeric(scale(ED1$PFHxS))
ED1Daily$PFNA <- as.numeric(scale(ED1$PFNA))
ED1Daily$T3 <- as.numeric(scale(ED1$T3))
ED1Daily$T4 <- as.numeric(scale(ED1$T4))
ED1Daily$T3_T4 <- as.numeric(scale(ED1$T3_T4))
ED1Daily$ClutchSize <- as.numeric(scale(ED1$ClutchSize))
ED1Daily$BodyCondition <- as.numeric(scale(ED1$BodyCondition))
ED1Daily$AdjustedRecordedDays <- as.numeric(scale(ED1Daily$AdjustedRecordedDays))
ED1Daily$Daily_avg_turn<- as.numeric(scale(ED1Daily$Daily_avg_turn))

ED1_complete <- na.omit(ED1Daily[, c("AVG_Temp_day","Daily_avg_turn","PFAS_SUM","BodyCondition","T3","AdjustedRecordedDays")])
ED1_complete <- na.omit(ED1Daily[, c("AVG_Temp_day","Daily_avg_turn","PFOS","BodyCondition","T3","AdjustedRecordedDays")])
ED1_complete <- na.omit(ED1Daily[, c("AVG_Temp_day","Daily_avg_turn","PFNA","BodyCondition","T3","AdjustedRecordedDays")])
ED1_complete <- na.omit(ED1Daily[, c("AVG_Temp_day","Daily_avg_turn","PFHxS","BodyCondition","T3","AdjustedRecordedDays")])
ED1_complete <- na.omit(ED1Daily[, c("AVG_Temp_day","Daily_avg_turn","PFUnA","BodyCondition","T3","AdjustedRecordedDays")])

Dredge_ED_AVGdailyTemp=dredge(lm(AVG_Temp_day ~  Daily_avg_turn+
                              PFAS_SUM+
                              T3+
                              BodyCondition+
                              PFAS_SUM:T3+
                              PFAS_SUM:BodyCondition+
                              AdjustedRecordedDays,
                            data=ED1_complete,
                            na.action = "na.fail"),
                         fixed = c()
)

View(Dredge_ED_AVGdailyTemp)
# summary() of the model with the lowest AICc
summary(get.models(Dredge_ED_AVGdailyTemp, subset = 1)[[1]])
summary(get.models(Dredge_ED_AVGdailyTemp, subset = 2)[[1]])
summary(get.models(Dredge_ED_AVGdailyTemp, subset = 3)[[1]])
summary(get.models(Dredge_ED_AVGdailyTemp, subset = 4)[[1]])
summary(get.models(Dredge_ED_AVGdailyTemp, subset = 8)[[1]])

#Model averaging 
avg_model <- model.avg(Dredge_ED_AVGdailyTemp, subset = delta < 4)
summary(avg_model)
sw(avg_model)

#Output1) 
ED1_complete <- na.omit(ED1Daily[, c("AVG_Temp_day","Daily_avg_turn","PFAS_SUM","BodyCondition","T3","AdjustedRecordedDays")])
ED_avgDailyTemp<- lm(AVG_Temp_day~ PFAS_SUM+BodyCondition+Daily_avg_turn, data=ED1_complete)
#OR, Since the output remains the same 
ED_avgDailyTemp<- lm(AVG_Temp_day~ PFAS_SUM+BodyCondition+Daily_avg_turn, data=ED1Daily)
summary(ED_avgDailyTemp)
nobs(ED_avgDailyTemp)

par(mfrow = c(2, 2))  
plot(ED_avgDailyTemp)  
shapiro.test(residuals(ED_avgDailyTemp))
hist(residuals(ED_avgDailyTemp), breaks = 20, main = "Histogram of Residuals")
#
#Output2) 
ED1_complete <- na.omit(ED1Daily[, c("AVG_Temp_day","Daily_avg_turn","PFOS","BodyCondition","T3","AdjustedRecordedDays")])
PFOS_ED_avgDailyTemp<- lm(AVG_Temp_day~ PFOS, data=ED1_complete)
#OR, Since the output remains the same 
PFOS_ED_avgDailyTemp<- lm(AVG_Temp_day~ PFOS, data=ED1Daily)
summary(PFOS_ED_avgDailyTemp)
nobs(PFOS_ED_avgDailyTemp)

par(mfrow = c(2, 2))  
plot(PFOS_ED_avgDailyTemp)  
shapiro.test(residuals(PFOS_ED_avgDailyTemp))
hist(residuals(PFOS_ED_avgDailyTemp), breaks = 20, main = "Histogram of Residuals")
#
#Plot
PFNA_ED_avgDailyTemp<- lm(AVG_Temp_day~ PFNA, data=ED1Daily)
PFHxS_ED_avgDailyTemp<- lm(AVG_Temp_day~ PFHxS, data=ED1Daily)
PFUnA_ED_avgDailyTemp<- lm(AVG_Temp_day~ PFUnA, data=ED1Daily)

coefs <- bind_rows(
  tidy(PFUnA_ED_avgDailyTemp, conf.int = TRUE) %>% filter(term == "PFUnA") %>% mutate(compound = "PFUnA"),
  tidy(PFNA_ED_avgDailyTemp, conf.int = TRUE) %>% filter(term == "PFNA") %>% mutate(compound = "PFNA"),
  tidy(PFHxS_ED_avgDailyTemp, conf.int = TRUE) %>% filter(term == "PFHxS") %>% mutate(compound = "PFHxS"),
  tidy(PFOS_ED_avgDailyTemp, conf.int = TRUE) %>% filter(term == "PFOS") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFHxS", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "#B0C4DE",  
    high = "#4169E9", 
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS (scaled)",
    title = "Average daily egg temperature (°)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "right")


#
# Mediation analysis for PFOS (negative effect both on daily egg turnig and daily egg temperature)
library(mediation)
#PFOS_ED_DailyTurn<- lm(Daily_avg_turn~ PFOS, data=ED1Daily)
m_model <- lm(Daily_avg_turn~ PFOS, data=ED1Daily)
summary(m_model)
#PFOS_ED_avgDailyTemp<- lm(AVG_Temp_day~ PFOS, data=ED1Daily)
y_model_med <- lm(AVG_Temp_day~ PFOS+Daily_avg_turn , data=ED1Daily)
summary(y_model_med)
med_out <- mediate(m_model, y_model_med, treat = "PFOS", mediator = "Daily_avg_turn",
                   boot = TRUE, sims = 5000)

summary(med_out)
#
##PFAS-THs####
#
class(ED1$Estimated_Hatch)
class(ED1$Blood)
ED1$Days_to_Hatch <- as.numeric(difftime(ED1$Estimated_Hatch, ED1$Blood, units = "days"))
#
ED1_scaled <- ED1
ED1_scaled$PFAS_SUM <- as.numeric(scale(ED1$PFAS_SUM))
ED1_scaled$PFOS <- as.numeric(scale(ED1$PFOS))
ED1_scaled$PFUnA <- as.numeric(scale(ED1$PFUnA))
ED1_scaled$PFHxS <- as.numeric(scale(ED1$PFHxS))
ED1_scaled$PFNA <- as.numeric(scale(ED1$PFNA))
ED1_scaled$T3 <- as.numeric(scale(ED1$T3))
ED1_scaled$T4 <- as.numeric(scale(ED1$T4))
ED1_scaled$T3_T4 <- as.numeric(scale(ED1$T3_T4))
ED1_scaled$BodyCondition <- as.numeric(scale(ED1$BodyCondition))
ED1_scaled$Days_to_Hatch  <- as.numeric(scale(ED1$Days_to_Hatch))

#
COR <- ED1_scaled[, c("PFAS_SUM","BodyCondition","T3_T4")] 
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#
#OR
#THs
ED1_complete <- na.omit(ED1_scaled[, c("PFAS_SUM","BodyCondition","T4","Days_to_Hatch")])
ED1_complete <- na.omit(ED1_scaled[, c("PFOS","BodyCondition","T3_T4")])
ED1_complete <- na.omit(ED1_scaled[, c("PFNA","BodyCondition","T4","Days_to_Hatch")])
ED1_complete <- na.omit(ED1_scaled[, c("PFHxS","BodyCondition","T3_T4")])
ED1_complete <- na.omit(ED1_scaled[, c("PFUnA","BodyCondition","T3_T4")])

Dredge_LM_PFAS_H=dredge(lm(T4 ~  PFNA+
                             Days_to_Hatch+
                             BodyCondition+
                             PFNA:BodyCondition,
                           data=ED1_complete,
                           na.action = "na.fail"),
                        fixed = c()
)

View(Dredge_LM_PFAS_H)
# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_PFAS_H, subset = 1)[[1]])
summary(get.models(Dredge_LM_PFAS_H, subset = 2)[[1]])
summary(get.models(Dredge_LM_PFAS_H, subset = 3)[[1]])
summary(get.models(Dredge_LM_PFAS_H, subset = 4)[[1]])
summary(get.models(Dredge_LM_PFAS_H, subset = 5)[[1]])

#Model averaging 
avg_model <- model.avg(Dredge_LM_PFAS_H, subset = delta < 4)
summary(avg_model)

sw(avg_model)
#Output 1)
ED1_complete <- na.omit(ED1_scaled[, c("PFAS_SUM","BodyCondition","T4")])
ED1_complete <- na.omit(ED1_scaled[, c("PFAS_SUM","BodyCondition","T4","Days_to_Hatch")])
LM_PFNA_H <- lm(T4~ PFAS_SUM*BodyCondition, data=ED1_complete)
summary(LM_PFNA_H)
nobs(LM_PFNA_H)

par(mfrow = c(2, 2))  
plot(LM_PFNA_H)  
shapiro.test(residuals(LM_PFNA_H))
hist(residuals(LM_PFNA_H), breaks = 20, main = "Histogram of Residuals")
#
#Influential points 
library(car)
influencePlot(LM_PFNA_H)
# OR
cooksd <- cooks.distance(LM_PFNA_H)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_complete) - length(coef(LM_PFNA_H)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(ED1_complete) - length(coef(LM_PFNA_H)) - 1))
infl_obs
as.numeric(rownames(LM_PFNA_H$model)[infl_obs])

#Re-running without influential points 
ED1_sub <- ED1_complete[-c(1,22,23),]
LM_PFNA_H <- lm(T4~ PFAS_SUM*BodyCondition, data=ED1_sub)
summary(LM_PFNA_H)
nobs(LM_PFNA_H)
#
#
##Plot
bc_mean <- mean(ED1_complete$BodyCondition, na.rm = TRUE)
bc_sd   <- sd(ED1_complete$BodyCondition, na.rm = TRUE)
bc_vals <- round(c(bc_mean - bc_sd, bc_mean, bc_mean + bc_sd), 4)

pred <- ggpredict(LM_PFNA_H, terms = c("PFAS_SUM", paste0("BodyCondition [", paste(bc_vals, collapse = ", "), "]")))

pred$group <- factor(pred$group,
                     levels = unique(pred$group),
                     labels = c("Mean - SD", "Mean", "Mean + SD"))
pal <- c("Mean - SD" = "#AEC6E8", 
         "Mean"      = "#6495ED", 
         "Mean + SD" = "#003F87")

ggplot(pred, aes(x = x, y = predicted, color = group, fill = group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
              alpha = 0.2, color = NA) +
  geom_point(data = ED1_complete,
             aes(x = PFAS_SUM, y = T4),
             inherit.aes = FALSE,
             size = 2, alpha = 0.6, color = "cornflowerblue") +
  scale_color_manual(values = pal) +
  scale_fill_manual(values = pal) +
  labs(x = "∑PFAS (scaled)",
       y = "T4 (scaled)",
       color = "Body Condition",
       fill  = "Body Condition") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )
#
#Output 2)
ED1_complete <- na.omit(ED1_scaled[, c("PFNA","BodyCondition","T4","Days_to_Hatch")])
LM_PFNA_H <- lm(T4~ PFNA*BodyCondition, data=ED1_complete)
summary(LM_PFNA_H)
nobs(LM_PFNA_H)

par(mfrow = c(2, 2))  
plot(LM_PFNA_H)  
shapiro.test(residuals(LM_PFNA_H))
hist(residuals(LM_PFNA_H), breaks = 20, main = "Histogram of Residuals")
#
#Influential points 
library(car)
influencePlot(LM_PFNA_H)
# OR
cooksd <- cooks.distance(LM_PFNA_H)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_complete) - length(coef(LM_PFNA_H)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(ED1_complete) - length(coef(LM_PFNA_H)) - 1))
infl_obs
as.numeric(rownames(LM_PFNA_H$model)[infl_obs])

#Re-running without influential points 
ED1_sub <- ED1_complete[-c(1,16,22),]
LM_PFNA_H <- lm(T4~ PFNA*BodyCondition, data=ED1_sub)
summary(LM_PFNA_H)
nobs(LM_PFNA_H)
#
#
##Plot
bc_mean <- mean(ED1_complete$BodyCondition, na.rm = TRUE)
bc_sd   <- sd(ED1_complete$BodyCondition, na.rm = TRUE)
bc_vals <- round(c(bc_mean - bc_sd, bc_mean, bc_mean + bc_sd), 4)

pred <- ggpredict(LM_PFNA_H, terms = c("PFNA", paste0("BodyCondition [", paste(bc_vals, collapse = ", "), "]")))

pred$group <- factor(pred$group,
                     levels = unique(pred$group),
                     labels = c("Mean - SD", "Mean", "Mean + SD"))
pal <- c("Mean - SD" = "#AEC6E8", 
         "Mean"      = "#6495ED", 
         "Mean + SD" = "#003F87")

ggplot(pred, aes(x = x, y = predicted, color = group, fill = group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high),
              alpha = 0.2, color = NA) +
  geom_point(data = ED1_complete,
             aes(x = PFNA, y = T4),
             inherit.aes = FALSE,
             size = 2, alpha = 0.6, color = "cornflowerblue") +
  scale_color_manual(values = pal) +
  scale_fill_manual(values = pal) +
  labs(x = "PFNA (scaled)",
       y = "T4 (scaled)",
       color = "Body Condition",
       fill  = "Body Condition") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

#
#---- Q5) Hatching success, turning frequency, egg temperature and PFAS ----
#------Goldeneye------
GD1 <- GD1%>%
  rename(Hatched_eggs = `Hatched eggs`)

GD1_scaled <- GD1
GD1_scaled$ClutchSize <- GD1$ClutchSize
GD1_scaled$Hatched_eggs <- GD1$Hatched_eggs
#class(GD1_scaled$ClutchSize)
GD1_scaled$PFAS_SUM <- as.numeric(scale(GD1$PFAS_SUM))
GD1_scaled$PFOS <- as.numeric(scale(GD1$PFOS))
GD1_scaled$PFDoDA <- as.numeric(scale(GD1$PFDoDA))
GD1_scaled$PFNA <- as.numeric(scale(GD1$PFNA))
GD1_scaled$PFUnA <- as.numeric(scale(GD1$PFUnA))
GD1_scaled$AVG_Temp_egg_Hour <- as.numeric(scale(GD1$AVG_Temp_egg_Hour))
GD1_scaled$BodyCondition <- as.numeric(scale(GD1$BodyCondition))
GD1_scaled$AVG_turns_hour <- as.numeric(scale(GD1$AVG_turns_hour))

#Correlation check
COR <- GD1[, c("AVG_turns_hour","PFAS_SUM", "ClutchSize", "BodyCondition","AVG_Temp_egg_Hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model selection 
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFAS_SUM","Hatched_eggs","ClutchSize","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFOS","Hatched_eggs","ClutchSize","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFNA","T4","BodyCondition","Hatched_eggs","ClutchSize","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFDoDA","Hatched_eggs","ClutchSize","AVG_turns_hour")])
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFUnA","Hatched_eggs","ClutchSize","AVG_turns_hour")])

Dredge_GLM_Hatch <- dredge(
  glm(
    cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~  
      PFOS +
            #PFNA:T4+
      #BodyCondition+
      #PFNA:BodyCondition+
      AVG_turns_hour+
      AVG_Temp_egg_Hour,
    data = GD1_complete,
    family = binomial,
    na.action = "na.fail"),
  fixed = c()
)

View(Dredge_GLM_Hatch)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_GLM_Hatch, subset = 1)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 2)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 3)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 4)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 5)[[1]])
#Model averaging 
avg_model <- model.avg(Dredge_GLM_Hatch, subset = delta < 4)
summary(avg_model)
sw(avg_model)

# Output 1)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFAS_SUM","Hatched_eggs","ClutchSize","AVG_turns_hour")])
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFAS_SUM +AVG_Temp_egg_Hour, family = binomial(), data = GD1_complete)

summary(GDHatch)
nobs(GDHatch)
#Model check
simres <- simulateResiduals(GDHatch) 
plot(simres)
testDispersion(simres)

GDNull <- glmmTMB(cbind(Hatched_eggs, ClutchSize)~ 1, family= binomial(), data=GD1_complete)
AICc(GDNull, GDHatch)
#Influential points
# OR
cooksd <- cooks.distance(GDHatch)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_complete) - length(coef(GDHatch)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(GD1_complete) - length(coef(GDHatch)) - 1))
infl_obs
#To make sure which observation is the influential 
as.numeric(rownames(GDHatch$model)[infl_obs])

#IF needed! Re-running the model with the subset, excluding the influential points: 
GD1_sub<- GD1_complete[-c(9,15), ]  # Removes the second row
#MODEL
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFAS_SUM +AVG_Temp_egg_Hour, family = binomial(), data = GD1_sub)
summary(GDHatch)
nobs(GDHatch)
#
# Output 2)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFOS","Hatched_eggs","ClutchSize","AVG_turns_hour")])
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFOS +AVG_Temp_egg_Hour, family = binomial(), data = GD1_complete)
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFOS, family = binomial(), data = GD1_complete) # Caused by an influential point

summary(GDHatch)
nobs(GDHatch)
#Model check
simres <- simulateResiduals(GDHatch) 
plot(simres)
testDispersion(simres)

GDNull <- glmmTMB(cbind(Hatched_eggs, ClutchSize)~ 1, family= binomial(), data=GD1_complete)
AICc(GDNull, GDHatch)
#Influential pointss
cooksd <- cooks.distance(GDHatch)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_complete) - length(coef(GDHatch)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(GD1_complete) - length(coef(GDHatch)) - 1))
infl_obs
#To make sure which observation is the influential 
as.numeric(rownames(GDHatch$model)[infl_obs])

#IF needed! Re-running the model with the subset, excluding the influential points: 
GD1_sub<- GD1_complete[-c(9,15), ]  # Removes the second row
#MODEL
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFOS +AVG_Temp_egg_Hour, family = binomial(), data = GD1_sub)
summary(GDHatch)
nobs(GDHatch)
#
# Output 3)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFDoDA","Hatched_eggs","ClutchSize","AVG_turns_hour")])
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFDoDA +AVG_Temp_egg_Hour, family = binomial(), data = GD1_complete)
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFDoDA , family = binomial(), data = GD1_complete)
summary(GDHatch)
nobs(GDHatch)
#Model check
simres <- simulateResiduals(GDHatch) 
plot(simres)
testDispersion(simres)

GDNull <- glmmTMB(cbind(Hatched_eggs, ClutchSize)~ 1, family= binomial(), data=GD1_complete)
AICc(GDNull, GDHatch)
#Influential points
library(car)
influencePlot(GDHatch)  # Plots influence, labels extreme cases
# OR
cooksd <- cooks.distance(GDHatch)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_complete) - length(coef(GDHatch)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(GD1_complete) - length(coef(GDHatch)) - 1))
infl_obs
#To make sure which observation is the influential 
as.numeric(rownames(GDHatch$model)[infl_obs])

GD1_sub<- GD1_complete[-9, ]  # Removes the second row
#MODEL
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFDoDA , family = binomial(), data = GD1_sub)

GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize-Hatched_eggs) ~ PFOS, family = binomial(), data = GD1_sub)

summary(GDHatch)
nobs(GDHatch)
confint(GDHatch)
#

#
#Plot
# Egg temperature on hatching success 
#GD11 <- GD1
GD1_sub$HatchingSuccess <- GD1_sub$Hatched_eggs / GD1_sub$ClutchSize

newdat <- data.frame(
  AVG_Temp_egg_Hour = seq(min(GD1_sub$AVG_Temp_egg_Hour, na.rm = TRUE),
                          max(GD1_sub$AVG_Temp_egg_Hour, na.rm = TRUE),
                          length.out = 100),
  PFDoDA = mean(GD1_sub$PFDoDA, na.rm = TRUE)
)

# Add predicted probabilities and SEs
pred <- predict(GDHatch, newdata = newdat, type = "link", se.fit = TRUE)

newdat$predicted <- plogis(pred$fit)
newdat$lwr <- plogis(pred$fit - 1.96 * pred$se.fit)
newdat$upr <- plogis(pred$fit + 1.96 * pred$se.fit)

ggplot(newdat, aes(x = AVG_Temp_egg_Hour, y = predicted)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "#B8800B", alpha = 0.2) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_point(data = GD1_sub, aes(x = AVG_Temp_egg_Hour, y = HatchingSuccess),
             inherit.aes = FALSE,color = "#B8800B", alpha = 0.5, size = 2) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = "",
    x = "Average egg temperature (°C)",
    y = "Predicted hatching success"
  )
###AND 
GD1_sub$HatchingSuccess <- GD1_sub$Hatched_eggs / GD1_sub$ClutchSize

newdat <- data.frame(
  PFDoDA = seq(min(GD1_sub$PFDoDA, na.rm = TRUE),
                          max(GD1_sub$PFDoDA, na.rm = TRUE),
                          length.out = 100),
  AVG_Temp_egg_Hour = mean(GD1_sub$AVG_Temp_egg_Hour, na.rm = TRUE)
)

# Add predicted probabilities and SEs
pred <- predict(GDHatch, newdata = newdat, type = "link", se.fit = TRUE)

newdat$predicted <- plogis(pred$fit)
newdat$lwr <- plogis(pred$fit - 1.96 * pred$se.fit)
newdat$upr <- plogis(pred$fit + 1.96 * pred$se.fit)

ggplot(newdat, aes(x = PFDoDA, y = predicted)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "#B8800B", alpha = 0.2) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_point(data = GD1_sub, aes(x = PFDoDA, y = HatchingSuccess),
             inherit.aes = FALSE,color = "#B8800B", alpha = 0.5, size = 2) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = "",
    x = "PFDoDA",
    y = "Predicted hatching success"
  )

#
#------ Eider------
ED1 <- ED1%>%
  rename(Hatched_remains = `Hatched remains`)

ED1_scaled <- ED1
ED1_scaled$PFAS_SUM <- as.numeric(scale(ED1$PFAS_SUM))
ED1_scaled$PFOS <- as.numeric(scale(ED1$PFOS))
ED1_scaled$PFUnA <- as.numeric(scale(ED1$PFUnA))
ED1_scaled$PFHxS <- as.numeric(scale(ED1$PFHxS))
ED1_scaled$PFNA <- as.numeric(scale(ED1$PFNA))
ED1_scaled$BodyCondition <- as.numeric(scale(ED1$BodyCondition))
ED1_scaled$AVG_turns_hour <- as.numeric(scale(ED1$AVG_turns_hour))
ED1_scaled$AVG_Temp_egg_Hour <- as.numeric(scale(ED1$AVG_Temp_egg_Hour))
ED1_scaled$Hatched_remains <- as.numeric(ED1_scaled$Hatched_remains)
ED1_scaled$ClutchSize <- as.numeric(ED1_scaled$ClutchSize)
# Checking whether body condition varies across incuation stages 
#hist(ED1_scaled$BodyCondition)
#levels(ED1_scaled$Incubation_stage)
#BODY <- lm(BodyCondition~ Incubation_stage, data= ED1_scaled)
#summary(BODY)
#ED1_scaled$Incubation_stage <- factor(
 # ED1_scaled$Incubation_stage,
  #levels = c("Early.breeder", "Peak.incubation", "Late.breeder"))
#anova_result <- aov(BodyCondition~ Incubation_stage, data = ED1_scaled)
#summary(anova_result)

#ggplot(ED1_scaled, aes(x = Incubation_stage, y = BodyCondition)) +
 # geom_boxplot(fill = "cornflowerblue", alpha = 0.6) +
 # theme_minimal() +
  #labs(x = "Incubation Stage", y = "Body Condition")
#Correlation check

COR <- ED1_scaled[, c("AVG_Temp_egg_Hour","PFNA","T4","BodyCondition","Hatched_remains","ClutchSize","AVG_turns_hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model selection 
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFAS_SUM","Hatched_remains","ClutchSize","AVG_turns_hour")])
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFOS","Hatched_remains","ClutchSize","AVG_turns_hour")])
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFNA","Hatched_remains","ClutchSize","AVG_turns_hour")])
#ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFNA","T4","BodyCondition","Hatched_remains","ClutchSize","AVG_turns_hour")])
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFHxS","Hatched_remains","ClutchSize","AVG_turns_hour")])
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFUnA","Hatched_remains","ClutchSize","AVG_turns_hour")])

Dredge_GLM_Hatch=dredge(glm(cbind(Hatched_remains, ClutchSize-Hatched_remains) ~  PFHxS+
                              AVG_turns_hour+
                              #PFNA:AVG_turns_hour+
                              #PFNA:AVG_Temp_egg_Hour+
                              AVG_Temp_egg_Hour,
                              #BodyCondition+
                              #T4+
                              #PFNA:BodyCondition,
                              #PFNA:T4,
                              #Incubation_stage,
                            data=ED1_complete,
                            family= binomial,
                            na.action = "na.fail"),
                        fixed = c()
)

View(Dredge_GLM_Hatch)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_GLM_Hatch, subset = 1)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 2)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 3)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 4)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 5)[[1]])
#Model averaging 
avg_model <- model.avg(Dredge_GLM_Hatch, subset = delta < 4)
summary(avg_model)
sw(avg_model)

#Model output 1) 
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFAS_SUM","Hatched_remains","ClutchSize","AVG_turns_hour")])
EDHatch <- glm(
  cbind(Hatched_remains, ClutchSize-Hatched_remains) ~ PFAS_SUM +AVG_Temp_egg_Hour, family = binomial(), data = ED1_complete)

summary(EDHatch)
nobs(EDHatch)
simres <- simulateResiduals(EDHatch) 
plot(simres)
testDispersion(simres)

#Model output 4) 
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFHxS","Hatched_remains","ClutchSize","AVG_turns_hour","HatchingSuccess")])
EDHatch <- glm(
  cbind(Hatched_remains, ClutchSize-Hatched_remains) ~ PFHxS,family = binomial(), data = ED1_complete)

summary(EDHatch)
nobs(EDHatch)
simres <- simulateResiduals(EDHatch) 
plot(simres)
testDispersion(simres)

#Influential points
# OR
cooksd <- cooks.distance(EDHatch)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_complete) - length(coef(EDHatch)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(ED1_complete) - length(coef(EDHatch)) - 1))
infl_obs
#To make sure which observation is the influential 
as.numeric(rownames(EDHatch$model)[infl_obs])

#IF needed! Re-running the model with the subset, excluding the influential points: 
ED1_sub<- ED1_complete[-12, ]  # Removes the second row
#MODEL
EDHatch <- glm(
  cbind(Hatched_remains, ClutchSize-Hatched_remains) ~ PFHxS,family = binomial(), data = ED1_sub)

summary(EDHatch)
nobs(EDHatch)

#Plotting
newdat <- data.frame(
  PFHxS = seq(min(ED1_complete$PFHxS, na.rm = TRUE),
              max(ED1_complete$PFHxS, na.rm = TRUE),
              length.out = 100))

# Add predicted probabilities and SEs
pred <- predict(EDHatch, newdata = newdat, type = "link", se.fit = TRUE)

newdat$predicted <- plogis(pred$fit)
newdat$lwr <- plogis(pred$fit - 1.96 * pred$se.fit)
newdat$upr <- plogis(pred$fit + 1.96 * pred$se.fit)

ED1_complete$HatchingSuccess <- ED1_complete$Hatched_remains / ED1_complete$ClutchSize

ggplot(newdat, aes(x = PFHxS, y = predicted)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr),
              fill = "cornflowerblue", alpha = 0.2) +
  geom_line(color = "cornflowerblue", size = 1.2) +
  geom_point(data = ED1_complete,
             aes(x = PFHxS, y = HatchingSuccess),
             color = "cornflowerblue", alpha = 0.6, size = 2.5) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    plot.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    legend.position = c(0.94, 0.86)
  ) +
  labs(
    title = "",
    x = "PFHxS (scaled)",
    y = "Predicted hatching success"
  )








#OR# 
##Modeling the absolute hatching success 
#ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFAS_SUM","Absolute_Hatch","ClutchSize")])
#ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFHxS","Absolute_Hatch","ClutchSize")])

#Dredge_GLM_Hatch=dredge(glm(Absolute_Hatch ~  PFHxS +
 #                             #AVG_turns_hour+
  #                            AVG_Temp_egg_Hour+
   #                           #BodyCondition+
    #                          ClutchSize,
     #                       data=ED1_complete,
      #                      family= binomial,
       #                     na.action = "na.fail"),
        #                fixed = c()
         #               
#)
#
#View(Dredge_GLM_Hatch)

# if you want to view summary() of the model with the lowest AICc
#summary(get.models(Dredge_GLM_Hatch, subset = 1)[[1]])




###--Bootstrapping the sig. results----####
#1)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFAS_SUM","BodyCondition","ClutchSize")])
GD_AvgTURNS<- lm(AVG_turns_hour~ PFAS_SUM, data=GD1_complete)
summary(GD_AvgTURNS)
#---#
library(boot)
#Boostrap function 
boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(AVG_turns_hour ~ PFAS_SUM, data = d)
  return(coef(fit))  # extract coefficients
}
#
set.seed(123)
boot_results <- boot(data = GD1_complete, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 1)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  return(cor(d$PFAS_SUM, d$AVG_turns_hour))
}

boot_results_cor <- boot(data = GD1_complete, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "#B8800B", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#2)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFUnA","BodyCondition","ClutchSize")])
PFUnA_AvgTURNS <- lm(AVG_turns_hour~ PFUnA, data=GD1_complete)
summary(PFUnA_AvgTURNS)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(AVG_turns_hour ~ PFUnA, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = GD1_complete, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 2)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  return(cor(d$PFUnA, d$AVG_turns_hour))
}

boot_results_cor <- boot(data = GD1_complete, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "#B8800B", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#3)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFOS","BodyCondition","ClutchSize")])
PFOS_AvgTURNS <- lm(AVG_turns_hour~ PFOS, data=GD1_complete)
summary(PFOS_AvgTURNS)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(AVG_turns_hour ~ PFOS, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = GD1_complete, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 3)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  return(cor(d$PFOS, d$AVG_turns_hour))
}

boot_results_cor <- boot(data = GD1_complete, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "#B8800B", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#4)
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","T3","PFNA","BodyCondition","ClutchSize")])
PFNA_AvgTURNS <- lm(AVG_turns_hour~ PFNA+BodyCondition, data=GD1_complete)
summary(PFNA_AvgTURNS)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(AVG_turns_hour ~ PFNA+BodyCondition, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = GD1_complete, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 4)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  return(cor(d$PFNA, d$AVG_turns_hour))
}

boot_results_cor <- boot(data = GD1_complete, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "#B8800B", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#5) 
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","T3","PFUnA","BodyCondition","AVG_turns_hour")])
PFUnA_AVGTemp <- lm(AVG_Temp_egg_Hour~ PFUnA, data=GD1_complete)
summary(PFUnA_AVGTemp)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(AVG_Temp_egg_Hour ~ PFUnA, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = GD1_complete, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 5)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  return(cor(d$PFUnA, d$AVG_Temp_egg_Hour))
}

boot_results_cor <- boot(data = GD1_complete, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "#B8800B", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#6)
GD1_complete <- na.omit(GD1_scaled[, c("T4","PFNA","BodyCondition","Days_to_Hatch")])
PFAS_T4 <- lm(T4~ PFNA+BodyCondition, data=GD1_complete)
summary(PFAS_T4)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(T4 ~ PFNA+BodyCondition, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = GD1_complete, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 6)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  return(cor(d$PFNA, d$T4))
}

boot_results_cor <- boot(data = GD1_complete, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "#B8800B", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#7)
LM_EDTemp<- lm(AVG_Temp_egg_Hour~ PFAS_SUM+AVG_turns_hour, data=ED1_scaled)
summary(LM_EDTemp)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(AVG_Temp_egg_Hour ~ PFAS_SUM+AVG_turns_hour, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = ED1_scaled, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 7)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  r <- try(cor(d$PFAS_SUM, d$AVG_Temp_egg_Hour, use = "complete.obs"), silent = TRUE)
  if (is.na(r) | inherits(r, "try-error")) r <- NA
  return(r)
}

boot_results_cor <- boot(data = ED1_scaled, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "cornflowerblue", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#8)
PFOS_AVGTemp<-  lm(AVG_Temp_egg_Hour~ PFOS, data=ED1_scaled)
summary(PFOS_AVGTemp)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(AVG_Temp_egg_Hour ~ PFOS, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = ED1_scaled, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 8)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  r <- try(cor(d$PFOS, d$AVG_Temp_egg_Hour, use = "complete.obs"), silent = TRUE)
  if (is.na(r) | inherits(r, "try-error")) r <- NA
  return(r)
}

boot_results_cor <- boot(data = ED1_scaled, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "cornflowerblue", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#
#9)
ED1_complete <- na.omit(ED1_scaled[, c("PFAS_SUM","BodyCondition","T4","Days_to_Hatch")])
LM_PFNA_H <- lm(T4~ PFAS_SUM*BodyCondition, data=ED1_complete)
summary(LM_PFNA_H)

boot_fun <- function(data, indices) {
  d <- data[indices, ]  # resample the data
  fit <- lm(T4 ~ PFAS_SUM*BodyCondition, data = d)
  return(coef(fit))  # extract coefficients
}
#
boot_results <- boot(data = ED1_complete, statistic = boot_fun, R = 5000)

boot_results
boot.ci(boot_results, type = "perc", index = 2)

#Plot 9)
boot_fun_cor <- function(data, indices) {
  d <- data[indices, ]
  r <- try(cor(d$PFAS_SUM, d$T4, use = "complete.obs"), silent = TRUE)
  if (is.na(r) | inherits(r, "try-error")) r <- NA
  return(r)
}

boot_results_cor <- boot(data = ED1_complete, statistic = boot_fun_cor, R = 5000)
boot_results_cor 
boot.ci(boot_results_cor, type = "perc")

boot_r <- boot_results_cor$t[,1]        # now this is r
original_r <- boot_results_cor$t0[1]

ci_r <- boot.ci(boot_results_cor, type = "perc")$percent[4:5]

plot_data <- data.frame(r = boot_r)

ggplot(plot_data, aes(x = r)) +
  geom_histogram(binwidth = 0.02, fill = "cornflowerblue", color = "black", alpha = 0.7) +
  geom_vline(xintercept = original_r, color = "red", size = 1.2) +
  geom_vline(xintercept = ci_r, color = "green", linetype = "dashed", size = 1) +
  labs(
    title = "",
    x = "Pearson correlation (r)",
    y = "Correaltion frequency"
  ) + theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
#

#
#### Additional plots #### 
#From the raw data. Individual example
#Cumpative hourly turns as a function of euler angle change in an individual
library(circular)
library(lubridate)
library(tidyverse)

GD1$Overal_angularChange_mean <- as.numeric(GD1$Overal_angularChange_mean)

#1)
#Euler angle based on Euler theorom
GDEX <- `GD11(K07)`

GDEX <- GDEX %>%
  mutate(FemaleID = "HT107525")

GDEX <- GDEX %>%
  mutate(AVG_turns_hour = 1.306)

GDEX <- GDEX %>%
  mutate(`Overall mean angular change` = 17.021)

GDEX <- GDEX %>%
  mutate(Euler_Angle = circular(sqrt(Roll^2 + Pitch^2 + Yaw^2), units="degrees")) 

GDSUM1 <- GDEX %>%
  group_by(FemaleID) %>%
  arrange(FemaleID) %>%
  mutate(
    cum_turns = cumsum(AVG_turns_hour),
    cum_angular_change = cumsum(`Overall mean angular change`)
  )


ggplot(GDSUM1, aes(x = cum_angular_change, y = cum_turns, color = as.factor(FemaleID))) +
  geom_line(size = 1, alpha = 0.6) + 
  geom_point() +  
  geom_smooth(method = "loess", aes(group = 1), color = "black", se = TRUE) + 
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.96, 0.32),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = "",
    x = "Cumulative Angular Change (degrees)",
    y = "Cumulative Egg Turns (per hour)",
    color = "FemaleID"
  )



##Trnaslation of the code from Matlab
install.packages("R.matlab")
library(R.matlab)
#5 example eider females 
dAngle1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle1.mat")
dataSave1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave1.mat")
deltaAngle1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle1.mat")
time1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time1.mat")
startInd1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd1.mat")
endInd1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd1.mat")
#
dAngle2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle2.mat")
dataSave2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave2.mat")
deltaAngle2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle2.mat")
time2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time2.mat")
startInd2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd2.mat")
endInd2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd2.mat")
# 
dAngle3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle3.mat")
dataSave3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave3.mat")
deltaAngle3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle3.mat")
time3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time3.mat")
startInd3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd3.mat")
endInd3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd3.mat")
#
dAngle4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle4.mat")
dataSave4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave4.mat")
deltaAngle4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle4.mat")
time4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time4.mat")
startInd4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd4.mat")
endInd4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd4.mat")
#
dAngle5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle5.mat")
dataSave5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave5.mat")
deltaAngle5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle5.mat")
time5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time5.mat")
startInd5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd5.mat")
endInd5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd5.mat")

#2)
#dAngle <- dAngle1$dAngle
#dataSave <- dataSave1$dataSave
#deltaAngle <- deltaAngle1$deltaAngle
#time <- time1$time
#startInd <- startInd1$startInd
#endInd <- endInd1$endInd
individuals_data <- list(
  list(dAngle = dAngle1$dAngle, dataSave=dataSave1$dataSave, deltaAngle = deltaAngle1$deltaAngle, time = time1$time, startInd = startInd1$startInd, endInd = endInd1$endInd),
  list(dAngle = dAngle2$dAngle, dataSave=dataSave2$dataSave, deltaAngle = deltaAngle2$deltaAngle, time = time2$time, startInd = startInd2$startInd, endInd = endInd2$endInd),
  list(dAngle = dAngle3$dAngle, dataSave=dataSave3$dataSave, deltaAngle = deltaAngle3$deltaAngle, time = time3$time, startInd = startInd3$startInd, endInd = endInd3$endInd),
list(dAngle = dAngle4$dAngle, dataSave=dataSave4$dataSave, deltaAngle = deltaAngle4$deltaAngle, time = time4$time, startInd = startInd4$startInd, endInd = endInd4$endInd),
list(dAngle = dAngle5$dAngle, dataSave=dataSave5$dataSave, deltaAngle = deltaAngle5$deltaAngle, time = time5$time, startInd = startInd5$startInd, endInd = endInd5$endInd))
#3)

#threshold_deg <- 10
#threshold_rad <- threshold_deg * pi / 180

#indices_greater_than_threshold <- which(deltaAngle > threshold_rad)

#start_times <- time1[startInd[indices_greater_than_threshold]]
#end_times <- time1[endInd[indices_greater_than_threshold]]
all_num_events_per_hr <- list()
all_dAngle <- list()

#plot((dataSave[5, startInd] + dataSave[5, endInd]) / 2 / 3600, 
     #deltaAngle * 180 / pi, 
     #main = "Angle Change vs. Time", 
    # xlab = "Time [hr]", 
   #  ylab = "Change in Orientation [deg]", 
  #   pch = 20, 
 #    col = "blue")
#grid()

dAngle <- seq(0, 180, by = 1) * pi / 180
num_events_per_hr <- sapply(dAngle, function(angle) {
  3600 * sum(deltaAngle > angle) / (max(time) - min(time))
})

smooth_fit <- smooth.spline(dAngle * 180 / pi, num_events_per_hr, spar = 0.7)
#plot(dAngle * 180 / pi, num_events_per_hr, 
#   type = "l", 
#    col = "#B8800B", 
#   lwd=2,
#    main = "Rotations per Hour vs. Angular Threshold", 
#    xlab = "Angle Threshold [deg]", 
#   ylab = "Rotations per Hour", 
#   xaxp = c(0, 180, 9))

for (i in 1:length(individuals_data)) {
  # Access individual data
  individual <- individuals_data[[i]]
  
  deltaAngle <- individual$deltaAngle
  time <- individual$time
  startInd <- individual$startInd
  endInd <- individual$endInd
  
  # Calculate number of events per hour for this individual
  num_events_per_hr_individual <- sapply(dAngle, function(angle) {
    3600 * sum(deltaAngle > angle) / (max(time) - min(time))
  })
  
  # Store results
  all_num_events_per_hr[[i]] <- num_events_per_hr_individual
  all_dAngle[[i]] <- dAngle
}

combined_num_events_per_hr <- do.call(cbind, all_num_events_per_hr)
combined_dAngle <- all_dAngle[[1]]  # Assuming the same angles for all individuals

mean_num_events_per_hr <- apply(combined_num_events_per_hr, 1, mean)
sd_num_events_per_hr <- apply(combined_num_events_per_hr, 1, sd)
ci_lower <- mean_num_events_per_hr - 1.96 * (sd_num_events_per_hr / sqrt(ncol(combined_num_events_per_hr)))
ci_upper <- mean_num_events_per_hr + 1.96 * (sd_num_events_per_hr / sqrt(ncol(combined_num_events_per_hr)))


combined_dAngle_deg <- combined_dAngle * 180 / pi
x_value <- 10
y_value_at_x_10 <- approx(combined_dAngle_deg, mean_num_events_per_hr, xout = x_value)$y

y_lim <- range(c(mean_num_events_per_hr, ci_upper, ci_lower), na.rm = TRUE)

plot(combined_dAngle * 180 / pi, mean_num_events_per_hr, 
     type = "l", 
     col = "#B8800B", 
     lwd = 4,
     main = "", 
     xlab = "Anglular change [deg]", 
     ylab = "Cumulative turns per hour", 
     xaxp = c(0, 180, 9),
     bty="n",
     ylim=y_lim)

lines(combined_dAngle * 180 / pi, ci_upper, 
      col = "red", 
      lty = 2,  # Dashed line for upper CI
      lwd = 2)

lines(combined_dAngle * 180 / pi, ci_lower, 
      col = "red", 
      lty = 2,  # Dashed line for lower CI
      lwd = 2)

points(x_value, y_value_at_x_10, col = "black", pch = 20, cex = 1.5)


### Example of daily temperature 
#GD 1:
GDTem <- `GD11(K07)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#random_date <- sample(unique(GDTem$Date), 1)
#print(random_date)
random_date<- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span=0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = paste("Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 2: 
GDTem <- `GD81(K05)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 3: 
GDTem <- `GD219(K16)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 4: 
GDTem <- `GD96(K08)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )


### Eiders###
#ED 1:
EDTem <- `ED(B108W1.4)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#Either an assigned date
random_date <- as.Date("2023-05-29")
print(random_date)
#OR a random date
#random_date <- sample(unique(EDTem$Date), 1)
#print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span=0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = paste("(Late breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#ED 2: 
EDTem <- `ED(B102W2.4)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Late breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )
#ED3
EDTem <- `ED(B22W1.3)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

#random_date <- sample(unique(EDTem$Date), 1)
#print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Early breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#ED4

EDTem <- `ED(B23W2.3)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)


ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Early breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

##### Daily turning movement 
library(circular)
library(lubridate)
library(tidyverse)
#Euler angle 
# Eider 1
EDMove1 <- `ED(B23W2.3)`

EDMove1$Date <- as.Date(EDMove1$Date)  
EDMove1$Time <- as.POSIXct(paste(EDMove1$Date, EDMove1$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

ED_24h <- EDMove1 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable"
  )

# OR
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_line(size = 1, alpha = 0.7) +  # Reduce opacity for better readability
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  )+
  labs(
    title = paste("(Early breeder) - Roll, Yaw, and Pitch, Date:", random_date),
    x = "Time",
    y = "Euler Angles (degrees)",
    color = "Variable"
  )

# Eider 2
EDMove2 <- `ED(B22W1.3)`

EDMove2$Date <- as.Date(EDMove2$Date)  
EDMove2$Time <- as.POSIXct(paste(EDMove2$Date, EDMove2$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

ED_24h <- EDMove2 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# Eider 3
EDMove3<- `ED(B102W2.4)`

EDMove3$Date <- as.Date(EDMove3$Date)  
EDMove3$Time <- as.POSIXct(paste(EDMove3$Date, EDMove3$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDMove3 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# Eider 4
EDMove4<- `ED(B108W1.4)`

EDMove4$Date <- as.Date(EDMove4$Date)  
EDMove4$Time <- as.POSIXct(paste(EDMove4$Date, EDMove4$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDMove4 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

###In goldeneye
#GD1
GDMove1 <- `GD11(K07)`

GDMove1$Date <- as.Date(GDMove1$Date)  
GDMove1$Time <- as.POSIXct(paste(GDMove1$Date, GDMove1$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove1 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD2
GDMove2 <- `GD81(K05)`

GDMove2$Date <- as.Date(GDMove2$Date)  
GDMove2$Time <- as.POSIXct(paste(GDMove2$Date, GDMove2$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove2 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD3
GDMove3 <- `GD219(K16)`

GDMove3$Date <- as.Date(GDMove3$Date)  
GDMove3$Time <- as.POSIXct(paste(GDMove3$Date, GDMove3$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove3 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD4
GDMove4 <- `GD96(K08)`

GDMove4$Date <- as.Date(GDMove4$Date)  
GDMove4$Time <- as.POSIXct(paste(GDMove4$Date, GDMove4$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove4 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
library(dplyr)
library(tidyr)

GD_24h_long <- GD_24h %>%
  dplyr::select(Time, Roll, Yaw, Pitch) %>%
  tidyr::pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")


# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

####### Euler+Temp plot#####
#GD4
library(patchwork)

GDData <- `GD11(K07)`
# Convert Date and Time
GDData$Date <- as.Date(GDData$Date)  
GDData$Time <- as.POSIXct(paste(GDData$Date, GDData$Time), format="%Y-%m-%d %H:%M:%S")

# Select Date
selected_date <- as.Date("2022-05-15")
#start_date <- as.Date("2022-05-15 00:00:00")
#end_date <- as.Date("2022-05-19 00:00:00")
#GD_MultiDay <- GDData %>%
 # filter(Date >= start_date & Date <= end_date)
# Filter Data for 24 hours
GD_24h <- GDData %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

# First Plot: Egg Temperature
p1 <- ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Temperature (°C)",
    x = ""
  ) +
  #coord_cartesian(ylim = c(NA, 43)) + 
  scale_y_continuous(
    limits = c(35, 43),
    expand = c(0, 0),
    breaks = seq(35, 42.5, by = 2.5))+
  theme_minimal()+
  theme(
    axis.text.x = element_blank(),   # remove x-axis text
    axis.ticks.x = element_blank(),  # remove x-axis ticks
    axis.title.x = element_blank()   # remove x-axis label
  )
#theme(
 # panel.background = element_rect(fill = "transparent", colour = NA),
  #axis.line = element_line(color = "black"),
  #axis.text.x = element_text(angle = 45, hjust = 1),
  #plot.background = element_rect(fill = "transparent", colour = NA)
#)

# Second Plot: Euler Angle (On its Own Scale)
p2 <- ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha = 0.8, linewidth = 1) +
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Angular change (°)",
    x = "Time"
  ) +
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis.title.x = element_blank()
  )

# Combine the two plots with the same X-axis
p1 / p2  # Using `patchwork` to stack them vertically

## ED4

EDdata <- `ED(B108W1.4)`

EDdata$Date <- as.Date(EDdata$Date)  
EDdata$Time <- as.POSIXct(paste(EDdata$Date, EDdata$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#Either an assigned date
#selected_date <- as.Date("2023-05-29")
#print(selected_date)
#OR a random date
random_date <- sample(unique(EDdata$Date), 1)
print(random_date)
#or
#random_date<- as.Date("2023-06-02")

ED_24h <- EDdata %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

p1 <- ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "cornflowerblue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Temperature (°C)",
    x = ""
  ) +
  scale_y_continuous(
    limits = c(35, 42.5),
    expand = c(0, 0),
    breaks = seq(35, 42.5, by = 2.5))+
  theme_minimal()+
  theme(
    axis.text.x = element_blank(),   # remove x-axis text
    axis.ticks.x = element_blank(),  # remove x-axis ticks
    axis.title.x = element_blank()   # remove x-axis label
  )
#theme(
# panel.background = element_rect(fill = "transparent", colour = NA),
#axis.line = element_line(color = "black"),
#axis.text.x = element_text(angle = 45, hjust = 1),
#plot.background = element_rect(fill = "transparent", colour = NA)
#)

# Second Plot: Euler Angle (On its Own Scale)
p2 <- ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "cornflowerblue", alpha = 0.8, size = 1) +
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Angular change (°)",
    x = "Time"
  ) +
  coord_cartesian(ylim = c(0, 50)) + 
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis.title.x = element_blank()
  )

# Combine the two plots with the same X-axis
p1 / p2  # Using `patchwork` to stack them vertically


