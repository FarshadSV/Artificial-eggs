#Upload packages 
library(ggplot2)
library(ggeffects)
library(effects)
library(lme4)
library(lmerTest)
library(glmmTMB)
library(emmeans)
library(Matrix)
library(lmerTest)
library(dplyr)
library(writexl)
library(DHARMa)
library(performance)
library(car)
library(Hmisc)
library(MASS)
library(betareg)
library(lmtest)
#R.version.string
#citation()
#Upload datasets 
ED1 <- ED1_Modeling
ED2 <- ED2_Modeling
GD1 <- GD1_Final
GD2 <- GD2_Final

#Creating a column for T4:T3 ratio: 
GD1 <- GD1%>%
  mutate("T3_T4"= `T3 (pg.ul)`/`T4 (pg.ul)`)
GD2 <- GD2%>%
  mutate("T3_T4"= `T3 (pg.ul)`/`T4 (pg.ul)`)

ED1 <- ED1%>%
  mutate("T3_T4"= `T3 (pg.ul)` /`T4 (pg.ul)`)
ED2 <- ED2%>%
  mutate("T3_T4"= `T3 (pg.ul)`/`T4 (pg.ul)`)

#Renaming columns for simplicity 
GD1 <- GD1%>%
  rename( PFAS_SUM = `PFAS(SUM)`,
          AVG_Temp_egg_Hour = `AVG.Temp.egg (Hour)`,
          AVG_Temp_out_Hour= `AVG.Temp.out (Hour)`,
          T3= `T3 (pg.ul)`, 
          T4= `T4 (pg.ul)`,
    AVG_turns_hour=`AVG.Egg turning frequency (Overall/Hour)`,
    Day_turns =`Day/Hr egg turning`,
    Night_turns=`Night/Hr egg turning`,
    Overal_angularChange_mean=`Overall mean angular change`
  )

ED1 <- ED1%>%
  rename( PFAS_SUM = `PFAS(Sum)`,
          AVG_Temp_egg_Hour = `AVG.Temp.egg (Hour)`,
          AVG_Temp_out_Hour= `AVG.Temp.out (Hour)`,
          T3= `T3 (pg.ul)`, 
          T4= `T4 (pg.ul)`,
          AVG_turns_hour=`AVG.Egg turning frequency (Overall/Hour)`,
          Incubation_stage =`Incubation stage`, 
          Day_turns =`Day/Hr egg turning`,
          Night_turns=`Night/Hr egg turning`,
          Overal_angularChange_mean=`Overall mean angular change`
  )
#Making the weighted average for the egg attendance for the nests with 2 loggers 
#Weighted average egg turning rate= (Egg turning all*recorded hours)1 + (Egg turning all* recorded hours)2 / Recorded hours 1+ Recorded hours 2
#1) K26 (Overall turns divided by overall recorded hours)
eggTurn1 <- 33/668
eggTurn2 <- 48/75
AVG_egg_turns_weighted1 <- (eggTurn1 * 668 + eggTurn2 * 75) / (668 + 75)
GD1$AVG_turns_hour[7] <- 0.109

eggTemp1 <- 41.98
eggTemp2 <- 37.50
AVG_egg_Temp_weighted1 <- (eggTemp1 * 668 + eggTemp2 * 75) / (668 + 75)
GD1$AVG_Temp_egg_Hour[7] <- 41.527
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 0.052
Euler_night1 <- 0.041
Euler_day2 <- 0.741
Euler_night2 <- 0.277
Day_turn_weighted <- (Euler_day1 * 668 + Euler_day2 * 75) / (668 + 75)
Night_turn_weighted <- (Euler_night1 * 668 + Euler_night2 * 75) / (668 + 75)
GD1$Day_turns[7]<- 0.121
GD1$Night_turns[7]<- 0.064

# K22
eggTurn1 <- 771/567
eggTurn2 <- 103/85
AVG_egg_turns_weighted1 <- (eggTurn1 * 567 + eggTurn2 * 85) / (567 + 85)
GD1$AVG_turns_hour[6] <- 1.340

eggTemp1 <- 39.865
eggTemp2 <- 41.526
AVG_egg_Temp_weighted1 <- (eggTemp1 * 567 + eggTemp2 * 85) / (567 + 85)
GD1$AVG_Temp_egg_Hour[6] <- 40.081
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 1.410
Euler_night1 <- 1.215
Euler_day2 <- 1.440
Euler_night2 <- 0.625
Day_turn_weighted <- (Euler_day1 * 567 + Euler_day2 * 85) / (567 + 85)
Night_turn_weighted <- (Euler_night1 * 567 + Euler_night2 * 85) / (567 + 85)
GD1$Day_turns[6]<- 1.413
GD1$Night_turns[6]<- 1.138

# K23
eggTurn1 <- 49/80
eggTurn2 <- 50/78
AVG_egg_turns_weighted1 <- (eggTurn1 * 80 + eggTurn2 * 78) / (80 + 78)
GD1$AVG_turns_hour[17] <- 0.626

eggTemp1 <- 40.911
eggTemp2 <- 40.974
AVG_egg_Temp_weighted1 <- (eggTemp1 * 80 + eggTemp2 * 78) / (80 + 78)
GD1$AVG_Temp_egg_Hour[17] <- 40.942
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 0.716
Euler_night1 <- 0.265
Euler_day2 <- 0.726
Euler_night2 <- 0.333
Day_turn_weighted <- (Euler_day1 * 80 + Euler_day2 * 78) / (80 + 78)
Night_turn_weighted <- (Euler_night1 * 80 + Euler_night2 * 78) / (80 + 78)
GD1$Day_turns[17]<- 0.720
GD1$Night_turns[17]<- 0.298


## Species data summary
mean(GD1$ClutchSize)
sd(GD1$ClutchSize)
mean(ED1$ClutchSize, na.rm=TRUE)
sd(ED1$ClutchSize, na.rm = TRUE)

class(GD1$`AVG.Delta.Tem/hr(Out-Egg)`)
GD1$`AVG.Delta.Tem/hr(Out-Egg)` <- as.numeric(GD1$`AVG.Delta.Tem/hr(Out-Egg)`)

mean(ED1$AVG_turns_hour, na.rm=TRUE)
range(GD1$AVG_Angular, na.rm=TRUE)
sd(GD1$AVG_Temp_egg_Hour, na.rm=TRUE)/sqrt(sum(GD1$AVG_Temp_egg_Hour, na.rm=TRUE))
#
sum(!is.na(GD1$PFOS))
mean(GD1$PFOS, na.rm=TRUE)
sd(GD1$PFOS, na.rm=TRUE)/sqrt(sum(GD1$PFOS, na.rm=TRUE))
# 
sum(!is.na(GD1$T4))
mean(GD1$T4, na.rm=TRUE)
sd(GD1$T4, na.rm=TRUE)/sqrt(sum(GD1$T4, na.rm=TRUE))
# ----Q1) Goldeneye vs. eider turning rates ----
#1) Havnig similar column names for the compared variables in both datasets 
#ED2<- ED2 %>%
 #rename(`Wing`= `Wing (R-U)`)
#1.2) Identifying outliers
identify_outliers_iqr <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR_value <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR_value
  upper_bound <- Q3 + 1.5 * IQR_value
  
  # Return a logical vector where TRUE indicates an outlier
  data[[column]] < lower_bound | data[[column]] > upper_bound
}

outliers_GD2 <- identify_outliers_iqr(GD2,"BodyCondition")
outliers_GD2
outliers_GD1 <- identify_outliers_iqr(GD1, "AVG_turns_hour")
outliers_GD1

#1.4) Across-species comparison
# First, across incubation stages in common eider
table(ED1$Incubation_stage)
  
sum(!is.na(ED1$AVG_Temp_out_Hour))
ED1$AVG_Temp_out_Hour
Shapiro <- shapiro.test(ED1$AVG_Temp_out_Hour[ED1$Incubation_stage == "Early.breeder"])
Shapiro
Shapiro <- shapiro.test(ED1$AVG_Temp_out_Hour[ED1$Incubation_stage == "Late.breeder"])
Shapiro
Shapiro <- shapiro.test(ED1$AVG_Temp_out_Hour[ED1$Incubation_stage == "Peak.incubation"])
Shapiro
#Homogenity of variance 
bartlett.test(AVG_Temp_egg_Hour ~ Incubation_stage, data = ED1)
# With linear regression 
ED1$Incubation_stage <- as.factor(ED1$Incubation_stage)
ED1$Incubation_stage <- relevel(ED1$Incubation_stage, ref = "Peak.incubation")
Lm_eider_stage <- lm(AVG_Temp_egg_Hour~ Incubation_stage, data=ED1)
summary(Lm_eider_stage)
anova(Lm_eider_stage)
pairs(emmeans(Lm_eider_stage, ~ Incubation_stage), adjust="tukey")

# 
kruskal.test(Overal_angularChange_mean ~ Incubation_stage, data = ED1)

#Plotting 
ggplot(ED1, aes(x = Incubation_stage, y = AVG_turns_hour)) +
  geom_boxplot() +
  geom_jitter(width = 0.2) +
  theme( 
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.9, 0.9),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  guides(color = guide_legend(title = "Time"), fill = FALSE)+
  labs(
    x = "Incubation Stage",
    y = "Average Egg Turning Frequency (Overall/Hour)")
#Eider hatching success across breeding period 
#EDHatch <- betareg(HatchingSuccess_adj ~ Incubation_stage, data = ED1)
#emmeans(EDHatch, ~ Incubation_stage)
#pairs(emmeans(EDHatch, ~ Incubation_stage))
#2) Average turning rate
# Normality testing 

Shapiro <- shapiro.test(GD1$AVG_turns_hour)
Shapiro
Shapiro <- shapiro.test(ED1$AVG_turns_hour)
Shapiro

#Histogram 
hist(ED1$AVG_Temp_egg_Hour)
hist(GD1$AVG_Temp_egg_Hour)
#qq plot
qqnorm(ED1$AVG_Temp_egg_Hour)
qqline(ED1$AVG_Temp_egg_Hour)
qqnorm(GD1$AVG_Temp_egg_Hour)
qqline(GD1$AVG_Temp_egg_Hour)

#2.5) Average turning rate 
mean(GD1$AVG_turns_hour)
mean(ED1$AVG_turns_hour)
#2.5.1) Average hourly turns
var.test(GD1$AVG_turns_hour, ED1$AVG_turns_hour)

T_test <- t.test(na.omit(GD1$AVG_turns_hour), na.omit(ED1$AVG_turns_hour), var.equal = FALSE)
T_test
# Plot 

boxplot(GD1$AVG_turns_hour,ED1$AVG_turns_hour,
        names=c("Goldeneye", "Eider"),
        main=NA, 
        ylab= "Average Egg Turning Frequency (Overall/Hour)",
        col=c("gold", "cornflowerblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE)
jitter <- 0.2
points(jitter(rep(1,length(GD1$AVG_turns_hour)), amount = jitter), GD1$AVG_turns_hour, pch=16, col="black", cex=0.8)
points(jitter(rep(2,length(ED1$AVG_turns_hour)), amount = jitter), ED1$AVG_turns_hour, pch=16, col="black", cex=0.8)

#2.5.1.2) Average daily turns 
Shapiro <- shapiro.test(GD1Daily$Daily_avg_turn)
Shapiro
Shapiro <- shapiro.test(ED1Daily$Daily_avg_turn)
Shapiro

mean(GD1Daily$Daily_avg_turn)
mean(ED1Daily$Daily_avg_turn)
var.test(GD1Daily$Daily_avg_turn, ED1Daily$Daily_avg_turn)

T_test <- t.test(na.omit(GD1Daily$Daily_avg_turn), na.omit(ED1Daily$Daily_avg_turn), var.equal = FALSE)
T_test

#2.5.2) Average turning rate during day/night hours 
#GD_Clean <- na.omit(GD1$`Day/Hr egg turning` & GD1$`Night/Hr egg turning`)
Shapiro <- shapiro.test(GD1$Day_turns)
Shapiro
Shapiro <- shapiro.test(GD1$Night_turns)
Shapiro
var.test(GD1$Night_turns, GD1$Day_turns)

T_test <- t.test(ED1$Night_turns, ED1$Day_turns, paired= TRUE)
T_test
mean(ED1$Night_turns)
mean(ED1$Day_turns)
#Only for Tvärminne eiders 
ED_Tva <- ED1[ED1$FemaleID %in% c("74295", "79025", "79068"), ]
T_test <- t.test(ED_Tva$Night_turns, ED_Tva$Day_turns, paired= TRUE)
T_test
mean(ED_Tva$Night_turns)
mean(ED_Tva$Day_turns)
#Plot
boxplot(ED1$Day_turns,ED1$Night_turns,
        names=c("Day (4:00-22:00)", "Night (22:00-4:00)"),
        main=NA, 
        ylab= "Average Egg Turning Frequency (Overall/Hour)",
        col=c("cornflowerblue", "powderblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE,
        ylim = c(min(ED1$Day_turns, ED1$Night_turns) - 0.1, 
                 max(ED1$Day_turns, ED1$Night_turns) + 0.3),
          cex.axis=1,
        cex.lab=1) # More space

jitter <- 0.2
points(jitter(rep(1,length(ED1$Day_turns)), amount = jitter), ED1$Day_turns, pch=16, cex=0.5, col="black")
points(jitter(rep(2,length(ED1$Night_turns)), amount = jitter), ED1$Night_turns, pch=16,cex=0.5, col="black")
#Adding significany sign
text(x = 2, y = max(ED1$Day_turns, ED1$Night_turns) + 0.1, labels = "***", cex=2)
text(x=0.6, y= max(ED1$Day_turns, ED1$Night_turns) + 0.2, labels= "(B)", front=2, cex=1.8)

#2.5.3) Average egg temperature 
GD1 <- GD1%>%
  rename(AVG_Temp_out_Day = `AVG.Temp.out (Day)`,
          DeltaTemp_eggOut=`AVG.Delta.Tem/hr(Out-Egg)`)
ED1 <- ED1%>%
  rename(AVG_Temp_out_Day = `AVG.Temp.out (Day)`,
          DeltaTemp_eggOut=`Delta.avgTem/hr(Out-Egg)`)

GD1$DeltaTemp_eggOut <- as.numeric(GD1$DeltaTemp_eggOut)  
ED1$DeltaTemp_eggOut <- as.numeric(ED1$DeltaTemp_eggOut) 

Shapiro <- shapiro.test(GD1$DeltaTemp_eggOut)
Shapiro
var.test(GD1$AVG_Temp_out_Hour, ED1$AVG_Temp_out_Hour)
mean(GD1$AVG_Temp_out_Hour)
mean(ED1$AVG_Temp_out_Hour, na.rm=TRUE)
var.test(GD1$DeltaTemp_eggOut, ED1$DeltaTemp_eggOut)
mean(GD1$AVG_Temp_egg_Hour)
mean(ED1$AVG_Temp_egg_Hour)
var.test(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour)

T_test <- t.test(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour, var.equal = TRUE)
T_test
sum(!is.na(GD1$AVG_Temp_out_Hour))

wilcox.test(GD1$AVG_Temp_out_Hour, ED1$AVG_Temp_out_Hour, exact = FALSE)
wilcox.test(GD1$AVG_Temp_out_Day, ED1$AVG_Temp_out_Day, exact=FALSE)
t.test(ED1$DeltaTemp_eggOut, GD1$DeltaTemp_eggOut, var.equal = TRUE)

#Plot
boxplot(GD1$AVG_Temp_egg_Hour,ED1$AVG_Temp_egg_Hour,
        names=c("Goldeneye", "Eider"),
        main=NA, 
        ylab= "Average egg temperature (Overall/Hour)",
        col=c("gold", "cornflowerblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE,
cex.axis=1,
cex.lab=1)
jitter <- 0.2
points(jitter(rep(1,length(GD1$AVG_Temp_egg_Hour)), amount = jitter), GD1$AVG_Temp_egg_Hour, pch=16, cex=0.5, col="black")
points(jitter(rep(2,length(ED1$AVG_Temp_egg_Hour)), amount = jitter), ED1$AVG_Temp_egg_Hour, pch=16, cex=0.5, col="black")
text(x = 1, y = max(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour) + 0.3, labels = "*", cex=2)


# ----Q2) Turning rate in relation to incubation day----
# ------In goldeneyes------ 

#There are zero's in GD2. I make a subset with only above zero values. 
GD2Final <- subset(GD2, turns_per_day > 0)
#Assumptions testing for family selection 
var_turns <- var(GD2Final$turns_per_day)
mean_turns <- mean(GD2Final$turns_per_day)
dispersion <- var_turns/mean_turns
shapiro.test(GD2Final$turns_per_day)

### Checking correlations 
#GD2Final$AVG.EggTem.Per.IncDay <- as.numeric(GD2Final$AVG.EggTem.Per.IncDay)
COR <- GD2Final[, c("Fullday.Incubation","ClutchSize", "BodyCondition","AVG.EggTem.Per.IncDay")] 
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#If I want a correlation table 
#cor_results <- rcorr(as.matrix(COR), type = "spearman")
#correlation_matrix <- cor_results$r
#p_values <- cor_results$P

#ggcorrplot(correlation_matrix, 
 #          type = "lower", 
  #         lab = TRUE, 
   #        p.mat = p_values, 
    #       insig = "blank",  # Hide non-significant correlations
     #      colors = c("#6D9EC1", "white", "#E46726"), 
      #     title = "Correlation Heatmap", 
       #    outline.col = "white") 
#OR

#corrplot(correlation_matrix, method = "circle", 
 #        type = "lower", 
  #       col = colorRampPalette(c("red", "white", "blue"))(200), 
   #      tl.col = "black", tl.srt = 45, # Rotate labels
  #       addCoef.col = "black", # Add correlation values
   #      p.mat = p_values, sig.level = 0.05) 
#png("correlation_heatmap.png", width = 1200, height = 1000, res = 300)
#ggcorrplot(cor_matrix, type = "lower", lab = TRUE, p.mat = p_values, insig = "blank")

#overdisp <- sum(residuals(IncDay6, type="pearson")^2) / df.residual(IncDay6)
#print(overdisp)

#Model selection 
GD2_complete <- na.omit(GD2Final[, c("Fullday.Incubation","turns_per_day","ClutchSize","BodyCondition",
                                     "FemaleID")])

Dredge_GLMM_turnPerDay=dredge(glmmTMB(turns_per_day ~  Fullday.Incubation +
                                        ClutchSize+
                                        #BodyCondition+
                                        (1|FemaleID),
                                      data=GD2_complete,
                                      na.action = "na.fail"),
                              fixed = c("Fullday.Incubation")
)

View(Dredge_GLMM_turnPerDay)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_GLMM_turnPerDay, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_GLMM_turnPerDay, subset = 2)[[1]])

#Selected model
#GD2FULL <- GD2Final[complete.cases(GD2Final[c("turns_per_day","Fullday.Incubation")]), ]
#IncDayGold1 <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1| FemaleID), family=poisson(),data = GD2Final)
IncDayGold <- glmmTMB(turns_per_day ~ Fullday.Incubation + (1| FemaleID),data = GD2Final)
summary(IncDayGold)
AICc(IncDayGold, IncDayGold1)
IncNULL <- glmmTMB(turns_per_day ~ 1+ (1|FemaleID), data= GD2Final)
AIC(IncDay6, IncNULL)
range(GD2Final$Fullday.Incubation)
#CheckinIncDay6#Checking collinearity 
check_collinearity(IncDayGold)
#Model fit 
sim_res <- simulateResiduals(IncDayGold)
plot(sim_res)
testDispersion(sim_res)
testZeroInflation(sim_res)

#Plotting 
pred <- ggpredict(IncDayGold, terms = "Fullday.Incubation")  

ggplot()+
  geom_point(data=GD2Final, aes(x = Fullday.Incubation, y = turns_per_day,color=factor(FemaleID)), alpha=0.6) +      
  geom_line(data = pred, aes(x = x, y = predicted), color = "#B8800B", size = 1) +
  geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high), alpha = 0.2, fill = "#B8800B") +
  labs(x = "Incubation day", y = "Turns per day") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#OR

GD2Final$predicted_ind <- predict(IncDayGold)  # includes random intercepts

ggplot(GD2Final, aes(x = Fullday.Incubation, y = turns_per_day, color = FemaleID)) +
  geom_point(alpha = 0.5) +
  geom_line(aes(y=predicted_ind)) +
  labs(x = "Incubation day", y = "Turns per day", color = "Female ID") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#AND
ggplot(GD2Final, aes(x = Fullday.Incubation, y = turns_per_day, color = FemaleID)) +
  geom_point(alpha = 0.5) +
  geom_line(aes(group = FemaleID), size = 0.6) +
  labs(x = "Incubation day", y = "Turns per day", color = "Female ID") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")


# -------In Eiders------ 
#Correlations 
COR <- ED2[, c("Fullday.Incubation", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
print(correlation_matrix)

#Assumptions testing 
var_turns <- var(ED2$turns_per_day)
mean_turns <- mean(ED2$turns_per_day)
dispersion <- var_turns/mean_turns
shapiro.test(ED2$turns_per_day)

length(na.omit(ED2$turns_per_day))
length(na.omit(ED2$Fullday.Incubation))
length(na.omit(ED2$ClutchSize))
length(na.omit(ED2$BodyCondition))
# Since there are missing values, I run the model also with the subset of data to make sure the output is the same:
ED2FULL <- ED2[complete.cases(ED2[c("turns_per_day", "Fullday.Incubation", "ClutchSize", "BodyCondition")]), ]

#Model selection
ED2_complete <- na.omit(ED2[, c("Fullday.Incubation","turns_per_day","ClutchSize","FemaleID")])

Dredge_GLMM_turnPerDay=dredge(glmmTMB(turns_per_day ~  Fullday.Incubation +
                                        ClutchSize+
                                        (1|FemaleID),
                                      data=ED2_complete,
                                      na.action = "na.fail"),
                              fixed = c("Fullday.Incubation")
)

View(Dredge_GLMM_turnPerDay)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_GLMM_turnPerDay, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_GLMM_turnPerDay, subset = 2)[[1]])
#NULL
IncNULL <- glmmTMB(turns_per_day ~ 1 + (1|FemaleID), family=nbinom2(), data=ED2FULL)

#Checking the model fit 
sim_res <- simulateResiduals(IncDayEider)
plot(sim_res)

#Selected model

IncDayEider <- glmmTMB(turns_per_day ~ scale(Fullday.Incubation) + (1|FemaleID), data=ED2)
summary(IncDayEider)
IncNULL <- glmmTMB(turns_per_day ~ 1 + (1|FemaleID), data=ED2)
#Predictors importance )#Predictors importance )ED2FULL
#anova(IncDay3, IncNULL)
AIC(IncDayEider, IncNULL)
#Plotting 
#ggplot(ED2, aes(x= Fullday.Incubation, y=turns_per_day, color=FemaleID)) + 
 # geom_point(alpha=0.6, stroke=1.5)+
  #geom_smooth(method="lm", se=TRUE, color="black")+
  #theme(
   # panel.background = element_rect(fill = "transparent", colour = NA),
    #legend.position = c(0.94, 0.86),
    #axis.line = element_line(color = "black"),
    #plot.background = element_rect(fill = "transparent", colour = NA)) +
  #labs(title="", x="Incubation day", y= "Turning frequency")+
  #scale_x_continuous(breaks=unique(ED2$Fullday.Incubation))

# ---- Q3) Turning rate in relation to thyroid and PFAS + egg temperature----
# ------Goldeneye------
#class(GD1$RecordedDays)
#GD1$RecordedDays <- as.numeric(GD1$RecordedDays)

COR <- GD1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour","AVG_Temp_out_Hour", "RecordedDays")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model selection 
GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","PFNA","T3","T4","T3_T4","BodyCondition")])
#GD1_complete <- na.omit(GD1_scaled[, c("AVG_turns_hour","PFAS_SUM","T3_T4","ClutchSize")])

Dredge_LM_AVG_TURN=dredge(lm(AVG_turns_hour ~  PFNA +
                               #ClutchSize+
                               #BodyCondition+
                               T3+ T4
                             + T3_T4+
                               PFNA:T3+
                               PFNA:T4+
                               PFNA:T3_T4,
                             data=GD1_complete,
                             na.action = "na.fail"),
                          fixed = c("PFNA","T3_T4"),
                          subset = !(T3 && T4) &&
                            !(T3 && T3_T4) &&
                            !(T4 && T3_T4)
)

View(Dredge_LM_AVG_TURN)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_TURN, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_TURN, subset = 2)[[1]])
summary(get.models(Dredge_LM_AVG_TURN, subset = 3)[[1]])

#Model output
GDTurn<- lm(AVG_turns_hour~ PFAS_SUM+T3_T4, data=GD1_scaled)

summary(GDTurn)
nobs(GDTurn)
anova(GDTurn1, GDTurnNULL, test = "Chisq")
#Checking the model fit 
par(mfrow = c(2, 2))  
plot(GDTurn)  
shapiro.test(residuals(GDTurn))
hist(residuals(GDTurn), breaks = 20, main = "Histogram of Residuals")
#Checking multicolinearity
vif(GDTurn1)
nobs(GDTurn1) 

# Only for clutch size 
#GDTurn1<- lm(AVG_turns_hour~ ClutchSize, data=GD1)
#Checking for influencial points 
library(car)
influencePlot(GDTurn)  # Plots influence, labels extreme cases
# OR
cooksd <- cooks.distance(GDTurn)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_scaled) - length(coef(GDTurn)) - 1), col = "red", lty = 2)
which(cooksd > 4/(nrow(GD1_scaled) - length(coef(GDTurn)) - 1))

## Major PFAS #####
COR <- GD1[, c("AVG_turns_hour","PFUnA", "T4", "AVG_Temp_egg_Hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GD1FULL <- GD1[complete.cases(GD1[c("AVG_turns_hour","T4", "PFDoDA", "AVG_Temp_egg_Hour")]), ]

GDTurnPFUnA <- lm(AVG_turns_hour~ scale(PFUnA)+scale(T3_T4), data=GD1)
GDTurnPFDoDA <- lm(AVG_turns_hour~  scale(PFDoDA)+scale(T3_T4), data=GD1)
GDTurnPFNA <- lm(AVG_turns_hour~  scale(PFNA)+scale(T3_T4), data=GD1)
GDTurnPFOS <- lm(AVG_turns_hour~ scale(PFOS)+scale(T3_T4), data=GD1)
summary(GDTurnPFOS)

### Angular changes ####
#Model selection 
GD1_complete <- na.omit(GD1_scaled[, c("Overal_angularChange_mean","PFAS_SUM","ClutchSize")])

Dredge_LM_AVG_ANG=dredge(lm(Overal_angularChange_mean ~  PFAS_SUM +
                              ClutchSize,
                              #T3+ T4
                            #+ T3_T4+
                              #PFAS_SUM:T3+
                              #PFAS_SUM:T4+
                              #PFAS_SUM:T3_T4,
                            data=GD1_complete,
                            na.action = "na.fail"),
                         fixed = c("PFAS_SUM"),
                         #subset = !(T3 && T4) &&
                          # !(T3 && T3_T4) &&
                           #!(T4 && T3_T4)
)

View(Dredge_LM_AVG_ANG)
# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_ANG, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_ANG, subset  = 2)[[1]])
summary(get.models(Dredge_LM_AVG_ANG, subset = 3)[[1]])

#Model output 
AVG_ANG_GD <-lm(Overal_angularChange_mean ~ PFAS_SUM, data = GD1_complete)
summary(AVG_ANG_GD)
nobs(AVG_ANG_GD)

#Influential points 
library(car)
influencePlot(AVG_ANG_GD) 
# OR
cooksd <- cooks.distance(AVG_ANG_GD)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_complete) - length(coef(AVG_ANG_GD)) - 1), col = "red", lty = 2)
which(cooksd > 4/(nrow(GD1_complete) - length(coef(AVG_ANG_GD)) - 1))
#Running the model without influential point
GD1_sub <- GD1_complete[-7,]
AVG_ANG_GD <-lm(Overal_angularChange_mean ~ PFAS_SUM, data = GD1_sub)
summary(AVG_ANG_GD)
nobs(AVG_ANG_GD)
#Checking the model fit 
par(mfrow = c(2, 2))  
plot(AVG_ANG_GD)  
shapiro.test(residuals(AVG_ANG_GD))
hist(residuals(AVG_ANG_GD), breaks = 20, main = "Histogram of Residuals")

#### PER day GD turning frequency----

#From hourly dataset 
#1) Making a new dataset for the daily average rate 1) 
GD1Daily <- GD1
#
GD1Daily <- GD1Daily %>%
  rename(Total_record_hr= `Total record (Hour)`)
GD1Daily <- GD1Daily %>%
  rename(AVG_Temp_day= `AVG.Temp.egg (Day)`)

GD1Daily$Total_record_hr <- as.numeric(GD1Daily$Total_record_hr)
GD1Daily$RecordedDays <- as.numeric(GD1Daily$RecordedDays)
GD1Daily$AVG_Temp_day <- as.numeric(GD1Daily$AVG_Temp_day)
# Only keeping days with at least 19 hours of record
GD1Daily$DecimalPart <- GD1Daily$RecordedDays - floor(GD1Daily$RecordedDays)
# Step 2: Apply the condition: Remove decimals if < 0.70
GD1Daily$AdjustedRecordedDays <- ifelse(GD1Daily$DecimalPart < 0.70, 
                                         floor(GD1Daily$RecordedDays), 
                                        GD1Daily$RecordedDays)
GD1Daily$newTotalHours <- GD1Daily$AdjustedRecordedDays*24

#Re-calculating the average hourly turn
GD1Daily$NewHourlyTurns <- GD1Daily$AVG_turns_hour * (GD1Daily$Total_record_hr / GD1Daily$newTotalHours)

#Getting the average daily turn
GD1Daily$Daily_avg_turn <- GD1Daily$NewHourlyTurns*24
GD1Daily$Daily_avg_turn <- round(GD1Daily$Daily_avg_turn, 3)

## 
COR <- GD1Daily[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_day","Daily_avg_turn","AdjustedRecordedDays")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#Model selection 
GD1_complete <- na.omit(GD1Daily_scaled[, c("Daily_avg_turn","PFAS_SUM","T3","T4","T3_T4", "AVG_Temp_day","ClutchSize")])

Dredge_LM_AVG_Daily=dredge(lm(Daily_avg_turn ~  PFAS_SUM +
                                ClutchSize+
                                AVG_Temp_day+
                                T3+ T4
                              + T3_T4+
                                PFAS_SUM:T3+
                                PFAS_SUM:T4+
                                PFAS_SUM:T3_T4,
                              data=GD1_complete,
                              na.action = "na.fail"),
                           fixed = c("PFAS_SUM"),
                           subset = !(T3 && T4) &&
                             !(T3 && T3_T4) &&
                             !(T4 && T3_T4)
)

View(Dredge_LM_AVG_Daily)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_Daily, subset = 1)[[1]])
#summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_Daily, subset  = 2)[[1]])
summary(get.models(Dredge_LM_AVG_Daily, subset = 3)[[1]])

#Model output
GDTurnDaily <- lm(Daily_avg_turn~ scale(PFAS_SUM), data=GD1_complete)
summary(GDTurnDaily)
nobs(GDTurnDaily)
#Residuals test
par(mfrow = c(2, 2))  
plot(GDTurnDaily)  
shapiro.test(residuals(GDTurnDaily))
hist(residuals(GDTurnDaily), breaks = 20, main = "Histogram of Residuals")

##Plotting##
#Plotting: Average egg turning vs. PFAS
#GDTurn<- lm(AVG_turns_hour~ PFAS_SUM+T3_T4, data=GD1_scaled)
GD1_plot <- GD1_scaled[complete.cases(GD1_scaled[, c("PFAS_SUM", "T3_T4", "AVG_turns_hour")]), ]

library(effects)
pfas_eff <- allEffects(GDTurn)
pfas_df <- as.data.frame(pfas_eff[["PFAS_SUM"]])

ggplot(pfas_df, aes(x = PFAS_SUM, y = fit)) +
  geom_line(color = "#B8923B", size = 1.2) +
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              fill = "#B8923B", alpha = 0.15) +
  geom_point(data = GD1_plot, aes(x = PFAS_SUM, y = AVG_turns_hour),
             color = "#B8923B", alpha = 0.5, size = 3) +
  labs(x = "∑PFAS(scaled)",
       y = "Average hourly egg turning frequency(scaled)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )
#Or with TH in a same plot:
GD1_model <- GD1[complete.cases(GD1$PFAS_SUM, GD1$T3_T4, GD1$AVG_turns_hour), ]

T3_mean <- mean(GD1_model$T3_T4, na.rm = TRUE)
T3_sd   <- sd(GD1_model$T3_T4, na.rm = TRUE)
T3_vals <- c(
  Low = T3_mean - T3_sd,
  Medium = T3_mean,
  High = T3_mean + T3_sd
)

pred_grid <- expand.grid(
  PFAS_SUM = seq(min(GD1_model$PFAS_SUM), max(GD1_model$PFAS_SUM), length.out = 100),
  T3_T4 = T3_vals
)

pred <- predict(GDTurn, newdata = pred_grid, se.fit = TRUE)

pred_grid$fit <- pred$fit
pred_grid$lower <- pred$fit - 1.96 * pred$se.fit
pred_grid$upper <- pred$fit + 1.96 * pred$se.fit

pred_grid$T3_level <- factor(pred_grid$T3_T4, labels = c("Low", "Medium", "High"))

ggplot() +
  geom_point(data = GD1_model, aes(x = PFAS_SUM, y = AVG_turns_hour),
             color = "#B8923B", alpha = 0.5, size = 3) +
  geom_line(data = pred_grid, aes(x = PFAS_SUM, y = fit, color = T3_level), size = 1.2) +
  geom_ribbon(data = pred_grid, aes(x = PFAS_SUM, ymin = lower, ymax = upper, fill = T3_level),
              alpha = 0.2, color = NA) +
  scale_color_manual(values = c("#FFE699", "#FFCC33", "#B8923B")) +
  scale_fill_manual(values = c("#FFE699", "#FFCC33", "#B8923B")) +
  labs(x = "???PFAS", y = "Predicted average hourly turning frequency", 
       color = "T3:T4", fill = "T3:T4") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  )

##All PFASs in relation with egg turning frequency 
#Marginal effects 
library(broom)
coefs <- bind_rows(
  tidy(GDTurnPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(GDTurnPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(GDTurnPFDoDA, conf.int = TRUE) %>% filter(term == "scale(PFDoDA)") %>% mutate(compound = "PFDoDA"),
  tidy(GDTurnPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFDoDA", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "#FFE8B8",
    high = "#9B5E3C",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Average hourly egg turning",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
# ------ Eider ------

COR <- ED1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour","AVG_Temp_out_Hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# Normality testing for distribution selection  
Shapiro <- shapiro.test(ED1$AVG_turns_hour)
Shapiro
var_turns <- var(ED1$AVG_turns_hour)
mean_turns <- mean(ED1$AVG_turns_hour)
dispersion <- var_turns/mean_turns
##
#Model selection: 
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFAS_SUM","T3_T4","ClutchSize")])

Dredge_LM_AVG_TURN=dredge(lm(AVG_turns_hour ~  PFHxS +
                               # T3+ T4
                               + T3_T4+
                               ClutchSize+
                               #BodyCondition+
                               #PFHxS:T3+
                               #PFHxS:T4+
                               PFHxS:T3_T4,
                             data=ED1_complete,
                             na.action = "na.fail"),
                          fixed = c("PFHxS","T3_T4"),
                          #subset = !(T3 && T4) &&
                          # !(T3 && T3_T4) &&
                          #!(T4 && T3_T4)
)

View(Dredge_LM_AVG_TURN)
# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_TURN, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_TURN, subset = 2)[[1]])

#Final model: 
EDTurn <- lm(AVG_turns_hour~ PFAS_SUM*T3_T4, data=ED1_complete)
summary(EDTurn)
nobs(EDTurn)
confint(EDTurn)
EDTurnNULL <- lm(AVG_turns_hour~ 1, data=ED1_complete)

#Model diagnostic 
par(mfrow = c(2, 2))  
plot(EDTurn)  
shapiro.test(residuals(EDTurn))
hist(residuals(EDTurn), breaks = 20, main = "Histogram of Residuals")

AICc(EDTurnNULL, EDTurn )

#Influential check 
library(car)
influencePlot(EDTurn) 
# OR
cooksd <- cooks.distance(EDTurn )
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_complete) - length(coef(EDTurn )) - 1), col = "red", lty = 2)
which(cooksd > 4/(nrow(ED1_complete) - length(coef(EDTurn )) - 1))
#Running the model without infleuntial point 
ED1_Sub <- ED1_complete[-14,]
EDTurn <- lm(AVG_turns_hour~ PFAS_SUM*T3_T4, data=ED1_Sub)
#EDTurn <- lm(AVG_turns_hour~ PFAS_SUM+T3_T4, data=ED1_Sub)
summary(EDTurn)
nobs(EDTurn)
# Only for clutch size 
#EDTurn1 <- lm(AVG_turns_hour~ ClutchSize, data=ED1)

### Major PFAS #####
ED1_complete <- na.omit(ED1_scaled[, c("AVG_turns_hour","PFUnA","T3_T4","ClutchSize")])

EDTurnPFUnA <- lm(AVG_turns_hour~ PFUnA*T3_T4, data=ED1_complete)
EDTurnPFHxS <- lm(AVG_turns_hour~ PFHxS*T3_T4, data=ED1_complete)
EDTurnPFNA <- lm(AVG_turns_hour~ PFNA*T3_T4, data=ED1_complete)
EDTurnPFOS <- lm(AVG_turns_hour~ PFOS+T3_T4, data=ED1_complete)
summary(EDTurnPFUnA)
nobs(EDTurnPFUnA)

par(mfrow = c(2, 2))  
plot(EDTurnPFUnA)  
shapiro.test(residuals(EDTurnPFUnA))
hist(residuals(EDTurnPFUnA), breaks = 20, main = "Histogram of Residuals")
vif(EDTurnPFUnA)

#### Angular change ####
ED1 <- ED1%>%
  rename(AVG_Angular=Overal_angularChange_mean)
ED1$AVG_Angular <- as.numeric(ED1$AVG_Angular)
ED1_scaled$AVG_Angular <- as.numeric(scale(ED1$AVG_Angular))

#Model selection 
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Angular","PFAS_SUM","T3","T4","T3_T4", "ClutchSize")])

Dredge_LM_AVG_ANG=dredge(lm(AVG_Angular ~  PFAS_SUM +
                              ClutchSize+
                              T3+ T4
                            + T3_T4+
                              PFAS_SUM:T3+
                              PFAS_SUM:T4+
                              PFAS_SUM:T3_T4,
                            data=ED1_complete,
                            na.action = "na.fail"),
                         fixed = c("PFAS_SUM"),
                         subset = !(T3 && T4) &&
                           !(T3 && T3_T4) &&
                           !(T4 && T3_T4)
)

View(Dredge_LM_AVG_ANG)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_ANG, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_ANG, subset  = 2)[[1]])
summary(get.models(Dredge_LM_AVG_ANG, subset = 3)[[1]])

#Model output 
EDAng <- lm(AVG_Angular~ PFAS_SUM, data=ED1_complete)
summary(EDAng)
nobs(EDAng)
#
par(mfrow = c(2, 2))  
plot(EDAng)  
shapiro.test(residuals(EDAng))
hist(residuals(EDAng), breaks = 20, main = "Histogram of Residuals")

##### PER day ED turning frequency ----
#1) Making a new dataset for the daily average rate 1) 
ED1Daily <- ED1
#
ED1Daily <- ED1Daily%>%
  rename(Total_record_hr= `Total record (Hour)`)
ED1Daily <- ED1Daily%>%
  rename(AVG_Temp_day= `AVG.Temp.egg (Day)`)
#class(GD1Daily$Total_record_hr)
ED1Daily$Total_record_hr <- as.numeric(ED1Daily$Total_record_hr)
ED1Daily$Days.recorded <- as.numeric(ED1Daily$Days.recorded)
ED1Daily$AVG_Temp_day <- as.numeric(ED1Daily$AVG_Temp_day)
# Only keeping days with at least 19 hours of record
ED1Daily$DecimalPart <- ED1Daily$Days.recorded- floor(ED1Daily$Days.recorded)
# Step 2: Apply the condition: Remove decimals if < 0.70
ED1Daily$AdjustedRecordedDays <- ifelse(ED1Daily$DecimalPart < 0.70, 
                                        floor(ED1Daily$Days.recorded), 
                                        ED1Daily$Days.recorded)
ED1Daily$newTotalHours <- ED1Daily$AdjustedRecordedDays*24

#Re-calculating the average hourly turn
ED1Daily$NewHourlyTurns <- ED1Daily$AVG_turns_hour * (ED1Daily$Total_record_hr / ED1Daily$newTotalHours)

#Getting the average daily turn
ED1Daily$Daily_avg_turn <- ED1Daily$NewHourlyTurns*24
ED1Daily$Daily_avg_turn <- round(ED1Daily$Daily_avg_turn, 3)

## 
COR <- ED1Daily[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_day","Daily_avg_turn","AdjustedRecordedDays")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model selection 
ED1_complete <- na.omit(ED1Daily_scaled[, c("Daily_avg_turn","PFAS_SUM","T3","T4","T3_T4", "ClutchSize")])

Dredge_LM_AVG_Daily=dredge(lm(Daily_avg_turn ~  PFAS_SUM +
                                ClutchSize+
                                #BodyCondition+
                                T3+ T4
                              + T3_T4+
                                PFAS_SUM:T3+
                                PFAS_SUM:T4+
                                PFAS_SUM:T3_T4,
                              data=ED1_complete,
                              na.action = "na.fail"),
                           fixed = c("PFAS_SUM"),
                           subset = !(T3 && T4) &&
                             !(T3 && T3_T4) &&
                             !(T4 && T3_T4)
)

View(Dredge_LM_AVG_Daily)

# summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_Daily, subset = 1)[[1]])
# summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_Daily, subset  = 2)[[1]])
summary(get.models(Dredge_LM_AVG_Daily, subset = 3)[[1]])

#Model output 
EDTurnDaily <- lm(Daily_avg_turn~ PFAS_SUM*T3_T4, data=ED1_complete)
summary(EDTurnDaily)
nobs(EDTurnDaily)
#Residuals test
par(mfrow = c(2, 2))  
plot(EDTurnDaily)  
shapiro.test(residuals(EDTurnDaily))
hist(residuals(EDTurnDaily), breaks = 20, main = "Histogram of Residuals")

EDTurnNULL <- lm(Daily_avg_turn~ 1,data=ED1Daily)

#Possible influential points 
library(car)
influencePlot(EDTurnDaily) 
# OR
cooksd <- cooks.distance(EDTurnDaily)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_complete) - length(coef(EDTurnDaily)) - 1), col = "red", lty = 2)
which(cooksd > 4/(nrow(ED1_complete) - length(coef(EDTurnDaily)) - 1))
#Running the model without influential point
ED1_Sub <- ED1_complete[-14,]
EDTurnDaily <- lm(Daily_avg_turn~ PFAS_SUM*T3_T4, data=ED1_Sub)
summary(EDTurnDaily)
nobs(EDTurnDaily)
#
###Plotting###
#PFAS*T3:T4 interaction on turning frequency 
#EDTurn <- lm(AVG_turns_hour~ PFAS_SUM*T3_T4, data=ED1_complete)
#ED1_Plot <- ED1_complete[complete.cases(ED1_complete[, c("PFAS_SUM", "T3_T4", "AVG_turns_hour")]), ]
pred_grid_ci <- expand.grid(
  PFAS_SUM = seq(min(ED1_complete$PFAS_SUM), max(ED1_complete$PFAS_SUM), length.out = 100),
  T3_T4 = T3_vals
)

pred_ci <- predict(EDTurn, newdata = pred_grid_ci, interval = "confidence")
pred_grid_ci$fit <- pred_ci[, "fit"]
pred_grid_ci$lower <- pred_ci[, "lwr"]
pred_grid_ci$upper <- pred_ci[, "upr"]

pred_grid_ci$T3_T4_level <- factor(pred_grid_ci$T3_T4, labels = c("Mean-sd", "Mean", "Mean+sd"))

ggplot(pred_grid_ci, aes(x = PFAS_SUM, y = fit, color = T3_T4_level, fill = T3_T4_level)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.15, color = NA) +
  geom_line(size = 1.2, linetype="dashed") +
  geom_point(data = ED1_complete, aes(x = PFAS_SUM, y = AVG_turns_hour, color = T3_T4_level),
             size = 2, alpha = 0.8) +
  labs(x = "∑PFAS(scaled)", y = "Average hourly egg turning frequency(scaled)", color = "T3:T4", fill = "T3:T4") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.6,0.2),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  scale_color_manual(values = c("Mean-sd" = "#AEC6E8", 
                                "Mean" = "#6495ED", 
                                "Mean+sd" = "#003F87")) +
  scale_fill_manual(values = c("Mean-sd" = "#AEC6E8", 
                               "Mean" = "#6495ED", 
                               "Mean+sd" = "#003F87"))

# PFASs all on egg turning
coefs <- bind_rows(
  tidy(EDTurnPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(EDTurnPFHxS, conf.int = TRUE) %>% filter(term == "scale(PFHxS)") %>% mutate(compound = "PFHxS"),
  tidy(EDTurnPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(EDTurnPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    p.value < 0.10  ~ ".",  
    TRUE            ~ ""
  ))
# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFUnA", "PFHxS", "PFNA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black", position=position_nudge(y=0.15)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "skyblue1",
    high = "firebrick3",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Egg Turning Rate (Overall/Hour)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "none")

#
# ----Q4) PFAS *TH+hourly turning rate on egg temperature ----
# ------Goldeneye------ 
COR <- GD1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "AVG_turns_hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model selection 
GD1_complete <- na.omit(GD1_scaled[, c("AVG_Temp_egg_Hour","PFAS_SUM","T3_T4","ClutchSize","AVG_turns_hour")])

Dredge_LM_AVG_Temp=dredge(lm(AVG_Temp_egg_Hour ~  PFAS_SUM +
                               AVG_turns_hour+
                               ClutchSize+
                               #BodyCondition+
                               #T3+ T4
                               + T3_T4+
                               #PFAS_SUM:T3+
                               #PFAS_SUM:T4+
                               PFAS_SUM:T3_T4,
                             data=GD1_complete,
                             na.action = "na.fail"),
                          fixed = c("PFAS_SUM","T3_T4"),
                          #subset = !(T3 && T4) &&
                          # !(T3 && T3_T4) &&
                          #!(T4 && T3_T4)
)

View(Dredge_LM_AVG_Temp)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_Temp, subset = 1)[[1]])
# if you want to see summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_Temp, subset = 2)[[1]])
summary(get.models(Dredge_LM_AVG_Temp, subset = 3)[[1]])

#Model output 
GDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM*T3_T4, data=GD1_scaled)
summary(GDTemT)
nobs(GDTemT)
confint(GDTemT)
#Residuals test
par(mfrow = c(2, 2))  
plot(GDTemT)  
shapiro.test(residuals(GDTemT))
hist(residuals(GDTemT), breaks = 20, main = "Histogram of Residuals")
vif(GDTemT)

#NULL
GDTemNULL <- lm(AVG_Temp_egg_Hour ~ 1, data=GDTemFULL)

#Mediator analysis (PFAS and TH affect egg temperature via manipulating egg turning):
library(mediation)
#GDTurn<- lm(AVG_turns_hour~ PFAS_SUM+T3_T4, data=GD1_scaled)
med_model <- lm(AVG_turns_hour ~ PFAS_SUM + T3_T4, data = GD1_scaled)
summary(med_model)
#GDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM*T3_T4, data=GD1_scaled)
out_model <- lm(AVG_Temp_egg_Hour ~ PFAS_SUM + T3_T4 + AVG_turns_hour, data = GD1_scaled)
summary(out_model)
set.seed(123) 
med_out <- mediate(med_model, out_model,
                   treat = "PFAS_SUM",
                   mediator = "AVG_turns_hour",
                   boot = TRUE, sims = 1000)
summary(med_out)
#JUST FOR TURNING RATES 
#GDTemTturn<- lm(AVG_Temp_egg_Hour~ scale(AVG_turns_hour)+scale(ClutchSize), data=GD1)
#GDTemTturn <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_turns_hour), data=GD1)
#summary(GDTemTturn)
#Checking for influencial points 
library(car)
influencePlot(GDTemT)  # Plots influence, labels extreme cases
# OR
cooksd <- cooks.distance(GDTemT)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_scaled) - length(coef(GDTemT)) - 1), col = "red", lty = 2)
which(cooksd > 4/(nrow(GD1_scaled) - length(coef(GDTemT)) - 1))

#IF needed! Re-running the model with the subset, excluding the influential points: 
GD1_sub<- GD1_scaled[-c(2,9), ]  # Removes the second row
#MODEL
GDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM+T3_T4, data=GD1_sub)
summary(GDTemT)
nobs(GDTemT)
#Individual PFAS
GDTemFULL <- GD1[complete.cases(GD1[c("PFNA", "T3", "AVG_Temp_egg_Hour","AVG_turns_hour")]), ]

GDTemPFUnA<- lm(AVG_Temp_egg_Hour~ PFUnA+T3_T4, data=GD1_scaled)
GDTemPFNA<- lm(AVG_Temp_egg_Hour~ PFNA+T3_T4, data=GD1_scaled)
GDTemPFDoDA<- lm(AVG_Temp_egg_Hour~ PFDoDA+T3_T4, data=GD1_scaled)
GDTemPFOS<- lm(AVG_Temp_egg_Hour~ PFOS+T3_T4, data=GD1_scaled)

summary(GDTemPFUnA)
nobs(GDTemPFUnA)

GDTemNULL <- lm(AVG_Temp_egg_Hour~ 1,data=GDTemFULL)
AIC(GDTemPFAS,GDTemNULL)

#Plot: PFAS on egg temperature 
#GDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM*T3_T4, data=GD1_scaled)
GD1_plot <- GD1_scaled[complete.cases(GD1_scaled[, c("PFAS_SUM", "T3_T4", "AVG_turns_hour")]), ]

mean_T3T4   <- mean(GD1_plot$T3_T4, na.rm = TRUE)
mean_PFAS <- mean(GD1_plot$PFAS_SUM, na.rm = TRUE)

pfas_grid <- data.frame(
  PFAS_SUM = seq(min(GD1_plot$PFAS_SUM), max(GD1_plot$PFAS_SUM), length.out = 100),
  T3_T4 = mean_T3T4
)
pfas_pred <- predict(GDTemT, newdata = pfas_grid, interval = "confidence")
pfas_grid$fit   <- pfas_pred[, "fit"]
pfas_grid$lower <- pfas_pred[, "lwr"]
pfas_grid$upper <- pfas_pred[, "upr"]

ggplot(pfas_grid, aes(x = PFAS_SUM, y = fit)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "#B8923B", alpha = 0.15) +
  geom_line(color = "#B8923B", size = 1.2) +
  geom_point(data = GD1_plot, aes(x = PFAS_SUM, y = AVG_Temp_egg_Hour),
             color = "#B8923B", alpha = 0.5, size = 3) +
  labs(x = "∑PFAS (scaled)", y = "Average hourly egg temperature (scaled)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

#Plot: T3:T4 on egg temperature 
t3_grid <- data.frame(
  PFAS_SUM = mean_PFAS,
  T3_T4 = seq(min(GD1_plot$T3_T4), max(GD1_plot$T3_T4), length.out = 100)
)
t3_pred <- predict(GDTemT, newdata = t3_grid, interval = "confidence")
t3_grid$fit   <- t3_pred[, "fit"]
t3_grid$lower <- t3_pred[, "lwr"]
t3_grid$upper <- t3_pred[, "upr"]

ggplot(t3_grid, aes(x = T3_T4, y = fit)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "#B8923B", alpha = 0.15) +
  geom_line(color = "#B8923B", size = 1.2, linetype="dashed") +
  geom_point(data = GD1_plot, aes(x = T3_T4, y = AVG_Temp_egg_Hour),
             color = "#B8923B", alpha = 0.5, size = 3) +
  labs(x = "T3:T4 (scaled)", y = "Scaled average egg temperature (°C)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

#PFASs all and egg temperature 
coefs <- bind_rows(
  tidy(GDTemPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(GDTemPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(GDTemPFDoDA, conf.int = TRUE) %>% filter(term == "scale(PFDoDA)") %>% mutate(compound = "PFDoDA"),
  tidy(GDTemPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFDoDA", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "#FFE8B8",
    high = "#9B5E3C",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "",
    title = "Average hourly egg temperature",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))

# ------Eider------- 
COR <- ED1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "AVG_turns_hour", "Incubation_stage")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# Normality testing for distribution selection  
#Shapiro <- shapiro.test(ED1$AVG_Temp_egg_Hour)
#Shapiro
#var_Temp <- var(ED1$AVG_Temp_egg_Hour)
#mean_Temp <- mean(ED1$AVG_Temp_egg_Hour)
#dispersion <- var_Temp/mean_Temp 
#Adding the incubation stage as a variable here
#ED1$Incubation_stage <- as.numeric(factor(ED1$Incubation_stage,
 #                                         levels= c("Early.breeder", "Peak.incubation", "Late.breeder"),
  #                                        labels= c(1,2,3)))
# Model selection 
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","PFAS_SUM","T3_T4","ClutchSize", "AVG_turns_hour")])

Dredge_LM_AVG_Temp=dredge(lm(AVG_Temp_egg_Hour ~  PFAS_SUM +
                               AVG_turns_hour+
                               ClutchSize+
                               #BodyCondition+
                               #Incubation_stage+
                               #T3+ T4
                               + T3_T4+
                               #PFAS_SUM:T3+
                               #PFAS_SUM:T4+
                               PFAS_SUM:T3_T4,
                             data=ED1_complete,
                             na.action = "na.fail"),
                          fixed = c("PFAS_SUM","T3_T4"),
                          #                          subset = !(T3 && T4) &&
                          #                           !(T3 && T3_T4) &&
                          #                          !(T4 && T3_T4)
)

View(Dredge_LM_AVG_Temp)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_AVG_Temp, subset = 1)[[1]])
# if you want to see summary() of the 2nd best model
summary(get.models(Dredge_LM_AVG_Temp, subset = 2)[[1]])
summary(get.models(Dredge_LM_AVG_Temp, subset = 3)[[1]])

#Model output: 
EDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM+T3_T4+AVG_turns_hour, data=ED1_complete)
summary(EDTemT)
nobs(EDTemT)
confint(EDTemT)
#NULL
EDTemNULL <- lm(AVG_Temp_egg_Hour ~ 1, data=EDTemFULL)
AIC(EDTem7,EDTem8,EDTem9, EDTemNULL)

#Residuals test
par(mfrow = c(2, 2))  
plot(EDTemT)  
shapiro.test(residuals(EDTemT))
hist(residuals(EDTemT), breaks = 20, main = "Histogram of Residuals")
#Colinearity 
vif(EDTemT)

#ONLY FOR EGG TURNING ¨
#EDTem8 <- lm(AVG_Temp_egg_Hour~ scale(AVG_turns_hour), data=ED1)
#Checking for influencial points 
library(car)
influencePlot(EDTemT)  # Plots influence, labels extreme cases
# OR
cooksd <- cooks.distance(EDTemT)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_complete) - length(coef(EDTemT)) - 1), col = "red", lty = 2)
which(cooksd > 4/(nrow(ED1_complete) - length(coef(EDTemT)) - 1))
#Running the model without influential points
ED1_sub<- ED1_complete[-14, ] 
#MODEL
EDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM+T3_T4+AVG_turns_hour, data=ED1_sub)
summary(EDTemT)
nobs(EDTemT)

#Mediator analysis 
library(mediation)
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","AVG_turns_hour","PFAS_SUM","T3","T4","T3_T4","ClutchSize")])
#EDTurn <- lm(AVG_turns_hour~ PFAS_SUM*T3_T4, data=ED1_complete)
med.fit <- lm(AVG_turns_hour ~ PFAS_SUM * T3_T4, data = ED1_complete)
summary(med.fit)
#EDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM+T3_T4+AVG_turns_hour, data=ED1_complete)
out.fit <- lm(AVG_Temp_egg_Hour ~ PFAS_SUM + T3_T4 + AVG_turns_hour, data = ED1_complete)
summary(out.fit)
med.out <- mediate(med.fit, out.fit, treat = "PFAS_SUM", mediator = "AVG_turns_hour",
                   boot = TRUE, sims = 5000)
summary(med.out)
#JUST FOR TURNING RATES 
#GDTemTturn<- lm(AVG_Temp_egg_Hour~ scale(AVG_turns_hour)+scale(ClutchSize), data=GD1)
#GDTemTturn <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_turns_hour), data=GD1)

#Individual PFAS
ED1_complete <- na.omit(ED1_scaled[, c("AVG_Temp_egg_Hour","PFOS","T3_T4","ClutchSize", "AVG_turns_hour")])
EDTemPFUnA <- lm(AVG_Temp_egg_Hour~ PFUnA+T3_T4+AVG_turns_hour, data=ED1_complete)
EDTemPFHxS <-  lm(AVG_Temp_egg_Hour~ PFHxS+T3_T4+AVG_turns_hour, data=ED1_complete)
EDTemPFNA <-  lm(AVG_Temp_egg_Hour~ PFNA+T3_T4+AVG_turns_hour, data=ED1_complete)
EDTemPFOS <- lm(AVG_Temp_egg_Hour~ PFOS+T3_T4+AVG_turns_hour, data=ED1_complete)

summary(EDTemPFOS)
nobs(EDTemPFAS)

EDTemNULL <- lm(AVG_Temp_egg_Hour~ 1,data=EDTemFULL)
AIC(EDTemPFAS,EDTemNULL)

#Plotting# 
#PFAS on egg temperature
#EDTemT <- lm(AVG_Temp_egg_Hour~ PFAS_SUM+T3_T4+AVG_turns_hour, data=ED1_complete)
pfas_grid <- data.frame(
  PFAS_SUM = seq(min(ED1_complete$PFAS_SUM), max(ED1_complete$PFAS_SUM), length.out = 100),
  T3_T4 = mean(ED1_complete$T3_T4, na.rm = TRUE),
  AVG_turns_hour = mean(ED1_complete$AVG_turns_hour, na.rm = TRUE)
)

pfas_preds <- predict(EDTemT, newdata = pfas_grid, interval = "confidence")
pfas_grid$fit <- pfas_preds[, "fit"]
pfas_grid$lwr <- pfas_preds[, "lwr"]
pfas_grid$upr <- pfas_preds[, "upr"]

ggplot(pfas_grid, aes(x = PFAS_SUM, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "cornflowerblue", alpha = 0.15) +
  geom_line(color = "cornflowerblue", size = 1.2) +
  geom_point(data = ED1_complete, aes(x = PFAS_SUM, y = AVG_Temp_egg_Hour),
             alpha = 0.5, size = 3, color = "cornflowerblue") +
  labs(x = "∑PFAS (scaled)", y = "Scaled average hourly egg temperature (°C)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

#Average egg turning on egg temperature 
turns_grid <- data.frame(
  AVG_turns_hour = seq(min(ED1_complete$AVG_turns_hour), max(ED1_complete$AVG_turns_hour), length.out = 100),
  PFAS_SUM = mean(ED1_complete$PFAS_SUM, na.rm = TRUE),
  T3_T4 = mean(ED1_complete$T3_T4, na.rm = TRUE)
)

turns_preds <- predict(EDTemT, newdata = turns_grid, interval = "confidence")
turns_grid$fit <- turns_preds[, "fit"]
turns_grid$lwr <- turns_preds[, "lwr"]
turns_grid$upr <- turns_preds[, "upr"]

ggplot(turns_grid, aes(x = AVG_turns_hour, y = fit)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "cornflowerblue", alpha = 0.15) +
  geom_line(color = "#6495ED", size = 1.2) +
  geom_point(data = ED1_complete, aes(x = AVG_turns_hour, y = AVG_Temp_egg_Hour),
             alpha = 0.5, size = 3, color = "cornflowerblue") +
  labs(x = "Average hourly egg turning (scaled)", y = "Scaled average hourly egg temperature (°C)") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

##PFASs all and egg temperature 
coefs <- bind_rows(
  tidy(EDTemPFUnA, conf.int = TRUE) %>% mutate(compound = "PFUnA"),
  tidy(EDTemPFHxS, conf.int = TRUE) %>% mutate(compound = "PFHxS"),
  tidy(EDTemPFNA, conf.int = TRUE) %>% mutate(compound = "PFNA"),
  tidy(EDTemPFOS, conf.int = TRUE) %>% mutate(compound = "PFOS")
)

coefs <- coefs %>% filter(term %in% c("PFUnA","PFHxS","PFNA","PFOS"))

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    p.value < 0.10  ~ ".",  
    TRUE            ~ ""
  ))
coefs <- coefs %>%
  mutate(conc_level = case_when(
    compound == "PFUnA" ~ 1,
    compound == "PFHxS" ~ 2,
    compound == "PFNA"  ~ 3,
    compound == "PFOS"  ~ 4
  ))

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = 0.5, vjust = -0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "#B0C4DE",  
    high = "#4169E9", 
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "",
    title = "Average hourly egg temperature"
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  )


#---- Q5) Hatching success, turning frequency, egg temperature and PFAS ----
#------Goldeneye------
GD1 <- GD1%>%
  rename(Hatched_eggs = `Hatched eggs`)

GD1_scaled <- GD1
GD1_scaled$PFAS_SUM <- as.numeric(scale(GD1$PFAS_SUM))
GD1_scaled$PFOS <- as.numeric(scale(GD1$PFOS))
GD1_scaled$PFDoDA <- as.numeric(scale(GD1$PFDoDA))
GD1_scaled$PFNA <- as.numeric(scale(GD1$PFNA))
GD1_scaled$PFUnA <- as.numeric(scale(GD1$PFUnA))
#GD1_scaled$T3 <- as.numeric(scale(GD1$T3))
#GD1_scaled$T4 <- as.numeric(scale(GD1$T4))
#GD1_scaled$T3_T4 <- as.numeric(scale(GD1$T3_T4))
GD1_scaled$AVG_Temp_egg_Hour <- as.numeric(scale(GD1$AVG_Temp_egg_Hour))
GD1_scaled$BodyCondition <- as.numeric(scale(GD1$BodyCondition))
GD1_scaled$AVG_turns_hour <- as.numeric(scale(GD1$AVG_turns_hour))

#Correlation check
COR <- GD1[, c("AVG_turns_hour", "T3_T4" ,"PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model selection 
GD1_complete <- na.omit(GD1_sub[, c("AVG_Temp_egg_Hour","PFAS_SUM","Hatched_eggs","ClutchSize","AVG_turns_hour")])

Dredge_GLM_Hatch <- dredge(
  glm(
    cbind(Hatched_eggs, ClutchSize) ~  
      PFAS_SUM +
      AVG_turns_hour+
      AVG_Temp_egg_Hour,
    #T3 + T4 + T3_T4 +
    #PFAS_SUM:T3 +
    #PFAS_SUM:T4 +
    #PFAS_SUM:T3_T4,
    data = GD1_complete,
    family = binomial,
    na.action = "na.fail"),
  fixed = c("PFAS_SUM")
  #subset = !(T3 && T4) &&
  # !(T3 && T3_T4) &&
  #!(T4 && T3_T4)
)

View(Dredge_GLM_Hatch)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_GLM_Hatch, subset = 1)[[1]])
# if you want to see summary() of the 2nd best model
summary(get.models(Dredge_GLM_Hatch, subset = 2)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 3)[[1]])

#Model output 

GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ PFAS_SUM +AVG_Temp_egg_Hour, family = binomial(), data = GD1_scaled)
#GDHatch <- glm(
 # cbind(Hatched_eggs, ClutchSize) ~ PFAS_SUM +AVG_Temp_egg_Hour, family = binomial(), data = GD1_complete)

summary(GDHatch)
nobs(GDHatch)

#Model check
simres <- simulateResiduals(GDHatch) 
plot(simres)
testDispersion(simres)

mod_lm <- lm(HatchingSuccess ~ scale(PFAS_SUM) + scale(AVG_Temp_egg_Hour), data = GD1_scaled)
vif(mod_lm)
GDHatchFULL <- GD1[complete.cases(GD1[c("ClutchSize","Hatched_eggs","PFAS_SUM", "AVG_Temp_egg_Hour")]), ]
GDNull <- glmmTMB(cbind(Hatched_eggs, ClutchSize)~ 1, family= binomial(), data=GDHatchFULL)
AIC(GDNull, GDHatch)
#Influential points
library(car)
influencePlot(GDHatch)  # Plots influence, labels extreme cases
# OR
cooksd <- cooks.distance(GDHatch)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_sub) - length(coef(GDHatch)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(GD1_sub) - length(coef(GDHatch)) - 1))
infl_obs
#To make sure which observation is the influential 
as.numeric(rownames(GDHatch$model)[infl_obs])

#IF needed! Re-running the model with the subset, excluding the influential points: 
GD1_sub<- GD1_scaled[-10, ]  # Removes the second row
#MODEL
GDHatch <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ PFAS_SUM +AVG_Temp_egg_Hour, family = binomial(), data = GD1_sub)
summary(GDHatch)
nobs(GDHatch)

# Individual PFAS # 
COR <- GD1[, c("AVG_turns_hour", "T3_T4" ,"PFOS", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "HatchingSuccess_adj")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GDHatchFULL <- GD1[complete.cases(GD1[c("ClutchSize","Hatched_eggs","PFOS", "T4", "AVG_turns_hour")]), ]

GDHatchPFUnA <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ PFUnA+ AVG_Temp_egg_Hour, family = binomial(), data = GD1_sub)
GDHatchPFNA<- glm(
  cbind(Hatched_eggs, ClutchSize) ~ PFNA+ AVG_Temp_egg_Hour , family = binomial(), data = GD1_sub)
GDHatchPFDoDA <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ PFDoDA + AVG_Temp_egg_Hour, family = binomial(), data = GD1_sub)
GDHatchPFOS <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ PFOS + AVG_Temp_egg_Hour+ T4, family = binomial(), data = GD1_sub)
#GDHatchPFOS <- glm(
  #cbind(Hatched_eggs, ClutchSize) ~ scale(PFOS) +scale(AVG_turns_hour)+scale(T4), family = binomial(), data = GD1)
#GDHatchPFOS <- glm(
  #cbind(Hatched_eggs, ClutchSize) ~ scale(PFOS) +scale(AVG_Temp_egg_Hour), family = binomial(), data = GD1)
summary(GDHatchPFOS)
nobs(GDHatchPFOS)

GDHatchNullPFAS <- glm(cbind(Hatched_eggs, ClutchSize) ~ 1, family = binomial(), data = GDHatchFULL)
AIC(GDHatchPFOS1,GDHatchPFOS2,GDHatchNullPFAS)
anova(GDHatchPFOS, GDHatchNullPFAS, test = "Chisq")

#Model check 
simres <- simulateResiduals(GDHatchPFOS) 
plot(simres)
testDispersion(simres)

mod_lm <- lm(HatchingSuccess ~ scale(PFOS) +scale(AVG_turns_hour)+scale(T4), data = GD1)
vif(mod_lm)

#Plot
# Egg temperature on hatching success 
sum(!is.na(GD1$AVG_Temp_egg_Hour)& !is.na(GD1$ClutchSize) & !is.na(GD1$Hatched_eggs))
#GD11 <- GD1
GD1$HatchingSuccess <- GD1$Hatched_eggs / GD1$ClutchSize

temp_seq <- seq(min(GD1$AVG_Temp_egg_Hour, na.rm = TRUE),
                max(GD1$AVG_Temp_egg_Hour, na.rm = TRUE),
                length.out = 100)

new_data <- data.frame(
  AVG_Temp_egg_Hour = temp_seq,
  PFAS_SUM = mean(GD1$PFAS_SUM, na.rm = TRUE)  # fixed PFAS level
)

pfas_center <- attr(scale(GD1$PFAS_SUM), "scaled:center")
pfas_scale <- attr(scale(GD1$PFAS_SUM), "scaled:scale")
temp_center <- attr(scale(GD1$AVG_Temp_egg_Hour), "scaled:center")
temp_scale <- attr(scale(GD1$AVG_Temp_egg_Hour), "scaled:scale")

new_data$PFAS_SUM_scaled <- (new_data$PFAS_SUM - pfas_center) / pfas_scale
new_data$AVG_Temp_egg_Hour_scaled <- (new_data$AVG_Temp_egg_Hour - temp_center) / temp_scale

pred_input <- data.frame(
  PFAS_SUM = new_data$PFAS_SUM_scaled,
  AVG_Temp_egg_Hour = new_data$AVG_Temp_egg_Hour_scaled
)

pred <- predict(GDHatch1, newdata = new_data, type = "link", se.fit = TRUE)
new_data$fit <- pred$fit
new_data$se <- pred$se.fit
new_data$predicted_prob <- plogis(new_data$fit)
new_data$lower <- plogis(new_data$fit - 1.96 * new_data$se)
new_data$upper <- plogis(new_data$fit + 1.96 * new_data$se)

new_data$predicted_prob <- predict(GDHatch1, newdata = new_data, type = "response")


ggplot(new_data, aes(x = AVG_Temp_egg_Hour, y = predicted_prob)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "#B8800B", alpha = 0.2) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_point(data = GD1, aes(x = AVG_Temp_egg_Hour, y = HatchingSuccess),
             inherit.aes = FALSE,color = "#B8800B", alpha = 0.5, size = 2) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = "",
    x = "Average egg temperature (°C)",
    y = "Predicted hatching success"
  )

#------ Eider------
# Checking whether body condition varies across incuation stages 
hist(ED1$BodyCondition)
levels(ED1$Incubation_stage)
BODY <- lm(BodyCondition~ Incubation_stage, data= ED1)
summary(BODY)

ED1$Incubation_stage <- as.factor(ED1$Incubation_stage)

anova_result <- aov(BodyCondition~ Incubation_stage, data = ED1)
summary(anova_result)

ggplot(ED1, aes(x = Incubation_stage, y = BodyCondition)) +
  geom_boxplot(fill = "cornflowerblue", alpha = 0.6) +
  theme_minimal() +
  labs(x = "Incubation Stage", y = "Body Condition")
#Correlation check
ED1 <- ED1%>%
  rename(Hatched_remains = `Hatched remains`)
ED1$Hatched_remains <- as.numeric(ED1$Hatched_remains)
COR <- ED1[, c("AVG_turns_hour","T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "ClutchSize","Hatched_remains")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model selection 
ED1_complete <- na.omit(ED1_scaled [, c("AVG_Temp_egg_Hour","PFAS_SUM","Hatched_remains","ClutchSize","AVG_turns_hour")])

Dredge_GLM_Hatch=dredge(glm(cbind(Hatched_remains, ClutchSize) ~  PFAS_SUM +
                              AVG_turns_hour+
                              AVG_Temp_egg_Hour,
                            #BodyCondition,
                            #T3+ T4+ T3_T4+
                            #PFAS_SUM:T3+
                            #PFAS_SUM:T4+
                            #PFAS_SUM:T3_T4,
                            data=ED1_complete,
                            family= binomial,
                            na.action = "na.fail"),
                        fixed = c("PFAS_SUM")
                        #subset = !(T3 && T4) &&
                        # !(T3 && T3_T4) &&
                        #!(T4 && T3_T4)
)

View(Dredge_GLM_Hatch)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_GLM_Hatch, subset = 1)[[1]])
# if you want to see summary() of the 2nd best model
summary(get.models(Dredge_GLM_Hatch, subset = 2)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 3)[[1]])

#Model output

EDHatch <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) +scale(AVG_Temp_egg_Hour), family = binomial(), data = ED1_scaled)

summary(EDHatch)
simres <- simulateResiduals(EDHatch) 
plot(simres)
testDispersion(simres)

#Influential points
library(car)
influencePlot(EDHatch)  # Plots influence, labels extreme cases
# OR
cooksd <- cooks.distance(EDHatch)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_scaled) - length(coef(EDHatch)) - 1), col = "red", lty = 2)
which(cooksd > 4/(nrow(ED1_scaled) - length(coef(EDHatch)) - 1))
#

EDHatchFULL <- ED1[complete.cases(ED1[c("ClutchSize","Hatched_remains","PFAS_SUM", "T3_T4")]), ]
EDNull <- glm(cbind(Hatched_remains, ClutchSize)~ 1, family= binomial(), data=EDHatchFULL)
AIC(EDNull, EDHatch1)

#OR# 
##Modeling the absolute hatching success 

#Model selection 
ED1_complete <- na.omit(ED1_scaled [, c("Absolute_Hatch","PFAS_SUM","ClutchSize","AVG_turns_hour","AVG_Temp_egg_Hour")])

Dredge_GLM_Hatch=dredge(glm(Absolute_Hatch ~  PFAS_SUM +
                              AVG_turns_hour+
                              #AVG_Temp_egg_Hour+
                              #BodyCondition,
                              ClutchSize,
                            data=ED1_complete,
                            family= binomial,
                            na.action = "na.fail"),
                        fixed = c("PFAS_SUM")
                        
)

View(Dredge_GLM_Hatch)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_GLM_Hatch, subset = 1)[[1]])
# if you want to see summary() of the 2nd best model
summary(get.models(Dredge_GLM_Hatch, subset = 2)[[1]])
summary(get.models(Dredge_GLM_Hatch, subset = 3)[[1]])

#Model output

glm_abs2 <- glm(Absolute_Hatch ~ PFAS_SUM + ClutchSize,
                family = binomial(),
                data = ED1_scaled)
summary(glm_abs2)
nobs(glm_abs2)
#Model testing 
simres <- simulateResiduals(glm_abs2) 
plot(simres)
testDispersion(simres)

check_collinearity(glm_abs2)

EDNull <- glm(Absolute_Hatch~ 1, family= binomial(), data=EDHatchFULL)
AIC(EDNull, glm_abs2)

# Individual PFAS # 
COR <- ED1[, c("AVG_turns_hour", "T3_T4" ,"PFOS", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "HatchingSuccess_adj")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

EDHatchFULL <- ED1[complete.cases(ED1[c("ClutchSize", "Hatched_remains","AVG_Temp_egg_Hour","AVG_turns_hour","PFOS", "T3_T4")]), ]

EDHatchPFUnA <- EDHatch <- glm(
  cbind(Hatched_remains, ClutchSize) ~ PFUnA +AVG_Temp_egg_Hour, family = binomial(), data = ED1_scaled)
EDHatchPFNA<- glm(
  cbind(Hatched_remains, ClutchSize) ~ PFNA + AVG_Temp_egg_Hour , family = binomial(), data = ED1_scaled)
EDHatchPFHxS <- glm(
  cbind(Hatched_remains, ClutchSize) ~ PFHxS + AVG_Temp_egg_Hour, family = binomial(), data = ED1_scaled)
EDHatchPFOS<- glm(
  cbind(Hatched_remains, ClutchSize) ~ PFOS + AVG_Temp_egg_Hour, family = binomial(), data = ED1)


summary(EDHatchPFOS)
nobs(EDHatchPFOS)

simres <- simulateResiduals(EDHatchPFOS) 
plot(simres)
testDispersion(simres)

check_collinearity(EDHatchPFOS)


#----Q6) PFAS ~ THs ----
#------Goldeneye------
COR <- GD1[, c("T3","T4","PFAS_SUM", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GD1_scaled <- GD1
GD1_scaled$PFAS_SUM <- scale(GD1$PFAS_SUM)
GD1_scaled$T3 <- scale(GD1$T3)
GD1_scaled$T4 <- scale(GD1$T4)
GD1_scaled$T3_T4 <- scale(GD1$T3_T4)
GD1_scaled$ClutchSize <- scale(GD1$ClutchSize)
GD1_scaled$AVG_Temp_egg_Hour <- scale(GD1$AVG_Temp_egg_Hour)
GD1_scaled$BodyCondition <- scale(GD1$BodyCondition)
GD1_scaled$RecordedDays <- scale(GD1$RecordedDays)

#Model selection 
GD1_complete <- na.omit(GD1_scaled[, c("PFAS_SUM","BodyCondition","T3_T4", "ClutchSize","AVG_Temp_egg_Hour","AVG_turns_hour")])

Dredge_LM_TH=dredge(lm(T3_T4 ~  PFAS_SUM +
                         ClutchSize+
                         BodyCondition+
                         AVG_turns_hour+
                         AVG_Temp_egg_Hour+
                         PFAS_SUM:BodyCondition+
                         PFAS_SUM:ClutchSize,
                       data=GD1_complete,
                       na.action = "na.fail"),
                    fixed = c("PFAS_SUM")
)

View(Dredge_LM_TH)

#summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_TH, subset = 1)[[1]])
#summary() of the 2nd best model
summary(get.models(Dredge_LM_TH, subset = 2)[[1]])
summary(get.models(Dredge_LM_TH, subset = 3)[[1]])

#Final model: 
#T3
GDThyT3<- lm(log(T3)~ PFAS_SUM, data=GD1_scaled)
summary(GDThyT3)
#T4
GDThyT4<- lm(log(T4)~ PFAS_SUM + BodyCondition, data=GD1_scaled)
summary(GDThyT4)
#T3:T4
GDThyT3T4<- lm(log(T3_T4)~ PFAS_SUM, data=GD1_scaled)
summary(GDThyT3T4)

# Model diagnostics 
par(mfrow = c(2, 2))  
plot(GDThyT3)  
shapiro.test(residuals(GDThyT3))
hist(residuals(GDThyT3), breaks = 20, main = "Histogram of Residuals")

#Influential points 
library(car)
influencePlot(GDThyT3T4)
# OR
cooksd <- cooks.distance(GDThyT3T4)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(GD1_scaled) - length(coef(GDThyT3T4)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(GD1_scaled) - length(coef(GDThyT3T4)) - 1))
infl_obs
as.numeric(rownames(GDThyT3T4$model)[infl_obs])

#Re-running without influential points 
GD1_sub <- GD1_scaled[-c(2,6),]
GDThyT3<- lm(log(T3)~ PFAS_SUM, data=GD1_sub)
summary(GDThyT3)
#
GDThyT3T4<- lm(log(T3_T4)~ PFAS_SUM, data=GD1_sub)
summary(GDThyT3T4)


#------Eider------ 
COR <- ED1[, c("T3","T4","PFAS_SUM", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

ED1_scaled <- ED1
ED1_scaled$PFAS_SUM <- as.numeric(scale(ED1$PFAS_SUM))
ED1_scaled$T3 <- as.numeric(scale(ED1$T3))
ED1_scaled$T4 <- as.numeric(scale(ED1$T4))
ED1_scaled$T3_T4 <- as.numeric(scale(ED1$T3_T4))
ED1_scaled$ClutchSize <- as.numeric(scale(ED1$ClutchSize))
ED1_scaled$AVG_Temp_egg_Hour <- as.numeric(scale(ED1$AVG_Temp_egg_Hour))
ED1_scaled$BodyCondition <- as.numeric(scale(ED1$BodyCondition))
ED1_scaled$AVG_turns_hour <- as.numeric(scale(ED1$AVG_turns_hour))

#Model selection 
ED1_complete <- na.omit(ED1_scaled[, c("PFAS_SUM","T3_T4","BodyCondition", "ClutchSize","AVG_Temp_egg_Hour","AVG_turns_hour")])

Dredge_LM_TH=dredge(lm(T3_T4 ~  PFAS_SUM +
                         ClutchSize+
                         BodyCondition+
                         AVG_Temp_egg_Hour+
                         AVG_turns_hour+
                         PFAS_SUM:BodyCondition+
                         PFAS_SUM:ClutchSize,
                       data=ED1_complete,
                       na.action = "na.fail"),
                    fixed = c("PFAS_SUM")
)

View(Dredge_LM_TH)

# if you want to view summary() of the model with the lowest AICc
summary(get.models(Dredge_LM_TH, subset = 1)[[1]])
# if you want to see summary() of the 2nd best model
summary(get.models(Dredge_LM_TH, subset = 2)[[1]])
summary(get.models(Dredge_LM_TH, subset = 3)[[1]])

#Final model: 
EDThyT3<- lm(log(T3+1)~ PFAS_SUM, data=ED1_scaled)
summary(EDThyT3)
#T4
EDThyT4<- lm(log(T4+1)~ PFAS_SUM, data=ED1_scaled)
summary(EDThyT4)
#T3:T4
EDThyT3T4<- lm(log(T3_T4+1)~ PFAS_SUM, data=ED1_scaled)
summary(EDThyT3T4)

# Model diagnostics 
par(mfrow = c(2, 2))  
plot(EDThyT3T4)  
shapiro.test(residuals(EDThyT3T4))
hist(residuals(EDThyT3T4), breaks = 20, main = "Histogram of Residuals")

#Influential points 
library(car)
influencePlot(EDThyT3T4)
# OR
cooksd <- cooks.distance(EDThyT3T4)
plot(cooksd, type = "h", main = "Cook's Distance")
abline(h = 4/(nrow(ED1_scaled) - length(coef(EDThyT3T4)) - 1), col = "red", lty = 2)
infl_obs<- which(cooksd > 4/(nrow(ED1_scaled) - length(coef(EDThyT3T4)) - 1))
infl_obs
as.numeric(rownames(EDThyT3T4$model)[infl_obs])

#Re-running without influential points 
ED1_sub <- ED1_scaled[-c(1,19),]
EDThyT3<- lm(log(T3)~ PFAS_SUM, data=ED1_sub)
summary(EDThyT3)
#
EDThyT4<- lm(log(T4+1)~ PFAS_SUM, data=ED1_sub)
summary(EDThyT4)
nobs(EDThyT4)
#
EDThyT3T4<- lm(log(T3_T4+1)~ PFAS_SUM, data=ED1_sub)
summary(EDThyT3T4)


#### Additional plots #### 
#From the raw data. Individual example
#Cumpative hourly turns as a function of euler angle change in an individual
library(circular)
library(lubridate)
library(tidyverse)

GD1$Overal_angularChange_mean <- as.numeric(GD1$Overal_angularChange_mean)

#1)
#Euler angle based on Euler theorom
GDEX <- `GD11(K07)`

GDEX <- GDEX %>%
  mutate(FemaleID = "HT107525")

GDEX <- GDEX %>%
  mutate(AVG_turns_hour = 1.306)

GDEX <- GDEX %>%
  mutate(`Overall mean angular change` = 17.021)

GDEX <- GDEX %>%
  mutate(Euler_Angle = circular(sqrt(Roll^2 + Pitch^2 + Yaw^2), units="degrees")) 

GDSUM1 <- GDEX %>%
  group_by(FemaleID) %>%
  arrange(FemaleID) %>%
  mutate(
    cum_turns = cumsum(AVG_turns_hour),
    cum_angular_change = cumsum(`Overall mean angular change`)
  )


ggplot(GDSUM1, aes(x = cum_angular_change, y = cum_turns, color = as.factor(FemaleID))) +
  geom_line(size = 1, alpha = 0.6) + 
  geom_point() +  
  geom_smooth(method = "loess", aes(group = 1), color = "black", se = TRUE) + 
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.96, 0.32),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = "",
    x = "Cumulative Angular Change (degrees)",
    y = "Cumulative Egg Turns (per hour)",
    color = "FemaleID"
  )



##Trnaslation of the code from Matlab
install.packages("R.matlab")
library(R.matlab)
#5 example eider females 
dAngle1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle1.mat")
dataSave1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave1.mat")
deltaAngle1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle1.mat")
time1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time1.mat")
startInd1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd1.mat")
endInd1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd1.mat")
#
dAngle2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle2.mat")
dataSave2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave2.mat")
deltaAngle2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle2.mat")
time2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time2.mat")
startInd2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd2.mat")
endInd2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd2.mat")
# 
dAngle3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle3.mat")
dataSave3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave3.mat")
deltaAngle3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle3.mat")
time3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time3.mat")
startInd3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd3.mat")
endInd3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd3.mat")
#
dAngle4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle4.mat")
dataSave4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave4.mat")
deltaAngle4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle4.mat")
time4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time4.mat")
startInd4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd4.mat")
endInd4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd4.mat")
#
dAngle5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle5.mat")
dataSave5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave5.mat")
deltaAngle5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle5.mat")
time5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time5.mat")
startInd5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd5.mat")
endInd5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd5.mat")

#2)
#dAngle <- dAngle1$dAngle
#dataSave <- dataSave1$dataSave
#deltaAngle <- deltaAngle1$deltaAngle
#time <- time1$time
#startInd <- startInd1$startInd
#endInd <- endInd1$endInd
individuals_data <- list(
  list(dAngle = dAngle1$dAngle, dataSave=dataSave1$dataSave, deltaAngle = deltaAngle1$deltaAngle, time = time1$time, startInd = startInd1$startInd, endInd = endInd1$endInd),
  list(dAngle = dAngle2$dAngle, dataSave=dataSave2$dataSave, deltaAngle = deltaAngle2$deltaAngle, time = time2$time, startInd = startInd2$startInd, endInd = endInd2$endInd),
  list(dAngle = dAngle3$dAngle, dataSave=dataSave3$dataSave, deltaAngle = deltaAngle3$deltaAngle, time = time3$time, startInd = startInd3$startInd, endInd = endInd3$endInd),
list(dAngle = dAngle4$dAngle, dataSave=dataSave4$dataSave, deltaAngle = deltaAngle4$deltaAngle, time = time4$time, startInd = startInd4$startInd, endInd = endInd4$endInd),
list(dAngle = dAngle5$dAngle, dataSave=dataSave5$dataSave, deltaAngle = deltaAngle5$deltaAngle, time = time5$time, startInd = startInd5$startInd, endInd = endInd5$endInd))
#3)

#threshold_deg <- 10
#threshold_rad <- threshold_deg * pi / 180

#indices_greater_than_threshold <- which(deltaAngle > threshold_rad)

#start_times <- time1[startInd[indices_greater_than_threshold]]
#end_times <- time1[endInd[indices_greater_than_threshold]]
all_num_events_per_hr <- list()
all_dAngle <- list()

#plot((dataSave[5, startInd] + dataSave[5, endInd]) / 2 / 3600, 
     #deltaAngle * 180 / pi, 
     #main = "Angle Change vs. Time", 
    # xlab = "Time [hr]", 
   #  ylab = "Change in Orientation [deg]", 
  #   pch = 20, 
 #    col = "blue")
#grid()

dAngle <- seq(0, 180, by = 1) * pi / 180
num_events_per_hr <- sapply(dAngle, function(angle) {
  3600 * sum(deltaAngle > angle) / (max(time) - min(time))
})

smooth_fit <- smooth.spline(dAngle * 180 / pi, num_events_per_hr, spar = 0.7)
#plot(dAngle * 180 / pi, num_events_per_hr, 
#   type = "l", 
#    col = "#B8800B", 
#   lwd=2,
#    main = "Rotations per Hour vs. Angular Threshold", 
#    xlab = "Angle Threshold [deg]", 
#   ylab = "Rotations per Hour", 
#   xaxp = c(0, 180, 9))

for (i in 1:length(individuals_data)) {
  # Access individual data
  individual <- individuals_data[[i]]
  
  deltaAngle <- individual$deltaAngle
  time <- individual$time
  startInd <- individual$startInd
  endInd <- individual$endInd
  
  # Calculate number of events per hour for this individual
  num_events_per_hr_individual <- sapply(dAngle, function(angle) {
    3600 * sum(deltaAngle > angle) / (max(time) - min(time))
  })
  
  # Store results
  all_num_events_per_hr[[i]] <- num_events_per_hr_individual
  all_dAngle[[i]] <- dAngle
}

combined_num_events_per_hr <- do.call(cbind, all_num_events_per_hr)
combined_dAngle <- all_dAngle[[1]]  # Assuming the same angles for all individuals

mean_num_events_per_hr <- apply(combined_num_events_per_hr, 1, mean)
sd_num_events_per_hr <- apply(combined_num_events_per_hr, 1, sd)
ci_lower <- mean_num_events_per_hr - 1.96 * (sd_num_events_per_hr / sqrt(ncol(combined_num_events_per_hr)))
ci_upper <- mean_num_events_per_hr + 1.96 * (sd_num_events_per_hr / sqrt(ncol(combined_num_events_per_hr)))


combined_dAngle_deg <- combined_dAngle * 180 / pi
x_value <- 10
y_value_at_x_10 <- approx(combined_dAngle_deg, mean_num_events_per_hr, xout = x_value)$y

y_lim <- range(c(mean_num_events_per_hr, ci_upper, ci_lower), na.rm = TRUE)

plot(combined_dAngle * 180 / pi, mean_num_events_per_hr, 
     type = "l", 
     col = "#B8800B", 
     lwd = 4,
     main = "", 
     xlab = "Anglular change [deg]", 
     ylab = "Cumulative turns per hour", 
     xaxp = c(0, 180, 9),
     bty="n",
     ylim=y_lim)

lines(combined_dAngle * 180 / pi, ci_upper, 
      col = "red", 
      lty = 2,  # Dashed line for upper CI
      lwd = 2)

lines(combined_dAngle * 180 / pi, ci_lower, 
      col = "red", 
      lty = 2,  # Dashed line for lower CI
      lwd = 2)

points(x_value, y_value_at_x_10, col = "black", pch = 20, cex = 1.5)


### Example of daily temperature 
#GD 1:
GDTem <- `GD11(K07)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#random_date <- sample(unique(GDTem$Date), 1)
#print(random_date)
random_date<- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span=0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = paste("Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 2: 
GDTem <- `GD81(K05)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 3: 
GDTem <- `GD219(K16)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 4: 
GDTem <- `GD96(K08)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )


### Eiders###
#ED 1:
EDTem <- `ED(B108W1.4)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#Either an assigned date
random_date <- as.Date("2023-05-29")
print(random_date)
#OR a random date
#random_date <- sample(unique(EDTem$Date), 1)
#print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span=0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = paste("(Late breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#ED 2: 
EDTem <- `ED(B102W2.4)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Late breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )
#ED3
EDTem <- `ED(B22W1.3)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

#random_date <- sample(unique(EDTem$Date), 1)
#print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Early breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#ED4

EDTem <- `ED(B23W2.3)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)


ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Early breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

##### Daily turning movement 
library(circular)
library(lubridate)
library(tidyverse)
#Euler angle 
# Eider 1
EDMove1 <- `ED(B23W2.3)`

EDMove1$Date <- as.Date(EDMove1$Date)  
EDMove1$Time <- as.POSIXct(paste(EDMove1$Date, EDMove1$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

ED_24h <- EDMove1 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable"
  )

# OR
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_line(size = 1, alpha = 0.7) +  # Reduce opacity for better readability
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  )+
  labs(
    title = paste("(Early breeder) - Roll, Yaw, and Pitch, Date:", random_date),
    x = "Time",
    y = "Euler Angles (degrees)",
    color = "Variable"
  )

# Eider 2
EDMove2 <- `ED(B22W1.3)`

EDMove2$Date <- as.Date(EDMove2$Date)  
EDMove2$Time <- as.POSIXct(paste(EDMove2$Date, EDMove2$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

ED_24h <- EDMove2 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# Eider 3
EDMove3<- `ED(B102W2.4)`

EDMove3$Date <- as.Date(EDMove3$Date)  
EDMove3$Time <- as.POSIXct(paste(EDMove3$Date, EDMove3$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDMove3 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# Eider 4
EDMove4<- `ED(B108W1.4)`

EDMove4$Date <- as.Date(EDMove4$Date)  
EDMove4$Time <- as.POSIXct(paste(EDMove4$Date, EDMove4$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDMove4 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

###In goldeneye
#GD1
GDMove1 <- `GD11(K07)`

GDMove1$Date <- as.Date(GDMove1$Date)  
GDMove1$Time <- as.POSIXct(paste(GDMove1$Date, GDMove1$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove1 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD2
GDMove2 <- `GD81(K05)`

GDMove2$Date <- as.Date(GDMove2$Date)  
GDMove2$Time <- as.POSIXct(paste(GDMove2$Date, GDMove2$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove2 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD3
GDMove3 <- `GD219(K16)`

GDMove3$Date <- as.Date(GDMove3$Date)  
GDMove3$Time <- as.POSIXct(paste(GDMove3$Date, GDMove3$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove3 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD4
GDMove4 <- `GD96(K08)`

GDMove4$Date <- as.Date(GDMove4$Date)  
GDMove4$Time <- as.POSIXct(paste(GDMove4$Date, GDMove4$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove4 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
library(dplyr)
library(tidyr)

GD_24h_long <- GD_24h %>%
  dplyr::select(Time, Roll, Yaw, Pitch) %>%
  tidyr::pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")


# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

####### Euler+Temp plot#####
#GD4
library(patchwork)

GDData <- `GD11(K07)`
# Convert Date and Time
GDData$Date <- as.Date(GDData$Date)  
GDData$Time <- as.POSIXct(paste(GDData$Date, GDData$Time), format="%Y-%m-%d %H:%M:%S")

# Select Date
selected_date <- as.Date("2022-05-15")
#start_date <- as.Date("2022-05-15 00:00:00")
#end_date <- as.Date("2022-05-19 00:00:00")
#GD_MultiDay <- GDData %>%
 # filter(Date >= start_date & Date <= end_date)
# Filter Data for 24 hours
GD_24h <- GDData %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

# First Plot: Egg Temperature
p1 <- ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Temperature (°C)",
    x = ""
  ) +
  #coord_cartesian(ylim = c(NA, 43)) + 
  scale_y_continuous(
    limits = c(35, 43),
    expand = c(0, 0),
    breaks = seq(35, 42.5, by = 2.5))+
  theme_minimal()+
  theme(
    axis.text.x = element_blank(),   # remove x-axis text
    axis.ticks.x = element_blank(),  # remove x-axis ticks
    axis.title.x = element_blank()   # remove x-axis label
  )
#theme(
 # panel.background = element_rect(fill = "transparent", colour = NA),
  #axis.line = element_line(color = "black"),
  #axis.text.x = element_text(angle = 45, hjust = 1),
  #plot.background = element_rect(fill = "transparent", colour = NA)
#)

# Second Plot: Euler Angle (On its Own Scale)
p2 <- ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha = 0.8, linewidth = 1) +
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Euler Angle (°)",
    x = "Time"
  ) +
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis.title.x = element_blank()
  )

# Combine the two plots with the same X-axis
p1 / p2  # Using `patchwork` to stack them vertically

## ED4

EDdata <- `ED(B108W1.4)`

EDdata$Date <- as.Date(EDdata$Date)  
EDdata$Time <- as.POSIXct(paste(EDdata$Date, EDdata$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#Either an assigned date
#selected_date <- as.Date("2023-05-29")
#print(selected_date)
#OR a random date
random_date <- sample(unique(EDdata$Date), 1)
print(random_date)
#or
#random_date<- as.Date("2023-06-02")

ED_24h <- EDdata %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

p1 <- ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "cornflowerblue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Temperature (°C)",
    x = ""
  ) +
  scale_y_continuous(
    limits = c(35, 42.5),
    expand = c(0, 0),
    breaks = seq(35, 42.5, by = 2.5))+
  theme_minimal()+
  theme(
    axis.text.x = element_blank(),   # remove x-axis text
    axis.ticks.x = element_blank(),  # remove x-axis ticks
    axis.title.x = element_blank()   # remove x-axis label
  )
#theme(
# panel.background = element_rect(fill = "transparent", colour = NA),
#axis.line = element_line(color = "black"),
#axis.text.x = element_text(angle = 45, hjust = 1),
#plot.background = element_rect(fill = "transparent", colour = NA)
#)

# Second Plot: Euler Angle (On its Own Scale)
p2 <- ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "cornflowerblue", alpha = 0.8, size = 1) +
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Euler Angle (°)",
    x = "Time"
  ) +
  coord_cartesian(ylim = c(0, 50)) + 
  theme_minimal()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), 
    axis.title.x = element_blank()
  )

# Combine the two plots with the same X-axis
p1 / p2  # Using `patchwork` to stack them vertically


