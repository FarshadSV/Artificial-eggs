#Upload packages 
library(ggplot2)
library(ggeffects)
library(effects)
library(lme4)
library(lmerTest)
library(glmmTMB)
library(emmeans)
library(Matrix)
library(lmerTest)
library(dplyr)
library(writexl)
library(DHARMa)
library(performance)
library(car)
library(Hmisc)
library(MASS)
library(betareg)
library(lmtest)
#R.version.string
#citation()
ED1 <- ED1_Modeling
ED2 <- ED2_Modeling
GD1 <- GD1_Final
GD2 <- GD2_Final

#Making the weighted average for the egg attendance for the nests with 2 loggers 
#Weighted average egg turning rate= (Egg turning all*recorded hours)1 + (Egg turning all* recorded hours)2 / Recorded hours 1+ Recorded hours 2
#1) K26 (Overall turns divided by overall recorded hours)
eggTurn1 <- 33/668
eggTurn2 <- 48/75
AVG_egg_turns_weighted1 <- (eggTurn1 * 668 + eggTurn2 * 75) / (668 + 75)
GD1$AVG_turns_hour[7] <- 0.109

eggTemp1 <- 41.98
eggTemp2 <- 37.50
AVG_egg_Temp_weighted1 <- (eggTemp1 * 668 + eggTemp2 * 75) / (668 + 75)
GD1$AVG_Temp_egg_Hour[7] <- 41.527
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 0.052
Euler_night1 <- 0.041
Euler_day2 <- 0.741
Euler_night2 <- 0.277
Day_turn_weighted <- (Euler_day1 * 668 + Euler_day2 * 75) / (668 + 75)
Night_turn_weighted <- (Euler_night1 * 668 + Euler_night2 * 75) / (668 + 75)
GD1$Day_turns[7]<- 0.121
GD1$Night_turns[7]<- 0.064

# K22
eggTurn1 <- 771/567
eggTurn2 <- 103/85
AVG_egg_turns_weighted1 <- (eggTurn1 * 567 + eggTurn2 * 85) / (567 + 85)
GD1$AVG_turns_hour[6] <- 1.340

eggTemp1 <- 39.865
eggTemp2 <- 41.526
AVG_egg_Temp_weighted1 <- (eggTemp1 * 567 + eggTemp2 * 85) / (567 + 85)
GD1$AVG_Temp_egg_Hour[6] <- 40.081
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 1.410
Euler_night1 <- 1.215
Euler_day2 <- 1.440
Euler_night2 <- 0.625
Day_turn_weighted <- (Euler_day1 * 567 + Euler_day2 * 85) / (567 + 85)
Night_turn_weighted <- (Euler_night1 * 567 + Euler_night2 * 85) / (567 + 85)
GD1$Day_turns[6]<- 1.413
GD1$Night_turns[6]<- 1.138

# K23
eggTurn1 <- 49/80
eggTurn2 <- 50/78
AVG_egg_turns_weighted1 <- (eggTurn1 * 80 + eggTurn2 * 78) / (80 + 78)
GD1$AVG_turns_hour[17] <- 0.626

eggTemp1 <- 40.911
eggTemp2 <- 40.974
AVG_egg_Temp_weighted1 <- (eggTemp1 * 80 + eggTemp2 * 78) / (80 + 78)
GD1$AVG_Temp_egg_Hour[17] <- 40.942
#AND NIGHT AND DAY TURNS 
Euler_day1 <- 0.716
Euler_night1 <- 0.265
Euler_day2 <- 0.726
Euler_night2 <- 0.333
Day_turn_weighted <- (Euler_day1 * 80 + Euler_day2 * 78) / (80 + 78)
Night_turn_weighted <- (Euler_night1 * 80 + Euler_night2 * 78) / (80 + 78)
GD1$Day_turns[17]<- 0.720
GD1$Night_turns[17]<- 0.298

## Species data summary
class(GD1$`AVG.Delta.Tem/hr(Out-Egg)`)
GD1$`AVG.Delta.Tem/hr(Out-Egg)` <- as.numeric(GD1$`AVG.Delta.Tem/hr(Out-Egg)`)

mean(ED1$AVG_turns_hour, na.rm=TRUE)
range(GD1$AVG_Angular, na.rm=TRUE)
sd(GD1$AVG_Temp_egg_Hour, na.rm=TRUE)/sqrt(sum(GD1$AVG_Temp_egg_Hour, na.rm=TRUE))
#
sum(!is.na(GD1$PFOS))
mean(GD1$PFOS, na.rm=TRUE)
sd(GD1$PFOS, na.rm=TRUE)/sqrt(sum(GD1$PFOS, na.rm=TRUE))
# 
sum(!is.na(GD1$T4))
mean(GD1$T4, na.rm=TRUE)
sd(GD1$T4, na.rm=TRUE)/sqrt(sum(GD1$T4, na.rm=TRUE))
# ----Q1) Goldeneye vs. eider turning rates ----
#1) Havnig similar column names for the compared variables in both datasets 
#ED2<- ED2 %>%
 #rename(`Wing`= `Wing (R-U)`)
#1.2) Identifying outliers
identify_outliers_iqr <- function(data, column) {
  Q1 <- quantile(data[[column]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column]], 0.75, na.rm = TRUE)
  IQR_value <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR_value
  upper_bound <- Q3 + 1.5 * IQR_value
  
  # Return a logical vector where TRUE indicates an outlier
  data[[column]] < lower_bound | data[[column]] > upper_bound
}

outliers_GD2 <- identify_outliers_iqr(GD2,"BodyCondition")
outliers_GD2
outliers_GD1 <- identify_outliers_iqr(GD1, "AVG_turns_hour")
outliers_GD1

#
#1.3) Decision to keep or remove outliers 
#GD1_clean <- GD1[!outliers_GD1, ]
#Deciding to omit one outlers from Eiders 
#ED1_clean <- ED1[!outliers_ED1, ]
#ED2_clean <- ED2[!ED2$FemaleID=="79065",]

# Cases where CORT_Base was higher than CORT_Stress. Replacing the CORT_Base with NA and putting its value for CORT_Stress
#ED1_clean$CORT_Base [ED1_clean$FemaleID=="DT081304"] <- 11.16
#ED2_clean$CORT_Stress[ED2_clean$FemaleID=="DT081816"] <- NA
# If CORT-Stress was taking before 10 mins after capture, removing that value and repacing with NA
#ED2_clean$CORT_Stress [ED2_clean$FemaleID=="DTX22959"] <- NA

#1.4) Across-species comparison
# First, across incubation stages in common eider
table(ED1$Incubation_stage)
  
sum(!is.na(ED1$AVG_Temp_out_Hour))
ED1$AVG_Temp_out_Hour
Shapiro <- shapiro.test(ED1$AVG_Temp_out_Hour[ED1$Incubation_stage == "Early.breeder"])
Shapiro
Shapiro <- shapiro.test(ED1$AVG_Temp_out_Hour[ED1$Incubation_stage == "Late.breeder"])
Shapiro
Shapiro <- shapiro.test(ED1$AVG_Temp_out_Hour[ED1$Incubation_stage == "Peak.incubation"])
Shapiro
#Homogenity of variance 
bartlett.test(AVG_Temp_egg_Hour ~ Incubation_stage, data = ED1)
# With linear regression 
ED1$Incubation_stage <- as.factor(ED1$Incubation_stage)
ED1$Incubation_stage <- relevel(ED1$Incubation_stage, ref = "Peak.incubation")
Lm_eider_stage <- lm(AVG_Temp_out_Hour~ Incubation_stage, data=ED1)
summary(Lm_eider_stage)
anova(Lm_eider_stage)
pairs(emmeans(Lm_eider_stage, ~ Incubation_stage), adjust="tukey")


# 
kruskal.test(Overal_angularChange_mean ~ Incubation_stage, data = ED1)

#Plotting 
ggplot(ED1, aes(x = Incubation_stage, y = AVG_turns_hour)) +
  geom_boxplot() +
  geom_jitter(width = 0.2) +
  theme( 
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.9, 0.9),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  guides(color = guide_legend(title = "Time"), fill = FALSE)+
  labs(
    x = "Incubation Stage",
    y = "Average Egg Turning Frequency (Overall/Hour)")
#Eider hatching success across breeding period 
#EDHatch <- betareg(HatchingSuccess_adj ~ Incubation_stage, data = ED1)
#emmeans(EDHatch, ~ Incubation_stage)
#pairs(emmeans(EDHatch, ~ Incubation_stage))
#2) Average turning rate
# Normality testing 

Shapiro <- shapiro.test(GD1$AVG_turns_hour)
Shapiro
Shapiro <- shapiro.test(ED1$AVG_turns_hour)
Shapiro

#Histogram 
hist(ED1$AVG_Temp_egg_Hour)
hist(GD1$AVG_Temp_egg_Hour)
#qq plot
qqnorm(ED1$AVG_Temp_egg_Hour)
qqline(ED1$AVG_Temp_egg_Hour)
qqnorm(GD1$AVG_Temp_egg_Hour)
qqline(GD1$AVG_Temp_egg_Hour)

#2.5) Average turning rate 
mean(GD1$AVG_turns_hour)
mean(ED1$AVG_turns_hour)
#2.5.1) Average hourly turns
var.test(GD1$AVG_turns_hour, ED1$AVG_turns_hour)

T_test <- t.test(na.omit(GD1$AVG_turns_hour), na.omit(ED1$AVG_turns_hour), var.equal = FALSE)
T_test
# Plot 

boxplot(GD1$AVG_turns_hour,ED1$AVG_turns_hour,
        names=c("Goldeneye", "Eider"),
        main=NA, 
        ylab= "Average Egg Turning Frequency (Overall/Hour)",
        col=c("gold", "cornflowerblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE)
jitter <- 0.2
points(jitter(rep(1,length(GD1$AVG_turns_hour)), amount = jitter), GD1$AVG_turns_hour, pch=16, col="black", cex=0.8)
points(jitter(rep(2,length(ED1$AVG_turns_hour)), amount = jitter), ED1$AVG_turns_hour, pch=16, col="black", cex=0.8)

#2.5.1.2) Average daily turns 
Shapiro <- shapiro.test(GD1Daily$Daily_avg_turn)
Shapiro
Shapiro <- shapiro.test(ED1Daily$Daily_avg_turn)
Shapiro

mean(GD1Daily$Daily_avg_turn)
mean(ED1Daily$Daily_avg_turn)
var.test(GD1Daily$Daily_avg_turn, ED1Daily$Daily_avg_turn)

T_test <- t.test(na.omit(GD1Daily$Daily_avg_turn), na.omit(ED1Daily$Daily_avg_turn), var.equal = FALSE)
T_test

#2.5.2) Average turning rate during day/night hours 
#GD_Clean <- na.omit(GD1$`Day/Hr egg turning` & GD1$`Night/Hr egg turning`)
Shapiro <- shapiro.test(GD1$Day_turns)
Shapiro
Shapiro <- shapiro.test(GD1$Night_turns)
Shapiro
var.test(GD1$Night_turns, GD1$Day_turns)

T_test <- t.test(GD1$Night_turns, GD1$Day_turns, paired= TRUE)
T_test

#Plot
boxplot(ED1$Day_turns,ED1$Night_turns,
        names=c("Day (4:00-22:00)", "Night (22:00-4:00)"),
        main=NA, 
        ylab= "Average Egg Turning Frequency (Overall/Hour)",
        col=c("cornflowerblue", "powderblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE,
        ylim = c(min(ED1$Day_turns, ED1$Night_turns) - 0.1, 
                 max(ED1$Day_turns, ED1$Night_turns) + 0.3),
          cex.axis=1,
        cex.lab=1) # More space

jitter <- 0.2
points(jitter(rep(1,length(ED1$Day_turns)), amount = jitter), ED1$Day_turns, pch=16, cex=0.5, col="black")
points(jitter(rep(2,length(ED1$Night_turns)), amount = jitter), ED1$Night_turns, pch=16,cex=0.5, col="black")
#Adding significany sign
text(x = 2, y = max(ED1$Day_turns, ED1$Night_turns) + 0.1, labels = "***", cex=2)
text(x=0.6, y= max(ED1$Day_turns, ED1$Night_turns) + 0.2, labels= "(B)", front=2, cex=1.8)

#2.5.3) Average egg temperature 
GD1 <- GD1%>%
  rename(AVG_Temp_out_Day = `AVG.Temp.out (Day)`,
          DeltaTemp_eggOut=`AVG.Delta.Tem/hr(Out-Egg)`)
ED1 <- ED1%>%
  rename(AVG_Temp_out_Day = `AVG.Temp.out (Day)`,
          DeltaTemp_eggOut=`Delta.avgTem/hr(Out-Egg)`)

GD1$DeltaTemp_eggOut <- as.numeric(GD1$DeltaTemp_eggOut)  
ED1$DeltaTemp_eggOut <- as.numeric(ED1$DeltaTemp_eggOut) 

Shapiro <- shapiro.test(GD1$DeltaTemp_eggOut)
Shapiro
var.test(GD1$AVG_Temp_out_Hour, ED1$AVG_Temp_out_Hour)
mean(GD1$AVG_Temp_out_Hour)
mean(ED1$AVG_Temp_out_Hour, na.rm=TRUE)
var.test(GD1$DeltaTemp_eggOut, ED1$DeltaTemp_eggOut)
mean(GD1$AVG_Temp_egg_Hour)
mean(ED1$AVG_Temp_egg_Hour)
var.test(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour)
#GD1_clean <- length(na.omit(GD1$`AVG.Temp.egg (Hour)`))
#ED1_clean <- length(na.omit(ED1$`AVG.Temp.egg (Hour)`))

T_test <- t.test(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour, var.equal = TRUE)
T_test
sum(!is.na(GD1$AVG_Temp_out_Hour))

wilcox.test(GD1$AVG_Temp_out_Hour, ED1$AVG_Temp_out_Hour, exact = FALSE)
wilcox.test(GD1$AVG_Temp_out_Day, ED1$AVG_Temp_out_Day, exact=FALSE)
t.test(ED1$DeltaTemp_eggOut, GD1$DeltaTemp_eggOut, var.equal = TRUE)

#Plot
boxplot(GD1$AVG_Temp_egg_Hour,ED1$AVG_Temp_egg_Hour,
        names=c("Goldeneye", "Eider"),
        main=NA, 
        ylab= "Average egg temperature (Overall/Hour)",
        col=c("gold", "cornflowerblue"),
        border="black",
        notch = FALSE,
        varwidth = TRUE,
        frame.plot=FALSE,
        outline=TRUE,
        axes=TRUE,
cex.axis=1,
cex.lab=1)
jitter <- 0.2
points(jitter(rep(1,length(GD1$AVG_Temp_egg_Hour)), amount = jitter), GD1$AVG_Temp_egg_Hour, pch=16, cex=0.5, col="black")
points(jitter(rep(2,length(ED1$AVG_Temp_egg_Hour)), amount = jitter), ED1$AVG_Temp_egg_Hour, pch=16, cex=0.5, col="black")
text(x = 1, y = max(GD1$AVG_Temp_egg_Hour, ED1$AVG_Temp_egg_Hour) + 0.3, labels = "*", cex=2)


# ----Q2) Turning rate in relation to incubation day----
# ------In goldeneyes------ 

#There are zero's in GD2. I make a subset with only above zero values. 
GD2Final <- subset(GD2, turns_per_day > 0)
#Assumptions testing for family selection 
var_turns <- var(GD2Final$turns_per_day)
mean_turns <- mean(GD2Final$turns_per_day)
dispersion <- var_turns/mean_turns
shapiro.test(GD2Final$turns_per_day)
## Thus, we choose negative binomial
#length(na.omit(GD2$turns_per_day))
#length(na.omit(GD2$Fullday.Incubation))
#length(na.omit(GD2$ClutchSize))
#length(na.omit(GD2$BodyCondition))
#GD2_new <- subset(GD2, turns_per_day >=1)
#shift_constant <- 1.75 + 0.01  
#GD2$BodyCondition_shifted <- GD2$BodyCondition + 1.76
#Full GD2 dataset, removing all NA values of variables in the model
### Checking correlations 
#GD2Final$AVG.EggTem.Per.IncDay <- as.numeric(GD2Final$AVG.EggTem.Per.IncDay)
COR <- GD2Final[, c("Fullday.Incubation","ClutchSize", "BodyCondition","AVG.EggTem.Per.IncDay")] 
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#If I want a correlation table 
cor_results <- rcorr(as.matrix(COR), type = "spearman")
correlation_matrix <- cor_results$r
p_values <- cor_results$P

ggcorrplot(correlation_matrix, 
           type = "lower", 
           lab = TRUE, 
           p.mat = p_values, 
           insig = "blank",  # Hide non-significant correlations
           colors = c("#6D9EC1", "white", "#E46726"), 
           title = "Correlation Heatmap", 
           outline.col = "white") 
#OR

corrplot(correlation_matrix, method = "circle", 
         type = "lower", 
         col = colorRampPalette(c("red", "white", "blue"))(200), 
         tl.col = "black", tl.srt = 45, # Rotate labels
         addCoef.col = "black", # Add correlation values
         p.mat = p_values, sig.level = 0.05) 

png("correlation_heatmap.png", width = 1200, height = 1000, res = 300)
ggcorrplot(cor_matrix, type = "lower", lab = TRUE, p.mat = p_values, insig = "blank")

#
GD2FULL <- GD2Final[complete.cases(GD2Final[c("turns_per_day","Fullday.Incubation","ClutchSize","BodyCondition")]), ]

IncDay1 <- glmmTMB(turns_per_day~ scale(Fullday.Incubation) + scale(ClutchSize)+ scale(BodyCondition) +(1|FemaleID), family=nbinom2(),,ziformula = ~1, data=GD2FULL)
#OR
IncDay3 <- glmmTMB(turns_per_day~ Fullday.Incubation + ClutchSize + BodyCondition +AVG.EggTem.Per.IncDay+ (1|FemaleID), family=nbinom2(), data=GD2FULL)
#OR
IncDay4  <- glmmTMB(turns_per_day ~ poly(Fullday.Incubation,2) +(1|FemaleID),family=nbinom2(), data= GD2FULL)
#OR
IncDay5  <- glmmTMB(turns_per_day ~ poly(Fullday.Incubation,2) + (1|FemaleID), family=nbinom2(), ziformula=~1,data= GD2FULL)
#OR
IncDay6 <- glmmTMB(turns_per_day ~ scale(Fullday.Incubation) + (1 | FemaleID), family=nbinom2(),ziformula = ~1, data = GD2FULL)
summary(IncDay6)
#OR 
IncDay7 <- glmmTMB(turns_per_day ~ poly(Fullday.Incubation,2) + (1|FemaleID), ziformula = ~1, family = nbinom2(), data = GD2FULL)
#NULL
IncNULL <- glmmTMB(turns_per_day ~ 1+ (1|FemaleID), data= GD2FULL)
#Checking the model fit 
sim_res <- simulateResiduals(IncDay6)
plot(sim_res)
testDispersion(sim_res)
testZeroInflation(sim_res)
#overdisp <- sum(residuals(IncDay6, type="pearson")^2) / df.residual(IncDay6)
#print(overdisp)

#Checking responses, individually 
#plotResiduals(sim_res, GD2$Fullday.Incubation)
#plotResiduals(sim_res, GD2$ClutchSize)
#plotResiduals(sim_res, GD2$BodyCondition)
#Akaike's Information Criterion check 
AIC(IncDay1,IncDay2,IncDay3, IncDay4, IncDay5,IncDay6,IncDay7)
#Bayesian Information Criterion check 
BIC(IncDay1,IncDay2,IncDay3, IncDay4, IncDay5,IncDay6,IncDay7,IncNULL)
#Anova check for the added variables 
anova(IncDay1, IncDay2, IncDay3, IncDay4, IncDay5, IncDay6, IncDay7, IncNULL)

#Selected model
#GD2FULL <- GD2Final[complete.cases(GD2Final[c("turns_per_day","Fullday.Incubation")]), ]
IncDay6 <- glmmTMB(turns_per_day ~ scale(Fullday.Incubation) + (1| FemaleID),family=poisson(), data = GD2Final)
summary(IncDay6)

IncNULL <- glmmTMB(turns_per_day ~ 1+ (1|FemaleID),family=poisson(), data= GD2Final)
AIC(IncDay6, IncNULL)
#CheckinIncDay6#Checking collinearity 
check_collinearity(IncDay6)

###Checking the change in angular change over incubation period####
GD2Final <- GD2Final%>%
  rename(AVG_angular_IncDay=AVG.AngularChange.ofAll.Turns.per.incubationDay
  )
GD2Final$AVG_angular_IncDay <- as.numeric(GD2Final$AVG_angular_IncDay)
var_turns <- var(GD2Final$AVG_angular_IncDay)
mean_turns <- mean(GD2Final$AVG_angular_IncDay)
dispersion <- var_turns/mean_turns
shapiro.test(GD2Final$AVG_angular_IncDay)
#
IncANG<- glmmTMB(log(AVG_angular_IncDay)~ scale(Fullday.Incubation)+ (1| FemaleID), family=gaussian(), data = GD2Final)
summary(IncANG)

sim_res <- simulateResiduals(IncANG)
plot(sim_res)

IncANG_NULL <- glmmTMB(log(AVG_angular_IncDay)~ 1+(1|FemaleID), family=gaussian, data=GD2Final)
AIC(IncANG_NULL, IncANG)
#Scaling the variables 
#GD2FULL$Fullday.Incubation_scaled<- scale(GD2FULL$Fullday.Incubation) 
#GD2FULL$BodyCondition_scaled<- scale(GD2FULL$BodyCondition) 
#GD2FULL$ClutchSize_scaled<- scale(GD2FULL$ClutchSize) 
#GD2FULL$AVG.EggTem.Per.IncDay_scaled<- scale(GD2FULL$AVG.EggTem.Per.IncDay)
#Solving the negative values of scaled variables by adjusting them 
#GD2FULL$Fullday.Incubation_scaled_shifted <- scale(GD2FULL$Fullday.Incubation) + abs(min(scale(GD2FULL$Fullday.Incubation), na.rm = TRUE)) + 1
#GD2FULL$BodyCondition_scaled_shifted <- scale(GD2FULL$BodyCondition) + abs(min(scale(GD2FULL$BodyCondition), na.rm = TRUE)) + 1
#GD2FULL$ClutchSize_scaled_shifted <- scale(GD2FULL$ClutchSize) + abs(min(scale(GD2FULL$ClutchSize), na.rm = TRUE)) + 1
#GD2FULL$AVG.EggTem.Per.IncDay_scaled_shifted <- scale(GD2FULL$AVG.EggTem.Per.IncDay) + abs(min(scale(GD2FULL$AVG.EggTem.Per.IncDay), na.rm = TRUE)) + 1

#IncDay6  <- glmmTMB(turns_per_day ~ sqrt(Fullday.Incubation_scaled_shifted) + sqrt(ClutchSize_scaled_shifted)+ (1|FemaleID), family=nbinom2(), data= GD2FULL)
#summary(IncDay6) 

#Plotting 
#Model
predictions <- ggpredict(IncDay6, terms = "Fullday.Incubation [all]")

# Plot the effects
ggplot(predictions, aes(x = x, y = predicted)) +
  geom_line(color = "#B8800B", size = 1) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2, fill = "#B8800B") +
  geom_point(data = GD2FULL, aes(x = Fullday.Incubation, 
                                 y = turns_per_day), 
             size = 3, color = "#B8800B", alpha = 0.3)+
  labs(
    title = "",
    x = "Complete incubaiton day",
    y = "Predicted Turns per Day"
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))+
      scale_x_continuous(breaks=unique(GD2Final$Fullday.Incubation))

#Raw data
ggplot(GD2Final, aes(x= Fullday.Incubation, y=turns_per_day, color=FemaleID)) + 
  geom_point(alpha=0.6, stroke=1.5)+
  geom_smooth(method="lm", se=TRUE, color="black")+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="Incubation day", y= "Turning frequency")+
  scale_x_continuous(breaks=unique(ED2$Fullday.Incubation))

# -------In Eiders------ 
#Correlations 
COR <- ED2[, c("Fullday.Incubation", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
print(correlation_matrix)

#Assumptions testing 
var_turns <- var(ED2$turns_per_day)
mean_turns <- mean(ED2$turns_per_day)
dispersion <- var_turns/mean_turns
shapiro.test(ED2$turns_per_day)

length(na.omit(ED2$turns_per_day))
length(na.omit(ED2$Fullday.Incubation))
length(na.omit(ED2$ClutchSize))
length(na.omit(ED2$BodyCondition))
# Since there are missing values, I run the model also with the subset of data to make sure the output is the same:
ED2FULL <- ED2[complete.cases(ED2[c("turns_per_day", "Fullday.Incubation", "ClutchSize", "BodyCondition")]), ]

#Models 
IncDay1 <- glmmTMB(turns_per_day~ scale(Fullday.Incubation) + scale(ClutchSize) + scale(BodyCondition)+ (1|FemaleID), family=nbinom1(), data=ED2FULL)
#OR
IncDay2 <- glmmTMB(turns_per_day~ scale(Fullday.Incubation) + poly(ClutchSize,2) + scale(BodyCondition)+ (1|FemaleID), family=nbinom1(), data=ED2FULL)
#OR
IncDay3 <- glmmTMB(turns_per_day ~ scale(Fullday.Incubation) + (1|FemaleID), family=nbinom1(), data=ED2FULL)

IncDay4 <- glmmTMB(turns_per_day ~ poly(Fullday.Incubation,2) + (1|FemaleID), family=nbinom1(), data=ED2FULL)

IncDay5 <- glmmTMB(turns_per_day ~ scale(Fullday.Incubation,2) * scale(ClutchSize)+ (1|FemaleID), family=poisson(), data=ED2FULL)

#NULL
IncNULL <- glmmTMB(turns_per_day ~ 1 + (1|FemaleID), family=nbinom2(), data=ED2FULL)

#Checking the model fit 
sim_res <- simulateResiduals(IncDay3)
plot(sim_res)

overdisp <- sum(residuals(IncDay3, type="pearson")^2) / df.residual(IncDay3)
print(overdisp)

AIC(IncDay1,IncDay2,IncDay3,IncDay4, IncDay5, IncNULL)
#Bayesian Information Criterion check 
BIC(IncDay1,IncDay2,IncDay3, IncNULL)

#Selected model
#ED2FULL <- ED2[complete.cases(ED2[c("turns_per_day", "Fullday.Incubation")]), ]
IncDay3 <- glmmTMB(turns_per_day ~ scale(Fullday.Incubation) + (1|FemaleID), family=nbinom1(), data=ED2)
summary(IncDay3)
IncNULL <- glmmTMB(turns_per_day ~ 1 + (1|FemaleID), family=nbinom1(), data=ED2)
#Predictors importance )#Predictors importance )ED2FULL
#anova(IncDay3, IncNULL)
AIC(IncDay3, IncNULL)
#Plotting 
ggplot(ED2, aes(x= Fullday.Incubation, y=turns_per_day, color=FemaleID)) + 
  geom_point(alpha=0.6, stroke=1.5)+
  geom_smooth(method="lm", se=TRUE, color="black")+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="Incubation day", y= "Turning frequency")+
  scale_x_continuous(breaks=unique(ED2$Fullday.Incubation))

###Checking the change in angular change over incubation period####
ED2 <- ED2%>%
  rename(AVG_angular_IncDay=AVG.angularchnage.FullDay)

ED2$AVG_angular_IncDay <- as.numeric(ED2$AVG_angular_IncDay)
var_turns <- var(ED2$AVG_angular_IncDay)
mean_turns <- mean(ED2$AVG_angular_IncDay)
dispersion <- var_turns/mean_turns
shapiro.test(ED2$AVG_angular_IncDay)
#
IncANG<- glmmTMB(log(AVG_angular_IncDay)~ scale(Fullday.Incubation)+(1| FemaleID), family=gaussian, data = ED2)
summary(IncANG)

sim_res <- simulateResiduals(IncANG)
plot(sim_res)

IncANG_NULL <- glmmTMB(log(AVG_angular_IncDay)~ 1+(1|FemaleID), family=gaussian, data=ED2)
AIC(IncANG_NULL, IncANG)

# ---- Q3) Turning rate in relation to thyroid and PFAS + egg temperature----
# ------For GD------
#class(GD1$RecordedDays)
GD1$RecordedDays <- as.numeric(GD1$RecordedDays)

COR <- GD1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour","AVG_Temp_out_Hour", "RecordedDays")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# For Goldeneye
# Normality testing for distribution selection  
Shapiro <- shapiro.test(GD1$AVG_turns_hour)
Shapiro
var_turns <- var(GD1$AVG_turns_hour)
mean_turns <- mean(GD1$AVG_turns_hour)
dispersion <- var_turns/mean_turns

## 
GDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_egg_Hour)+ scale(ClutchSize)+ scale(RecordedDays), data=GD1)
GDTurn2 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+ scale(AVG_Temp_egg_Hour)+ scale(ClutchSize)+ scale(RecordedDays), data=GD1)
GDTurn3 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3)+ scale(AVG_Temp_egg_Hour)+ scale(AVG_Temp_out_Hour)+ scale(ClutchSize)+ scale(BodyCondition)+ scale(RecordedDays), data=GD1)
GDTurn4 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3_T4)+ scale(AVG_Temp_egg_Hour)+ scale(AVG_Temp_out_Hour)+ scale(ClutchSize)+ scale(BodyCondition)+ scale(RecordedDays) ,data=GD1)
GDTurn5<- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T4)+ scale(AVG_Temp_egg_Hour)+ scale(ClutchSize)+ scale(BodyCondition) + scale(RecordedDays),data=GD1)
GDTurn6 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3_T4)+ scale(AVG_Temp_egg_Hour)+ scale(ClutchSize)+ scale(RecordedDays) , data=GD1)
GDTurn7 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_egg_Hour)+ scale(AVG_Temp_out_Hour)+scale(ClutchSize)+ scale(BodyCondition)+scale(RecordedDays) , data=GD1)
GDTurn8 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+ scale(AVG_Temp_egg_Hour)+ scale(ClutchSize)+ scale(RecordedDays) ,data=GD1)

#Checking the model fit 
par(mfrow = c(2, 2))  
plot(GDTurn1)  
shapiro.test(residuals(GDTurn1))
hist(residuals(GDTurn1), breaks = 20, main = "Histogram of Residuals")
#Checking multicolinearity
vif(GDTurn1)
#Model comparison
nobs(GDTurn1) # Making sure all models are running on the same number of observation
AIC(GDTurn1,GDTurn2,GDTurn3, GDTurn4, GDTurn5,GDTurn6,GDTurn7,GDTurn8)

#Shortlisting models: GDTrun1 and GDTurn7
stepwise_model <- stepAIC(GDTurn7, direction = "backward", trace = TRUE)

GDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_egg_Hour)+ scale(ClutchSize), data=GD1)
GDTurn7 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+ scale(BodyCondition) , data=GD1)
#Comparing with the null model 
GD1FULL <- GD1[complete.cases(GD1[c("AVG_turns_hour", "PFAS_SUM", "T3_T4", "AVG_Temp_egg_Hour","BodyCondition")]), ]

GDTurnNULL <- lm(AVG_turns_hour~ 1,data=GD1FULL)

AIC(GDTurn1,GDTurn7)
AIC(GDTurn1,GDTurnNULL)
nobs(GDTurn1) 

#Model output:
GD1FULL <- GD1[complete.cases(GD1[c("AVG_turns_hour", "PFAS_SUM", "T3", "AVG_Temp_egg_Hour","BodyCondition")]), ]
#GDTurn1<- lm(BodyCondition~ scale(PFUnA), data=ED1)

GDTurn1<- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_egg_Hour)+scale(BodyCondition), data=GD1)
#OR
#GDTurn11 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(AVG_Temp_egg_Hour)+scale(BodyCondition), data=GD1)
#OR
#GDTurn11 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_egg_Hour)+ scale(ClutchSize), data=GD1)
#OR
#GDTurn111 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(ClutchSize)+scale(AVG_Temp_egg_Hour), data=GD1)
summary(GDTurn1)
nobs(GDTurn1)
anova(GDTurn1, GDTurnNULL, test = "Chisq")

#Checking for influencial points 
library(car)
influencePlot(GDTurnPFAS)  # Plots influence, labels extreme cases

cooksd <- cooks.distance(GDTurnPFAS)
which(cooksd > 1)  # Identifies highly influential points
#IF needed! Re-running the model with the subset, excluding the influential points: 
#GD1_sub<- GD1[-2, ]  # Removes the second row

###With angular changes ####
GD1 <- GD1%>%
  rename(AVG_Angular=Overal_angularChange_mean)
GDAng1 <- lm(AVG_Angular~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_egg_Hour)+scale(BodyCondition), data=GD1)
summary(GDAng1)
nobs(GDAng1)
##Without egg temperature 
GDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+ scale(ClutchSize)+scale(BodyCondition)+ scale(RecordedDays)+scale(AVG_Temp_out_Hour), data=GD1)
stepAIC(GDTurn1)
GD1FULL <- GD1[complete.cases(GD1[c("AVG_turns_hour","T3_T4", "PFAS_SUM", "BodyCondition")]), ]

GDTurnNoTemp1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3)+scale(ClutchSize), data=GD1)
#OR
GDTurnNoTemp2 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+ scale(ClutchSize), data=GD1)
#OR
GDTurnNoTemp3 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+ scale(BodyCondition), data=GD1)

summary(GDTurnNoTemp3) 
GDTurnNULL <- lm(AVG_turns_hour~ 1,data=GD1FULL)
AIC(GDTurnNoTemp3, GDTurnNULL)
anova(GDTurnNoTemp)
nobs(GDTurnNoTemp3)
confint(GDTurnNoTemp)

#Checking the model fit 
par(mfrow = c(2, 2))  
plot(GDTurnNoTemp1)  
shapiro.test(residuals(GDTurnNoTemp1))
hist(residuals(GDTurn1), breaks = 20, main = "Histogram of Residuals")
#Checking multicolinearity
vif(GDTurnNoTemp1)

#Comparing whethere with or without temperature model gives a better fit: 
AIC(GDTurnNoTemp1, GDTurn1)


# Checking the effect of each PFAS, separately
COR <- GD1[, c("AVG_turns_hour","PFUnA", "T4", "AVG_Temp_egg_Hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GD1FULL <- GD1[complete.cases(GD1[c("AVG_turns_hour","T4", "PFDoDA", "AVG_Temp_egg_Hour")]), ]

GDTurnPFUnA <- lm(AVG_turns_hour~ scale(PFUnA)*scale(T3_T4)+scale(AVG_Temp_egg_Hour), data=GD1)
GDTurnPFDoDA <- lm(AVG_turns_hour~ scale(PFDoDA)*scale(T3_T4)+scale(AVG_Temp_egg_Hour), data=GD1)
GDTurnPFNA <- lm(AVG_turns_hour~ scale(PFNA)*scale(T3_T4)+scale(AVG_Temp_egg_Hour), data=GD1)
GDTurnPFOS <- lm(AVG_turns_hour~ scale(PFOS)*scale(T4)+ scale(AVG_Temp_out_Hour), data=GD1)
summary(GDTurnPFOS)
#cooksd <- cooks.distance(GDTurnPFAS)
#which(cooksd > 1)  # Identifies highly influential points
#IF needed! Re-running the model with the subset, excluding the influential points: 
#GD1_sub<- GD1[-c(12,15), ]  # Removes these rows
AIC(GDTurnPFAS,GDTurnPFAS2)
summary(GDTurnPFNA)
par(mfrow = c(2, 2))  
plot(GDTurnPFAS)  
shapiro.test(residuals(GDTurnPFAS))
hist(residuals(GDTurnPFAS), breaks = 20, main = "Histogram of Residuals")
vif(GDTurnPFAS)

GDTurnNULL <- lm(AVG_turns_hour~ 1, data=GD1FULL)
AIC(GDTurnNULL, GDTurnPFAS)
sum(!is.na(GD1$PFUnA))
nobs(GDTurnPFAS)

#Plotting#
#Plotting: Average egg turning vs. PFAS

new_data <- data.frame(
  PFAS_SUM = seq(min(GD1$PFAS_SUM, na.rm = TRUE), 
                 max(GD1$PFAS_SUM, na.rm = TRUE), 
                 length.out = 100),
  # Setting other variables to their mean to isolate PFAS effect
  T3_T4 = mean(GD1$T3_T4, na.rm = TRUE),
  AVG_Temp_egg_Hour = mean(GD1$AVG_Temp_egg_Hour, na.rm = TRUE),
  BodyCondition = mean(GD1$BodyCondition, na.rm = TRUE)
)
#new_data$Predicted <- predict(GDTurn9, newdata = new_data, type = "response")
predictions <- predict(GDTurn1, newdata = new_data, type = "response", se.fit = TRUE)
new_data$Predicted <- predictions$fit
new_data$SE <- predictions$se.fit

new_data <- new_data %>%
  mutate(Lower = Predicted - 1.96 * SE,  
         Upper = Predicted + 1.96 * SE) 

ggplot(new_data, aes(x = PFAS_SUM, y = Predicted)) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "#B8800B", alpha = 0.3) +
  geom_point(data = GD1, aes(x = PFAS_SUM, 
                                 y = AVG_turns_hour), 
             size = 3, color = "#B8923B", alpha = 0.5)+
               theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title = "", x = "∑PFAS", y = "Predicted average turning frequency (Overall/Hour)")


#Average egg temperature vs. Average frequency rate 
new_data3 <- data.frame(
  PFAS_SUM = mean(GD1$PFAS_SUM, na.rm = TRUE),
  T4 = mean(GD1$T4, na.rm=TRUE),
  T3 = mean(GD1$T3, na.rm = TRUE),
  AVG_Temp_egg_Hour = seq(min(GD1$AVG_Temp_egg_Hour, na.rm=TRUE),
                          max(GD1$AVG_Temp_egg_Hour, na.rm = TRUE),
                              length.out=100),
  ClutchSize = mean(GD1$ClutchSize, na.rm = TRUE),
  RecordedDays = mean(GD1$RecordedDays, na.rm=TRUE)
)

new_data_predict <- predict(GDTurn1, newdata = new_data3, type = "response", se.fit = TRUE)

new_data_temp <- new_data3 %>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data_temp, aes(x = AVG_Temp_egg_Hour, y = Predicted)) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "#B8800B", alpha = 0.3) +
  geom_point(data = GD1, aes(x =  AVG_Temp_egg_Hour, 
                                 y = AVG_turns_hour), 
             size = 3, color = "#B8923B", alpha = 0.5)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="Average egg temperature (Overall/Hour)", y= "Predicted average turning frequency (Overall/Hour)")

#T3_T4 vs. Average frequency rate 
new_data <- data.frame(
  T3_T4 = seq(min(GD1$T3_T4, na.rm = TRUE), 
                 max(GD1$T3_T4, na.rm = TRUE), 
                 length.out = 100),
  PFAS_SUM = mean(GD1$PFAS_SUM, na.rm = TRUE),
  AVG_Temp_egg_Hour = mean(GD1$AVG_Temp_egg_Hour, na.rm = TRUE),
  BodyCondition = mean(GD1$BodyCondition, na.rm = TRUE)
)
#new_data$Predicted <- predict(GDTurn9, newdata = new_data, type = "response")
predictions <- predict(GDTurn1, newdata = new_data, type = "response", se.fit = TRUE)
new_data$Predicted <- predictions$fit
new_data$SE <- predictions$se.fit

new_data <- new_data %>%
  mutate(Lower = Predicted - 1.96 * SE,  
         Upper = Predicted + 1.96 * SE) 

ggplot(new_data, aes(x = T3_T4, y = Predicted)) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "#B8800B", alpha = 0.3) +
  geom_point(data = GD1, aes(x = T3_T4, 
                             y = AVG_turns_hour), 
             size = 3, color = "#B8923B", alpha = 0.5)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title = "", x = "T3:T4 ratio", y = "Predicted average turning frequency (Overall/Hour)")

##All PFASs in relation with egg turning frequency 
#Marginal effects 
library(broom)
coefs <- bind_rows(
  tidy(GDTurnPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(GDTurnPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(GDTurnPFDoDA, conf.int = TRUE) %>% filter(term == "scale(PFDoDA)") %>% mutate(compound = "PFDoDA"),
  tidy(GDTurnPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFDoDA", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
  low = "skyblue1",
  high = "firebrick3",
  name = "Mean PFAS\nConcentration",
  breaks = c(1, 2, 3, 4),
  labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Egg Turning Rate (Overall/Hour)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "non")
#----PER day GD turning frequency----
#From daily dataset
#GD2 <- GD2%>%
 # rename(AVG_Temp_day=AVG.AmbientTem.Per.IncDay,
  #       T3= `T3 (pg.ul)`, 
   #      T4= `T4 (pg.ul)`,
  #)
#GD2Final <- subset(GD2, turns_per_day > 0)
#range(GD2Final$turns_per_day)
#GD2Final$AVG_Temp_day <- as.numeric(GD2Final$AVG_Temp_day)

#COR <- GD2Final[, c("T3_T4","PFAS", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_day","Fullday.Incubation")]
#correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# For Goldeneye
#Normality testing for distribution selection  
#Shapiro <- shapiro.test(GD2Final$turns_per_day)
#Shapiro
#mean(GD2Final$turns_per_day)
#var(GD2Final$turns_per_day)
##
#GDTurnPFULL <- GD2Final[complete.cases(GD2Final[c("PFAS", "T4", "T3","T3_T4", "AVG_Temp_day","ClutchSize","BodyCondition","Fullday.Incubation")]), ]
#shapiro.test(GD2Final$turns_per_day_log)
#GDTurnPFULL$turns_per_day_log <- log(GDTurnPFULL$turns_per_day+1)
#GDTurnPFULL$turns_per_day_sqrt <- sqrt(GDTurnPFULL$turns_per_day)

#GDTurnP1<- glmmTMB(turns_per_day_log  ~ poly(Fullday.Incubation,2) +scale(PFAS)+ scale(T3)+scale(T4)+ (1 | FemaleID), family=Gamma(link="log"), data = GDTurnPFULL)
#GDTurnP2 <- glmmTMB(turns_per_day_log~ scale(PFAS)*scale(T3)+scale(PFAS)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+ (1 | FemaleID), family=Gamma(link="log"), data=GDTurnPFULL )
#GDTurnP3 <- glmmTMB(turns_per_day_log~ scale(PFAS)*scale(T3_T4)+ scale(AVG_Temp_day)+ scale(ClutchSize)+ (1 | FemaleID), family=Gamma(link="log"), data=GDTurnPFULL)
#GDTurnP4 <- glmmTMB(turns_per_day_log~ scale(PFAS)+scale(T4)+scale(T3)+ scale(AVG_Temp_day)+ scale(ClutchSize)+ scale(BodyCondition)+ (1 | FemaleID), family=Gamma(link="log"), data=GDTurnPFULL )
#GDTurnP5<- glmmTMB(turns_per_day~ scale(Fullday.Incubation)+ scale(PFAS)+ scale(AVG_Temp_day)+ (1 | FemaleID), family=Gamma(link="log"), data=GDTurnPFULL )
#GDTurnP6 <- glmmTMB(turns_per_day~ scale(PFAS)+ (1 | FemaleID), ziformula = ~1, family=Gamma(link="log"), data=GDTurnPFULL )
#GDTurnP7 <- glmmTMB(turns_per_day_log~ scale(PFAS)+ (1 | FemaleID), family=Gamma(link="log"), data=GDTurnPFULL )
#GDTurnP8 <- glmmTMB(turns_per_day~ scale(PFAS)*scale(T3)+scale(PFAS)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+ scale(BodyCondition)+(1 | FemaleID), family=genpois(), data=GDTurnPFULL)
#GDTurnP9 <- glmmTMB(turns_per_day~ scale(PFAS)*scale(T3_T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+ scale(BodyCondition)+(1 | FemaleID), family=genpois(), data=GDTurnPFULL)
#GDTurnP10 <- glmmTMB(turns_per_day_log ~ scale(PFAS) + (1 | FemaleID),family=Gamma(link="log"), data = GDTurnPFULL)

#summary(GDTurnP1)

#GDTurnPNULL <- glmmTMB(turns_per_day~1+ (1 | FemaleID), family=nbinom2(), data=GDTurnPFULL)

#stepAIC(GDTurnP3)
#stepwise_model <- stepAIC(GDTurnP2, direction = "backward", trace = TRUE)
#summary(stepwise_model)

#GDTurnP2 <- glmmTMB(turns_per_day~ scale(PFAS)*scale(T3)+scale(PFAS)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+ scale(BodyCondition)+(1 | FemaleID), family=nbinom2(), data=GDTurnPFULL)

#Checking the model fit 
#sim_res <- simulateResiduals(GDTurnP10)
#plot(sim_res)
#Checking for multicollinearity 
#check_collinearity(GDTurnP)

#check_collinearity(GDTurnP3)
#nobs(GDTurnP1)
#AIC(GDTurnP1,GDTurnP2,GDTurnP3,GDTurnP4,GDTurnP5,GDTurnP6,GDTurnP7,GDTurnP8, GDTurnP9,GDTurnPNULL)

#From hourly dataset 
#1) Making a new dataset for the daily average rate 1) 
GD1Daily <- GD1
#
GD1Daily <- GD1Daily %>%
  rename(Total_record_hr= `Total record (Hour)`)
GD1Daily <- GD1Daily %>%
  rename(AVG_Temp_day= `AVG.Temp.egg (Day)`)
#class(GD1Daily$Total_record_hr)
GD1Daily$Total_record_hr <- as.numeric(GD1Daily$Total_record_hr)
GD1Daily$RecordedDays <- as.numeric(GD1Daily$RecordedDays)
GD1Daily$AVG_Temp_day <- as.numeric(GD1Daily$AVG_Temp_day)
# Only keeping days with at least 19 hours of record
GD1Daily$DecimalPart <- GD1Daily$RecordedDays - floor(GD1Daily$RecordedDays)
# Step 2: Apply the condition: Remove decimals if < 0.70
GD1Daily$AdjustedRecordedDays <- ifelse(GD1Daily$DecimalPart < 0.70, 
                                         floor(GD1Daily$RecordedDays), 
                                        GD1Daily$RecordedDays)
GD1Daily$newTotalHours <- GD1Daily$AdjustedRecordedDays*24

#Re-calculating the average hourly turn
GD1Daily$NewHourlyTurns <- GD1Daily$AVG_turns_hour * (GD1Daily$Total_record_hr / GD1Daily$newTotalHours)

#Getting the average daily turn
GD1Daily$Daily_avg_turn <- GD1Daily$NewHourlyTurns*24
GD1Daily$Daily_avg_turn <- round(GD1Daily$Daily_avg_turn, 3)

##Analyzing!
Shapiro <- shapiro.test(GD1Daily$Daily_avg_turn)
Shapiro
var_turns <- var(GD1Daily$Daily_avg_turn)
mean_turns <- mean(GD1Daily$Daily_avg_turn)
dispersion <- var_turns/mean_turns

## 
COR <- GD1Daily[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_day","Daily_avg_turn","AdjustedRecordedDays")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GDTurnFULL <- GD1Daily[complete.cases(GD1Daily[c("Daily_avg_turn","PFAS_SUM", "T4", "T3","T3_T4", "AVG_Temp_day","ClutchSize","BodyCondition", "AdjustedRecordedDays")]), ]

GDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3_T4)+scale(T3)+scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+scale(BodyCondition), data=GDTurnFULL)
GDTurn2 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize), data=GDTurnFULL)
GDTurn3 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+ scale(AdjustedRecordedDays) , data=GDTurnFULL)

#Shortlisting the best models 
stepwise_model <- stepAIC(GDTurn3, direction = "backward", trace = TRUE)

GDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_day)+ scale(BodyCondition), data=GDTurnFULL)
GDTurn2 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize), data=GDTurnFULL)
GDTurn3 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+ scale(AdjustedRecordedDays) , data=GDTurnFULL)

#Comparing with the null model 
GDTurnNULL <- lm(Daily_avg_turn~ 1,data=GD1Daily)

AIC(GDTurn1, GDTurnNULL)
anova(GDTurn1, GDTurnNULL, test = "Chisq")
#Residuals test
par(mfrow = c(2, 2))  
plot(GDTurn1)  
shapiro.test(residuals(GDTurn1))
hist(residuals(GDTurn1), breaks = 20, main = "Histogram of Residuals")
#Colinearity 
vif(GDTurn1)
#Model output
GDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_day)+ scale(BodyCondition), data=GD1Daily)
#OR
GDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(AVG_Temp_day), data=GD1Daily)
#OR
GDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)+scale(T3), data=GD1Daily)

summary(GDTurn1)
nobs(GDTurn1) 

# Checking the effect of each PFAS, separately
COR <- GD1Daily[, c("PFNA", "Daily_avg_turn")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GDTurnFULL <- GD1Daily[complete.cases(GD1Daily[c("Daily_avg_turn","PFDoDA","T3_T4", "AVG_Temp_day","BodyCondition")]), ]
GDTurnPFAS<- lm(Daily_avg_turn~ scale(PFDoDA)*scale(T3_T4)+scale(AVG_Temp_day)+ scale(BodyCondition), data=GDTurnFULL)
stepwise_model <- stepAIC(GDTurnPFAS, direction = "backward", trace = TRUE)
#
GDTurnPFAS<- lm(Daily_avg_turn~ scale(PFOS)+scale(T3_T4)+scale(AVG_Temp_day)+scale(BodyCondition), data=GDTurnFULL)
#Residuals test
par(mfrow = c(2, 2))  
plot(GDTurnPFAS)  
shapiro.test(residuals(GDTurnPFAS))
hist(residuals(GDTurnPFAS), breaks = 20, main = "Histogram of Residuals")
#Model output
GDTurnFULL <- GD1Daily[complete.cases(GD1Daily[c("Daily_avg_turn","PFUnA","T3_T4", "BodyCondition","AVG_Temp_day")]), ]
GDTurnPFAS<- lm(Daily_avg_turn~ scale(PFUnA)+scale(T3_T4)+scale(AVG_Temp_day)+scale(BodyCondition), data=GDTurnFULL)
#For PFDoDA
GDTurnPFAS<- lm(Daily_avg_turn~ scale(PFDoDA), data=GDTurnFULL)
#
summary(GDTurnPFAS)
GDTurnNULL <- lm(Daily_avg_turn~ 1,data=GDTurnFULL)
AIC(GDTurnPFAS,GDTurnNULL)
nobs(GDTurnPFAS)
Confint(GDTurnPFAS)
anova


# ------ For Eider ------

COR <- ED1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour","AVG_Temp_out_Hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# Normality testing for distribution selection  
Shapiro <- shapiro.test(ED1$AVG_turns_hour)
Shapiro
var_turns <- var(ED1$AVG_turns_hour)
mean_turns <- mean(ED1$AVG_turns_hour)
dispersion <- var_turns/mean_turns
##
# Since there are missing values, I run the model also with the subset of data to make sure the output is the same:
ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFAS_SUM", "T4", "T3","T3_T4", "AVG_Temp_egg_Hour","AVG_Temp_out_Hour","ClutchSize","BodyCondition" )]), ]

EDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_egg_Hour)+ scale(ClutchSize) ,data=ED1FULL)
EDTurn2 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+ scale(AVG_Temp_egg_Hour)+ scale(AVG_Temp_out_Hour)+ scale(ClutchSize)+ scale(BodyCondition) , data=ED1FULL)
EDTurn3 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+ scale(AVG_Temp_egg_Hour)+ scale(AVG_Temp_out_Hour)+scale(ClutchSize)+ scale(BodyCondition) ,  data=ED1FULL)
EDTurn4 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+ scale(AVG_Temp_egg_Hour)+ scale(ClutchSize)+ scale(BodyCondition) ,  data=ED1FULL)
EDTurn5 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3_T4)+scale(AVG_Temp_egg_Hour)+ scale(ClutchSize) + scale(BodyCondition), data=ED1FULL)
EDTurn6 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+ scale(AVG_Temp_egg_Hour)+ scale(AVG_Temp_out_Hour)+ scale(ClutchSize)+ scale(BodyCondition) , data=ED1FULL)
EDTurn7 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3)*scale(T4)+scale(AVG_Temp_egg_Hour)+ scale(ClutchSize)+ scale(BodyCondition) , data=ED1FULL)

#Models comparison
AIC(EDTurn1, EDTurn2, EDTurn3, EDTurn4,EDTurn5,EDTurn6, EDTurn7)
#Model diagnostic 
par(mfrow = c(2, 2))  
plot(EDTurn1)  
shapiro.test(residuals(EDTurn1))
hist(residuals(EDTurn1), breaks = 20, main = "Histogram of Residuals")

#Short listing models with stepwise AIC
stepwise_model <- stepAIC(EDTurn4, direction = "backward", trace = TRUE)
ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFAS_SUM", "T4", "T3","T3_T4", "AVG_Temp_egg_Hour","ClutchSize" )]), ]

EDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_egg_Hour),data=ED1FULL)
EDTurn4 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+ scale(AVG_Temp_egg_Hour)+ scale(ClutchSize) ,  data=ED1FULL)

#Comparing with the null
EDTurnNULL <- lm(AVG_turns_hour~ 1, data=ED1FULL)

AIC(EDTurn1, EDTurn4, EDTurnNULL)
#Final model: 
ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFAS_SUM", "T3_T4", "AVG_Temp_egg_Hour","ClutchSize")]), ]

EDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_egg_Hour), data=ED1)
#OR
#EDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(AVG_Temp_egg_Hour),data=ED1)
#OR
#EDTurn11 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3_T4)+scale(AVG_Temp_egg_Hour)+scale(BodyCondition),data=ED1)
#OR
#EDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_egg_Hour),data=ED1FULL)
#OR
#EDTurn1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3)+scale(AVG_Temp_egg_Hour),data=ED1)
AIC(EDTurn1, EDTurn11)
summary(EDTurn1)
nobs(EDTurn1)
confint(EDTurn1)
EDTurnNULL <- lm(AVG_turns_hour~ 1, data=ED1FULL)

AIC(EDTurn1, EDTurnNULL)
anova(EDTurnNULL, EDTurn1, test = "Chisq")
#Collinearity check 
vif(EDTurn1)
#Checking for influencial points 
#library(car)
#influencePlot(EDTurn1)  # Plots influence, labels extreme cases
#cooksd <- cooks.distance(EDTurn1)
#which(cooksd > 1)  # Identifies highly influential points
#IF needed! Re-running the model with the subset, excluding the influential points: 
#GD1_sub<- GD1[-2, ]  # Removes the second row
#MODEL
###With angular change ####
ED1 <- ED1%>%
  rename(AVG_Angular=Overal_angularChange_mean)
EDAng1 <- lm(AVG_Angular~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_egg_Hour), data=ED1)
summary(EDAng1)
##Without egg temperature 
ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFAS_SUM", "T3", "T3_T4", "ClutchSize", "BodyCondition")]), ]
EDTurnNoTemp1 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+ scale(PFAS_SUM)*scale(T3_T4)+scale(ClutchSize)+ scale(BodyCondition),data=ED1FULL)
stepwise_model <- stepAIC(EDTurnNoTemp1, direction = "backward", trace = TRUE)
# MODEL OUTPUT
ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFAS_SUM","T3_T4")]), ]

EDTurnNoTemp1<- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3_T4), data=ED1)
#OR
EDTurnNoTemp2 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3),data=ED1)
#OR
EDTurnNoTemp3 <- lm(AVG_turns_hour~ scale(PFAS_SUM)*scale(T3)+scale(BodyCondition),data=ED1FULL)
#OR
EDTurnNoTemp4 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3)+scale(BodyCondition),data=ED1FULL)
#OR
EDTurnNoTemp5 <- lm(AVG_turns_hour~ scale(PFAS_SUM)+scale(T3_T4)+scale(ClutchSize),data=ED1)
#AIC(EDTurnNoTemp1,EDTurnNoTemp2,EDTurnNoTemp3,EDTurnNoTemp4,EDTurnNoTemp5)
EDTurnNULL <- lm(AVG_turns_hour~ 1,data=ED1FULL)
AIC(EDTurnNoTemp1, EDTurnNULL)
anova(EDTurnNULL, EDTurnNoTemp)

summary(EDTurnNoTemp1) 
nobs(EDTurnNoTemp1)
confint(EDTurnNULL)
#
par(mfrow = c(2, 2))  
plot(EDTurnNoTemp1)  
shapiro.test(residuals(EDTurnNoTemp))
hist(residuals(EDTurnNoTemp), breaks = 20, main = "Histogram of Residuals")
vif(EDTurnNoTemp)
#Comparing whethere with or without temperature model gives a better fit: With ED1 dataset.
AIC(EDTurnNoTemp1, EDTurn1)

# Checking the effect of each PFAS, separately
COR <- ED1[, c("PFUnA", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFUnA", "T4", "T3", "AVG_Temp_egg_Hour")]), ]
#EDTurnPFAS <- lm(AVG_turns_hour~ scale(PFUnA)*scale(T3)+scale(PFUnA)*scale(T4)+scale(AVG_Temp_egg_Hour),data=ED1FULL)
stepwise_model <- stepAIC(EDTurnPFAS, direction = "backward", trace = TRUE)
#Model output: 
ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFOS", "T3", "AVG_Temp_egg_Hour")]), ]
EDTurnPFUnA <- lm(AVG_turns_hour~ scale(PFUnA)+scale(T3_T4)+scale(AVG_Temp_egg_Hour),data=ED1)
EDTurnPFHxS <- lm(AVG_turns_hour~ scale(PFHxS)+scale(T3_T4)+scale(AVG_Temp_egg_Hour),data=ED1)
EDTurnPFNA <- lm(AVG_turns_hour~ scale(PFNA)+scale(T3_T4)+scale(AVG_Temp_egg_Hour),data=ED1)
EDTurnPFOS <- lm(AVG_turns_hour~ scale(PFOS)+scale(T3_T4)+scale(AVG_Temp_egg_Hour),data=ED1)
#
summary(EDTurnPFOS)
confint(EDTurnPFOS)
nobs(EDTurnPFAS)
par(mfrow = c(2, 2))  
plot(EDTurnPFAS)  
shapiro.test(residuals(EDTurnPFAS))
hist(residuals(EDTurnPFAS), breaks = 20, main = "Histogram of Residuals")
vif(EDTurnPFAS)

EDTurnNULL <- lm(AVG_turns_hour~ 1,data = ED1FULL)
AIC(EDTurnPFAS , EDTurnNULL)
anova(EDTurnNULL, EDTurnPFAS, test = "Chisq")


###Plotting###
#PFAS on turning frequency 
sum(!is.na(ED1$PFAS_SUM) & !is.na(ED1$AVG_turns_hour))

new_data <- data.frame(
  PFAS_SUM = seq(min(ED1$PFAS_SUM, na.rm = TRUE), 
                 max(ED1$PFAS_SUM, na.rm = TRUE), 
                 length.out = 100),
  # Setting other variables to their mean to isolate PFAS effect
  T3_T4 = mean(ED1$T3_T4, na.rm = TRUE),
  AVG_Temp_egg_Hour = mean(ED1$AVG_Temp_egg_Hour, na.rm = TRUE))

predictions <- predict(EDTurn1, newdata = new_data, type = "response", se.fit = TRUE)
new_data$Predicted <- predictions$fit
new_data$SE <- predictions$se.fit

new_data <- new_data %>%
  mutate(Lower = Predicted - 1.96 * SE,  
         Upper = Predicted + 1.96 * SE) 

ggplot(new_data, aes(x = PFAS_SUM, y = Predicted)) +
  geom_line(color = "cornflowerblue", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "cornflowerblue", alpha = 0.4) +
  geom_point(data = ED1, aes(x = PFAS_SUM, 
                                 y = AVG_turns_hour), 
             size = 3, color = "cornflowerblue", alpha = 0.4)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title = "", x = "∑PFAS", y = "Predicted average turning frequency (Overall/Hour)")

#T3:T4 and turning frequency 
sum(!is.na(ED1$T3_T4) & !is.na(ED1$AVG_turns_hour))

new_data2 <- data.frame(
  PFAS_SUM = mean(ED1$PFAS_SUM, na.rm = TRUE),  # Setting PFAS_SUM to its mean
  T3_T4 = seq(min(ED1$T3_T4, na.rm = TRUE),
              max(ED1$T3_T4, na.rm=TRUE),
           length.out = 100),
  AVG_Temp_egg_Hour = mean(ED1$AVG_Temp_egg_Hour, na.rm = TRUE))

new_data_predict <- predict(EDTurn1, newdata = new_data2, type = "response", se.fit = TRUE)

new_data2 <- new_data2%>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )


ggplot(new_data2, aes(x = T3_T4, y = Predicted)) +
  geom_line(color = "cornflowerblue", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "cornflowerblue", alpha = 0.3) +
  geom_point(data = ED1, aes(x = T3_T4, 
                                 y = AVG_turns_hour), 
             size = 3, color = "cornflowerblue", alpha = 0.5)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="T3:T4 ratio", y= "Predicted average turning frequency (Overall/Hour)")

#Average egg temperature vs. Average frequency rate 
sum(!is.na(ED1$AVG_Temp_egg_Hour) & !is.na(ED1$AVG_turns_hour))

new_data3 <- data.frame(
  PFAS_SUM = mean(ED1$PFAS_SUM, na.rm = TRUE),
  T4 = mean(ED1$T4, na.rm=TRUE),
  T3 = mean(ED1$T3, na.rm = TRUE),
  AVG_Temp_egg_Hour = seq(min(ED1$AVG_Temp_egg_Hour, na.rm=TRUE),
                          max(ED1$AVG_Temp_egg_Hour, na.rm = TRUE),
                          length.out=100),
  ClutchSize = mean(ED1$ClutchSize, na.rm = TRUE)
)

new_data_predict <- predict(EDTurn1, newdata = new_data3, type = "response", se.fit = TRUE)

new_data_temp <- new_data3 %>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data_temp, aes(x = AVG_Temp_egg_Hour, y = Predicted)) +
  geom_line(color = "cornflowerblue", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "cornflowerblue", alpha = 0.3) +
  geom_point(data = ED1, aes(x =  AVG_Temp_egg_Hour, 
                                 y = AVG_turns_hour), 
             size = 3, color = "cornflowerblue", alpha = 0.5)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="Average egg temperature (Overall/Hour)", y= "Predicted average turning frequency (Overall/Hour)")

#PFAS*T3 interaction on turning frequency 
sum(!is.na(ED1$T3) & !is.na(ED1$AVG_turns_hour) & !is.na(ED1$PFAS_SUM))
new_data_interaction <- expand.grid(
  PFAS_SUM = seq(min(ED1$PFAS_SUM, na.rm = TRUE), 
                 max(ED1$PFAS_SUM, na.rm = TRUE), 
                 length.out = 100),
  T3 = quantile(ED1$T3, probs = c(0.25, 0.5, 0.75), na.rm = TRUE), # Different levels of T4
  T4 = mean(ED1$T4, na.rm = TRUE),
  AVG_Temp_egg_Hour = mean(ED1$AVG_Temp_egg_Hour, na.rm = TRUE),
  ClutchSize = mean(ED1$ClutchSize, na.rm = TRUE)
)

new_data_predict <- predict(EDTurn1, newdata = new_data_interaction, type = "response", se.fit = TRUE)

new_data_interaction <- new_data_interaction %>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data_interaction, aes(x = PFAS_SUM, y = Predicted, color = as.factor(T3))) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper, fill = as.factor(T3)), alpha = 0.2) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.55, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = "",
    x = "PFAS_SUM",
    y = "Predicted Average Turning Frequency",
    color = "T3 Level",
    fill = "T3 Level"
  )

# PFASs all on egg turning
coefs <- bind_rows(
  tidy(EDTurnPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(EDTurnPFHxS, conf.int = TRUE) %>% filter(term == "scale(PFHxS)") %>% mutate(compound = "PFHxS"),
  tidy(EDTurnPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(EDTurnPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    p.value < 0.10  ~ "•",  
    TRUE            ~ ""
  ))
# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFUnA", "PFHxS", "PFNA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black", position=position_nudge(y=0.15)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "skyblue1",
    high = "firebrick3",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Egg Turning Rate (Overall/Hour)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA),
    legend.position = "none")
#----PER day ED turning frequency ----
#1) Making a new dataset for the daily average rate 1) 
ED1Daily <- ED1
#
ED1Daily <- ED1Daily%>%
  rename(Total_record_hr= `Total record (Hour)`)
ED1Daily <- ED1Daily%>%
  rename(AVG_Temp_day= `AVG.Temp.egg (Day)`)
#class(GD1Daily$Total_record_hr)
ED1Daily$Total_record_hr <- as.numeric(ED1Daily$Total_record_hr)
ED1Daily$Days.recorded <- as.numeric(ED1Daily$Days.recorded)
ED1Daily$AVG_Temp_day <- as.numeric(ED1Daily$AVG_Temp_day)
# Only keeping days with at least 19 hours of record
ED1Daily$DecimalPart <- ED1Daily$Days.recorded- floor(ED1Daily$Days.recorded)
# Step 2: Apply the condition: Remove decimals if < 0.70
ED1Daily$AdjustedRecordedDays <- ifelse(ED1Daily$DecimalPart < 0.70, 
                                        floor(ED1Daily$Days.recorded), 
                                        ED1Daily$Days.recorded)
ED1Daily$newTotalHours <- ED1Daily$AdjustedRecordedDays*24

#Re-calculating the average hourly turn
ED1Daily$NewHourlyTurns <- ED1Daily$AVG_turns_hour * (ED1Daily$Total_record_hr / ED1Daily$newTotalHours)

#Getting the average daily turn
ED1Daily$Daily_avg_turn <- ED1Daily$NewHourlyTurns*24
ED1Daily$Daily_avg_turn <- round(ED1Daily$Daily_avg_turn, 3)
##Analyzing!
Shapiro <- shapiro.test(ED1Daily$Daily_avg_turn)
Shapiro
var_turns <- var(ED1Daily$Daily_avg_turn)
mean_turns <- mean(ED1Daily$Daily_avg_turn)
dispersion <- var_turns/mean_turns

## 
COR <- ED1Daily[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_day","Daily_avg_turn","AdjustedRecordedDays")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

EDTurnFULL <- ED1Daily[complete.cases(ED1Daily[c("Daily_avg_turn","PFAS_SUM", "T4", "T3","T3_T4", "AVG_Temp_day","ClutchSize","BodyCondition", "AdjustedRecordedDays")]), ]

EDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+scale(BodyCondition), data=EDTurnFULL)
EDTurn2 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize), data=EDTurnFULL)
EDTurn3 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_day)+ scale(ClutchSize)+ scale(AdjustedRecordedDays) , data=EDTurnFULL)

#Shortlisting the best models 
stepwise_model <- stepAIC(EDTurn3, direction = "backward", trace = TRUE)

EDTurnFULL <- ED1Daily[complete.cases(ED1Daily[c("Daily_avg_turn","PFAS_SUM", "T4", "T3","T3_T4", "AVG_Temp_day","ClutchSize")]), ]
EDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_day)+ scale(ClutchSize), data=EDTurnFULL)
EDTurn2 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_Temp_day), data=EDTurnFULL)
#Comparing with the null model 
EDTurnNULL <- lm(Daily_avg_turn~ 1,data=EDTurnFULL)

AIC(EDTurn1,EDTurn2, EDTurnNULL)
anova(EDTurn2, EDTurnNULL, test = "Chisq")
#Residuals test
par(mfrow = c(2, 2))  
plot(EDTurn1)  
shapiro.test(residuals(EDTurn1))
hist(residuals(EDTurn1), breaks = 20, main = "Histogram of Residuals")
#Colinearity 
vif(EDTurn1)
#Model output
EDTurnFULL <- ED1Daily[complete.cases(ED1Daily[c("Daily_avg_turn","PFAS_SUM", "T3", "AVG_Temp_day")]), ]

EDTurn1 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_Temp_day), data=ED1Daily)
#OR
EDTurn2 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3)+scale(AVG_Temp_day), data=ED1Daily)
#OR
EDTurn3 <- lm(Daily_avg_turn~ scale(PFAS_SUM)*scale(T3), data=ED1Daily)

EDTurnNULL <- lm(Daily_avg_turn~ 1,data=ED1Daily)

summary(EDTurn1)
nobs(EDTurn1) 
confint(EDTurn2)
AIC(EDTurn1, EDTurnNULL)

#Possible influential points 
influencePlot(EDTurn1)  
cooksd <- cooks.distance(EDTurn1)
which(cooksd > 1)  # Identifies influential observations
#ED1Daily_sub<- ED1Daily[-c(18,17), ]  # Removes the second row
#Both models, with and without influential points, show a similar effect of PFAS
# Checking the effect of each PFAS, separately
COR <- ED1Daily[, c("PFNA", "Daily_avg_turn")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

EDTurnFULL <- ED1Daily[complete.cases(ED1Daily[c("Daily_avg_turn","PFUnA", "T4", "T3", "AVG_Temp_day")]), ]
EDTurnPFAS <- lm(Daily_avg_turn~ scale(PFUnA)*scale(T3)+scale(PFUnA)*scale(T4)+scale(AVG_Temp_day), data=EDTurnFULL)
#OR
EDTurnFULL <- ED1Daily[complete.cases(ED1Daily[c("Daily_avg_turn","PFUnA","T3_T4", "AVG_Temp_day", "ClutchSize")]), ]
EDTurn1 <- lm(Daily_avg_turn~ scale(PFUnA)*scale(T3_T4)+scale(AVG_Temp_day)+ scale(ClutchSize), data=EDTurnFULL)
#
stepwise_model <- stepAIC(EDTurn1, direction = "backward", trace = TRUE)

#Residuals test
par(mfrow = c(2, 2))  
plot(EDTurnPFAS)  
shapiro.test(residuals(EDTurnPFAS))
hist(residuals(EDTurnPFAS), breaks = 20, main = "Histogram of Residuals")
#Model output
EDTurnFULL <- ED1Daily[complete.cases(ED1Daily[c("Daily_avg_turn","PFOS", "T4", "T3", "AVG_Temp_day")]), ]
EDTurnPFAS <- lm(Daily_avg_turn~ scale(PFOS)+scale(T3)+scale(T4)+scale(AVG_Temp_day), data=EDTurnFULL)

#
summary(EDTurnPFAS)
EDTurnNULL <- lm(Daily_avg_turn~ 1,data=EDTurnFULL)
AIC(EDTurnPFAS,EDTurnNULL)
nobs(EDTurnPFAS)
Confint(EDTurnPFAS)



# ----Q3) PFAS *TH+hourly turning rate on egg temperature ----
# ------In goldeneye------ 
COR <- GD1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "AVG_turns_hour")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# Normality testing for distribution selection  
Shapiro <- shapiro.test(GD1$AVG_Temp_egg_Hour)
Shapiro
var_Temp <- var(GD1$AVG_Temp_egg_Hour)
mean_Temp <- mean(GD1$AVG_Temp_egg_Hour)
dispersion <- var_Temp /mean_Temp 
##
# Since there are missing values, I run the model also with the subset of data to make sure the output is the same:
GDTemFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "T4", "T3","T3_T4", "AVG_Temp_egg_Hour","ClutchSize","BodyCondition", "AVG_turns_hour")]), ]

GDTemT1 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3_T4), data=GDTemFULL)
GDTemT2 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)* scale(T3_T4)+ scale(ClutchSize) , data=GDTemFULL)
GDTemT3 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)* scale(T3)+ scale(PFAS_SUM)*scale(T4)+ scale(ClutchSize) , data=GDTemFULL)
GDTemT4 <- lm(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)* scale(T3)+ scale(ClutchSize)+ scale(BodyCondition), data=GDTemFULL)
GDTemT5 <- lm(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)+scale(T3)+scale(T4)+ scale(BodyCondition)+ scale(AVG_turns_hour), data=GDTemFULL)
GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize)+ scale(BodyCondition), data=GDTemFULL)
GDTemT7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize), data=GDTemFULL)
GDTemT8 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_turns_hour)+ scale(ClutchSize), data=GDTemFULL)

#Model selection 
AIC(GDTemT1,GDTemT2,GDTemT3,GDTemT4,GDTemT5,GDTemT6,GDTemT7,GDTemT8)
# 
GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize)+ scale(BodyCondition), data=GDTemFULL)
GDTemT7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize), data=GDTemFULL)

stepwise_model <- stepAIC(GDTemT7, direction = "backward", trace = TRUE)

#Selected model
GDTemFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "T4", "T3", "AVG_Temp_egg_Hour","BodyCondition", "AVG_turns_hour")]), ]
GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(T4)+scale(AVG_turns_hour)+ scale(BodyCondition), data=GDTemFULL)

#OR
GDTemFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "T4", "T3", "AVG_Temp_egg_Hour", "AVG_turns_hour")]), ]
GDTemT7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(T4)+scale(AVG_turns_hour), data=GD1)
#Residuals test
par(mfrow = c(2, 2))  
plot(GDTemPFAS)  
shapiro.test(residuals(GDTemPFAS))
hist(residuals(GDTemT8), breaks = 20, main = "Histogram of Residuals")
vif(GDTemT8)

#NULL
GDTemNULL <- lm(AVG_Temp_egg_Hour ~ 1, data=GDTemFULL)
AIC(GDTemT6, GDTemNULL)
anova(GDTemT6, GDTemNULL, test = "Chisq")

#Model output: 
GDTemFULL <- GD1[complete.cases(GD1[c("PFAS_SUM","T3","T3_T4", "AVG_Temp_egg_Hour","BodyCondition", "AVG_turns_hour")]), ]
GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM), data=GD1)
#OR
#GDTemT7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_turns_hour)+scale(BodyCondition), data=GD1)
#OR
#GDTemT8 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_turns_hour), data=GD1)
#OR
#GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(T4)+scale(AVG_turns_hour)+ scale(BodyCondition), data=GD1)

#GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(AVG_turns_hour)+scale(BodyCondition), data=GD1)
#OR
#GDTemT66 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3), data=GD1)
AIC(GDTemT6,GDTemT7,GDTemT8)
summary(GDTemT6)
nobs(GDTemT6)
confint(GDTemT6)
#JUST FOR TURNING RATES 
GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(AVG_turns_hour)+scale(ClutchSize), data=GD1)


#Checking for influencial points 
library(car)
influencePlot(GDTemT6)  # Plots influence, labels extreme cases

cooksd <- cooks.distance(GDTemPFAS)
which(cooksd > 1)  # Identifies highly influential points
#IF needed! Re-running the model with the subset, excluding the influential points: 
GD1_sub<- GD1[-6, ]  # Removes the second row
#MODEL
#GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(T4)+scale(AVG_turns_hour)+ scale(BodyCondition), data=GD1_sub)
#GDTemT6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(AVG_turns_hour)+scale(BodyCondition), data=GD1_sub)

#Individual PFAS
GDTemFULL <- GD1[complete.cases(GD1[c("PFNA", "T3", "AVG_Temp_egg_Hour","AVG_turns_hour")]), ]

GDTemPFUnA<- lm(AVG_Temp_egg_Hour~ scale(PFUnA)+scale(T3_T4)+scale(AVG_turns_hour), data=GD1)
GDTemPFNA<- lm(AVG_Temp_egg_Hour~ scale(PFNA)+scale(T3_T4)+scale(AVG_turns_hour), data=GD1)
GDTemPFDoDA<- lm(AVG_Temp_egg_Hour~ scale(PFDoDA)+scale(T3_T4), data=GD1)
GDTemPFOS<- lm(AVG_Temp_egg_Hour~ scale(PFOS), data=GD1)

summary(GDTemPFOS)
nobs(GDTemPFAS)

GDTemNULL <- lm(AVG_Temp_egg_Hour~ 1,data=GDTemFULL)
AIC(GDTemPFAS,GDTemNULL)


#Plot: PFAS on egg temperature 
sum(!is.na(GD1$PFAS_SUM))

new_data <- data.frame(
  PFAS_SUM = seq(min(GDTemFULL$PFAS_SUM, na.rm = TRUE),
                 max(GDTemFULL$PFAS_SUM, na.rm = TRUE),
                 length.out=100),
  T3 = mean(GDTemFULL$T3, na.rm=TRUE),
  AVG_turns_hour = mean(GDTemFULL$AVG_turns_hour, na.rm=TRUE),
  BodyCondition = mean(GDTemFULL$BodyCondition, na.rm = TRUE)
)

new_data_predict <- predict(GDTemT6 , newdata = new_data, type = "response", se.fit = TRUE)

new_data_temp <- new_data %>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data_temp, aes(x =PFAS_SUM, y = Predicted)) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "#B8800B", alpha = 0.3) +
  geom_point(data = GD1, aes(x =  PFAS_SUM, 
                                 y = AVG_Temp_egg_Hour), 
             size = 3, color = "#B8923B", alpha = 0.5)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="∑PFAS", y= "Predicted average egg temperature (Overall/Hour)")

#Plot: T3 on egg temperature 
sum(!is.na(GD1$T3))

new_data <- data.frame(
  T3 = seq(min(GDTemFULL$T3, na.rm = TRUE),
           max(GDTemFULL$T3, na.rm = TRUE),
           length.out=100),
  T4= mean(GDTemFULL$T4, na.rm=TRUE),
  PFAS_SUM = mean(GDTemFULL$PFAS_SUM, na.rm=TRUE),
  BodyCondition = mean(GDTemFULL$BodyCondition, na.rm = TRUE),
  AVG_turns_hour = mean(GDTemFULL$AVG_turns_hour, na.rm=TRUE)
)

new_data_predict <- predict(GDTemT6 , newdata = new_data, type = "response", se.fit = TRUE)

new_data_temp <- new_data %>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data_temp, aes(x =T3, y = Predicted)) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "#B8800B", alpha = 0.3) +
  geom_point(data = GD1, aes(x =  T3, 
                             y = AVG_Temp_egg_Hour), 
             size = 3, color = "#B8923B", alpha = 0.5)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="T3", y= "Predicted average egg temperature (Overall/Hour)")

#Plot: egg turning rate on egg temperature 
sum(!is.na(GD1$AVG_turns_hour))

new_data <- data.frame(
  T3 = mean(GDTemFULL$T3, na.rm = TRUE),
  PFAS_SUM = mean(GDTemFULL$PFAS_SUM, na.rm=TRUE),
  BodyCondition = mean(GDTemFULL$BodyCondition, na.rm = TRUE),
  AVG_turns_hour = seq(min(GDTemFULL$AVG_turns_hour, na.rm=TRUE),
                       max(GDTemFULL$AVG_turns_hour, na.rm=TRUE),
                       length.out=100)
)

new_data_predict <- predict(GDTemT6 , newdata = new_data, type = "response", se.fit = TRUE)

new_data_temp <- new_data %>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data_temp, aes(x =AVG_turns_hour, y = Predicted)) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "#B8800B", alpha = 0.3) +
  geom_point(data = GD1, aes(x =  AVG_turns_hour, 
                             y = AVG_Temp_egg_Hour), 
             size = 3, color = "#B8923B", alpha = 0.5)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(title="", x="Average egg turning rate (Overall/Hour)", y= "Predicted average egg temperature (Overall/Hour)")

#Plot:PFAS*T3 on egg temperature 
sum(!is.na(GD1$T3) & !is.na(GD1$AVG_turns_hour) & !is.na(GD1$PFAS_SUM))

new_data_interaction <- expand.grid(
  PFAS_SUM = seq(min(GDTemFULL$PFAS_SUM, na.rm = TRUE), 
                 max(GDTemFULL$PFAS_SUM, na.rm = TRUE), 
                 length.out = 100),
  T3 = quantile(GDTemFULL$T3, probs = c(0.25, 0.5, 0.75), na.rm = TRUE), # Different levels of T3
  AVG_turns_hour= mean(GDTemFULL$AVG_turns_hour, na.rm = TRUE),
  BodyCondition = mean(GDTemFULL$BodyCondition, na.rm = TRUE)
)

new_data_predict <- predict(GDTemT6, newdata = new_data_interaction, type = "response", se.fit = TRUE)

new_data_interaction <- new_data_interaction %>%
  mutate(
    Predicted = new_data_predict$fit,
    SE = new_data_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data_interaction, aes(x = PFAS_SUM, y = Predicted, color = as.factor(T3))) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper, fill = as.factor(T3)), alpha = 0.2) +
  scale_color_manual(values = c("#D1B300", "#B8823B", "#5E4718")) +
  scale_fill_manual(values = c("#D1B300", "#B8823B", "#5E4718")) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.55, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = "",
    x = "∑PFAS",
    y = "Predicted Average egg temperature (Overall/Hour)",
    color = "T3 (pg/µl)",
    fill = "T3 (pg/µl)"
  )

#PFASs all and egg temperature 
coefs <- bind_rows(
  tidy(GDTemPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(GDTemPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(GDTemPFDoDA, conf.int = TRUE) %>% filter(term == "scale(PFDoDA)") %>% mutate(compound = "PFDoDA"),
  tidy(GDTemPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFDoDA", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "skyblue1",
    high = "firebrick3",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Egg temperature (Overall/Hour)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
# ------ Q3.1) Separate: Goldeneye temperature as function of average turn------
#COR <- GD1[, c("PFAS_SUM", "ClutchSize", "AVG_turns_hour","BodyCondition", "T3", "T4","T3_T4", "RecordedDays")]
#correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")
#GDTemFULL <- GD1[complete.cases(GD1[c("PFAS_SUM","T3","T4", "AVG_Temp_egg_Hour","AVG_turns_hour", "RecordedDays")]), ]
#GDTemT1 <- glmmTMB(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)*scale(T3_T4)+ scale(AVG_turns_hour), family=gaussian, data=GDTemFULL)
#GDTemT2 <- glmmTMB(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize)+ scale(RecordedDays), family=gaussian, data=GDTemFULL)
#GDTemT3 <- glmmTMB(AVG_Temp_egg_Hour~ scale(AVG_turns_hour)+scale(PFAS_SUM),family=gaussian, data=GDTemFULL)
#GDTemT4 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3)*scale(T4)+scale(AVG_turns_hour) , family=gaussian, data=GDTemFULL)
#GDTemT5 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3)+scale(T4)+scale(AVG_turns_hour) , family=gaussian, data=GDTemFULL)
#GDTemT6 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3)+scale(AVG_turns_hour) , family=gaussian, data=GDTemFULL)
#GDTemT7 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3_T4)+scale(AVG_turns_hour) , family=gaussian, data=GDTemFULL)
#GDTemT8 <- glmmTMB(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)*scale(T3_T4)+ scale(BodyCondition)+ scale(AVG_turns_hour), family=gaussian, data=GDTemFULL)

#GDTemNULL <- glmmTMB(AVG_Temp_egg_Hour ~ 1, family=gaussian, data=GDTemFULL)

#sim_res <- simulateResiduals(GDTemT2)
#plot(sim_res)
#summary(GDTemT2)
#confint(GDTemT8)
#check_collinearity(GDTemT2)
#nobs(GDTemT2)
#AIC(GDTemT1,GDTemT2,GDTemT3,GDTemT4,GDTemT5,GDTemT6,GDTemT7,GDTemT8,GDTemT9,GDTemNULL)
#AIC(GDTemT1,GDTemT2,GDTemT3,GDTemNULL)
#anova(GDTemT2, GDTemNULL, test = "Chisq")

#Selected model 
#GDTemFULL <- GD1[complete.cases(GD1[c("PFAS_SUM","T3","T4", "AVG_Temp_egg_Hour","AVG_turns_hour", "RecordedDays","ClutchSize")]), ]
#GDTemT2 <- glmmTMB(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize)+ scale(RecordedDays), family=gaussian, data=GDTemFULL)
#anova(GDTemT2, GDTemNULL, test = "Chisq")

#For individual PFAS
#COR <- GD1[, c("PFUnA", "ClutchSize", "AVG_turns_hour","BodyCondition", "T3", "T4","T3_T4", "RecordedDays")]
#correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#GDTemFULL <- GD1[complete.cases(GD1[c("PFDoDA","T3_T4", "AVG_Temp_egg_Hour","AVG_turns_hour","BodyCondition")]), ]

#GDTemT8 <- glmmTMB(AVG_Temp_egg_Hour ~ scale(PFOS)*scale(T3_T4)+ scale(BodyCondition)+ scale(AVG_turns_hour), family=gaussian, data=GDTemFULL)
#summary(GDTemT8)
#confint(GDTemT8)
#check_collinearity(GDTemT8)
#sim_res <- simulateResiduals(GDTemT8)
#plot(sim_res)
#nobs(GDTemT8)

# ------In Eider (PFAS *TH +hourly egg turning on egg temperature)------- 
COR <- ED1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "AVG_turns_hour", "Incubation_stage")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# Normality testing for distribution selection  
Shapiro <- shapiro.test(ED1$AVG_Temp_egg_Hour)
Shapiro
var_Temp <- var(ED1$AVG_Temp_egg_Hour)
mean_Temp <- mean(ED1$AVG_Temp_egg_Hour)
dispersion <- var_Temp/mean_Temp 
#Adding the incubation stage as a variable here
ED1$Incubation_stage <- as.numeric(factor(ED1$Incubation_stage,
                                          levels= c("Early.breeder", "Peak.incubation", "Late.breeder"),
                                          labels= c(1,2,3)))
#
EDTemFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "T4", "T3", "T3_T4", "AVG_Temp_egg_Hour","ClutchSize","BodyCondition", "AVG_turns_hour","Incubation_stage")]), ]

EDTem1 <- lm(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)*scale(T3_T4)+ scale(BodyCondition), data=EDTemFULL)
EDTem2 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3_T4)+ scale(ClutchSize)+ Incubation_stage , data=EDTemFULL)
EDTem3 <- lm(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)*scale(T3_T4),data=EDTemFULL)
EDTem4 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+ scale(ClutchSize)+ Incubation_stage , data=EDTemFULL)
EDTem5 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(T4)+ scale(ClutchSize)+ Incubation_stage , data=EDTemFULL)
EDTem6 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize)+ scale(BodyCondition), data=EDTemFULL)
EDTem7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize), data=EDTemFULL)
EDTem8 <- lm(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)*scale(T3_T4)+ scale(BodyCondition)+scale(AVG_turns_hour), data=EDTemFULL)
EDTem9 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+ scale(ClutchSize)+ Incubation_stage+scale(AVG_turns_hour) , data=EDTemFULL)

#Model selection 
AIC(EDTem1,EDTem2,EDTem3,EDTem4,EDTem5,EDTem6,EDTem7,EDTem8,EDTem9)

# Top models
EDTemFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "T4", "T3", "T3_T4", "AVG_Temp_egg_Hour","ClutchSize","BodyCondition", "AVG_turns_hour","Incubation_stage")]), ]
EDTem7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize), data=EDTemFULL)
EDTem8 <- lm(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)*scale(T3_T4)+ scale(BodyCondition)+scale(AVG_turns_hour), data=EDTemFULL)
EDTem9 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+ scale(ClutchSize)+ Incubation_stage+scale(AVG_turns_hour) , data=EDTemFULL)

stepwise_model <- stepAIC(EDTem9, direction = "backward", trace = TRUE)
#Selected model
EDTemFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "T4", "T3", "T3_T4", "AVG_Temp_egg_Hour","ClutchSize","BodyCondition", "AVG_turns_hour","Incubation_stage")]), ]
EDTem7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+scale(AVG_turns_hour), data=EDTemFULL)
EDTem8 <- lm(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)+scale(T3_T4)+ scale(BodyCondition)+scale(AVG_turns_hour), data=EDTemFULL)
EDTem9 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+ scale(ClutchSize)+ Incubation_stage+scale(AVG_turns_hour) , data=EDTemFULL)

#Residuals test
par(mfrow = c(2, 2))  
plot(EDTemPFAS)  
shapiro.test(residuals(EDTemPFAS))
hist(residuals(EDTem7), breaks = 20, main = "Histogram of Residuals")
#Colinearity 
vif(EDTemPFAS)

#NULL
EDTemNULL <- lm(AVG_Temp_egg_Hour ~ 1, data=EDTemFULL)
AIC(EDTem7,EDTem8,EDTem9, EDTemNULL)
anova(EDTem9, EDTemNULL, test = "Chisq")

#Model output: 
EDTemFULL <- ED1[complete.cases(ED1[c("PFAS_SUM","T3_T4", "AVG_Temp_egg_Hour", "AVG_turns_hour")]), ]
#EDTem7 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+scale(AVG_turns_hour), data=ED1)
#OR
EDTem8 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM), data=ED1)
#EDTem88 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3_T4)+scale(AVG_turns_hour), data=ED1)
#OR
#EDTem9 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3)+scale(T4)+scale(AVG_turns_hour)+scale(BodyCondition), data=ED1)
#OR
#EDTem10 <- lm(AVG_Temp_egg_Hour~ scale(PFAS_SUM)+scale(T3_T4)+scale(AVG_turns_hour)+scale(BodyCondition), data=ED1)
AIC(EDTem8, EDTemNULL)
AIC(EDTem7,EDTem8,EDTem9,EDTem10)
summary(EDTem8)
nobs(EDTem8)
confint(EDTem7)
#ONLY FOR EGG TURNING ¨
EDTem8 <- lm(AVG_Temp_egg_Hour~ scale(AVG_turns_hour), data=ED1)

#For a mediator analysis
ED1$PFAS_sc <- as.numeric(scale(ED1$PFAS_SUM))
ED1$turns_sc <- as.numeric(scale(ED1$AVG_turns_hour))
ED1$temp_sc <- as.numeric(scale(ED1$AVG_Temp_egg_Hour))

# Mediator model
model.M <- lm(turns_sc ~ PFAS_sc, data = ED1)

# Outcome model
model.Y <- lm(temp_sc ~ PFAS_sc + turns_sc, data = ED1)

# Mediation
library(mediation)
mediate.out <- mediate(model.M, model.Y, treat = "PFAS_sc", mediator = "turns_sc", boot = TRUE, sims = 1000)
summary(mediate.out)


#Checking potential infleuntial points
library(car)
influencePlot(EDTem7)  # Plots influence, labels extreme cases

cooksd <- cooks.distance(EDTemPFAS)
which(cooksd > 1) 

#Individual PFAS
EDTemFULL <- ED1[complete.cases(ED1[c("PFNA", "AVG_Temp_egg_Hour","T3_T4", "AVG_turns_hour")]), ]
EDTemPFUnA <- lm(AVG_Temp_egg_Hour~ scale(PFUnA)+scale(T3_T4)+scale(AVG_turns_hour), data=ED1)
EDTemPFHxS <- lm(AVG_Temp_egg_Hour~ scale(PFHxS)+scale(T3_T4)+scale(AVG_turns_hour), data=ED1)
EDTemPFNA <- lm(AVG_Temp_egg_Hour~ scale(PFNA)+scale(T3_T4)+scale(AVG_turns_hour), data=ED1)
EDTemPFOS <- lm(AVG_Temp_egg_Hour~ scale(PFOS)+scale(T3_T4), data=ED1)

summary(EDTemPFOS)
nobs(EDTemPFAS)

EDTemNULL <- lm(AVG_Temp_egg_Hour~ 1,data=EDTemFULL)
AIC(EDTemPFAS,EDTemNULL)

#Plotting# 
#PFAS on egg temperature
sum(!is.na(ED1$PFAS_SUM) & !is.na(ED1$AVG_Temp_egg_Hour))

new_data <- data.frame(
  T3_T4 = mean(ED1$T3_T4, na.rm = TRUE),
  AVG_turns_hour = mean (ED1$AVG_turns_hour, na.rm=TRUE),
  PFAS_SUM= seq(min(ED1$PFAS_SUM, na.rm = TRUE), 
                max(ED1$PFAS_SUM, na.rm = TRUE),
                length.out = 100)
)


Tem_predict <- predict(EDTem8, newdata = new_data , type = "response", se.fit = TRUE)

new_data <- new_data %>%
  mutate(
    Predicted = Tem_predict$fit,
    SE = Tem_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data, aes(x = PFAS_SUM, y = Predicted)) +
  geom_line(color = "cornflowerblue", size = 1.2) +
  geom_point(data = ED1, aes(x =  PFAS_SUM, 
                             y = AVG_Temp_egg_Hour), 
             size = 3, color = "cornflowerblue", alpha = 0.5)+
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "cornflowerblue", alpha = 0.3) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(title = "", x = "∑PFAS", y = "Predicted average egg temperature (Overall/Hour)")

#Average egg turning on egg temperature 
sum(!is.na(ED1$AVG_turns_hour) & !is.na(ED1$AVG_Temp_egg_Hour))

new_data <- data.frame(
  T3_T4 = mean(ED1$T3_T4, na.rm = TRUE),
  AVG_turns_hour = seq (min(ED1$AVG_turns_hour, na.rm=TRUE),
                        max(ED1$AVG_turns_hour, na.rm=TRUE),
                        length.out=100),
  PFAS_SUM= mean(ED1$PFAS_SUM, na.rm=TRUE)
)


Tem_predict <- predict(EDTem8, newdata = new_data , type = "response", se.fit = TRUE)

new_data <- new_data %>%
  mutate(
    Predicted = Tem_predict$fit,
    SE = Tem_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )

ggplot(new_data, aes(x = AVG_turns_hour, y = Predicted)) +
  geom_line(color = "cornflowerblue", size = 1.2) +
  geom_point(data = ED1, aes(x =  AVG_turns_hour, 
                             y = AVG_Temp_egg_Hour), 
             size = 3, color = "cornflowerblue", alpha = 0.5)+
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "cornflowerblue", alpha = 0.3) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(title = "", x = "Average turning frequency (Overall/Hour)", y = "Predicted average egg temperature (Overall/Hour)")

##PFASs all and egg temperature 
coefs <- bind_rows(
  tidy(EDTemPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(EDTemPFHxS, conf.int = TRUE) %>% filter(term == "scale(PFHxS)") %>% mutate(compound = "PFHxS"),
  tidy(EDTemPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(EDTemPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    p.value < 0.10  ~ "•",  
    TRUE            ~ ""
  ))
# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFUnA", "PFHxS", "PFNA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black", position=position_nudge(y=0.15)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "skyblue1",
    high = "firebrick3",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Egg temperature (Overall/Hour)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))
# ------ Q3.2) Separate: Eider average temperature as function of average turn------
#COR <- ED1[, c("T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour")]
#correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFAS_SUM", "T4", "T3","T3_T4", "AVG_Temp_egg_Hour","ClutchSize")]), ]

#EDTemT1 <- glmmTMB(AVG_Temp_egg_Hour~ scale(PFAS_SUM)*scale(T3)+scale(PFAS_SUM)*scale(T4)+scale(AVG_turns_hour)+ scale(ClutchSize) , family=gaussian, data=ED1FULL)
#EDTemT2 <- glmmTMB(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)*scale(T3_T4)+ scale(AVG_turns_hour), family=gaussian, data=ED1FULL)
#EDTemT3 <- glmmTMB(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)+scale(T3_T4)+ scale(AVG_turns_hour), family=gaussian, data=ED1FULL)
#EDTemT4 <- glmmTMB(AVG_Temp_egg_Hour~ scale(AVG_turns_hour)+scale(PFAS_SUM),family=gaussian, data=ED1FULL)
#EDTemT5 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3)*scale(T4)+scale(AVG_turns_hour) , family=gaussian, data=ED1FULL)
#EDTemT6 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3)+scale(T4)+scale(AVG_turns_hour) , family=gaussian, data=ED1FULL)
#EDTemT7 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3)+scale(AVG_turns_hour) , family=gaussian, data=ED1FULL)
#EDTemT8 <- glmmTMB(AVG_Temp_egg_Hour~ scale(T3_T4)+scale(AVG_turns_hour) , family=gaussian, data=ED1FULL)

#EDTemTNULL <- glmmTMB(AVG_Temp_egg_Hour ~ 1, family=gaussian, data=ED1FULL)

#sim_res <- simulateResiduals(EDTemT3)
#plot(sim_res)
#AIC(EDTemT1,EDTemT2,EDTemT3,EDTemT4,EDTemT5,EDTemT6,EDTemT7,EDTemT8,EDTemTNULL)
#summary(EDTemT4)
#confint(EDTemT3)
#check_collinearity(EDTemT3)
#nobs(EDTemT3)
#anova(EDTemT2, EDTemTNULL, test = "Chisq")

#Selected model 
#ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFAS_SUM","T3_T4", "AVG_Temp_egg_Hour")]), ]
#EDTemT3 <- glmmTMB(AVG_Temp_egg_Hour ~ scale(PFAS_SUM)+scale(T3_T4)+ scale(AVG_turns_hour), family=gaussian, data=ED1FULL)
#summary(EDTemT3)
#anova(EDTemT3, EDTemTNULL, test = "Chisq")

#Individual PFAS
#ED1FULL <- ED1[complete.cases(ED1[c("AVG_turns_hour", "PFNA","T3_T4", "AVG_Temp_egg_Hour")]), ]
#EDTemT3 <- glmmTMB(AVG_Temp_egg_Hour ~ scale(PFOS)+scale(T3_T4)+ scale(BodyCondition), family=gaussian, data=ED1FULL)
#summary(EDTemT3)
#confint(EDTemT3)
#check_collinearity(EDTemT3)
#nobs(EDTemT3)
#sim_res <- simulateResiduals(EDTemT3)
#plot(sim_res)

#---- Q5) Hatching success, turning frequency, egg temperature and PFAS ----
#------For GD------

#Correlation check
COR <- GD1[, c("AVG_turns_hour", "T3_T4" ,"PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "HatchingSuccess_adj")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GD1 <- GD1%>%
  rename(Hatched_eggs = `Hatched eggs`)

GDHatchFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "AVG_Temp_egg_Hour", "T3","T4","T3_T4")]), ]

GDHatch1 <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ scale(PFAS_SUM) + scale(AVG_Temp_egg_Hour), family = binomial(), data = GD1)

#GDHatch2 <- glmmTMB(
 # cbind(Hatched_eggs, ClutchSize) ~ scale(PFAS_SUM) + scale(T3_T4), family = binomial(), data = GD1)

#GDHatch3 <- glmmTMB(
#  cbind(Hatched_eggs, ClutchSize) ~ scale(PFAS_SUM) + scale(T4), family = binomial(), data = GD1)

#GDHatch4 <- glmmTMB(
 # cbind(Hatched_eggs, ClutchSize) ~ scale(PFAS_SUM) + scale(T3), family = binomial(), data = GD1)

AIC(GDHatch1, GDHatch2, GDHatch3, GDHatch4)

summary(GDHatch1)
nobs(GDHatch1)
#Model check
simres <- simulateResiduals(GDHatch1) 
plot(simres)
testDispersion(simres)

mod_lm <- lm(HatchingSuccess ~ scale(PFAS_SUM) + scale(AVG_Temp_egg_Hour), data = GD1)
vif(mod_lm)
GDHatchFULL <- GD1[complete.cases(GD1[c("ClutchSize","Hatched_eggs","PFAS_SUM", "AVG_Temp_egg_Hour")]), ]
GDNull <- glmmTMB(cbind(Hatched_eggs, ClutchSize)~ 1, family= binomial(), data=GDHatchFULL)
AIC(GDNull, GDHatch)

# Individual PFAS # 
COR <- GD1[, c("AVG_turns_hour", "T3_T4" ,"PFOS", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "HatchingSuccess_adj")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

GDHatchFULL <- GD1[complete.cases(GD1[c("ClutchSize","Hatched_eggs","PFOS", "T4", "AVG_turns_hour")]), ]

GDHatchPFUnA <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ scale(PFUnA)+scale(AVG_Temp_egg_Hour), family = binomial(), data = GD1)
GDHatchPFNA<- glm(
  cbind(Hatched_eggs, ClutchSize) ~ scale(PFNA)+scale(AVG_Temp_egg_Hour) , family = binomial(), data = GD1)
GDHatchPFDoDA <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ scale(PFDoDA)+scale(AVG_Temp_egg_Hour), family = binomial(), data = GD1)
GDHatchPFOS <- glm(
  cbind(Hatched_eggs, ClutchSize) ~ scale(PFOS) +scale(AVG_Temp_egg_Hour)+scale(T4), family = binomial(), data = GD1)
#GDHatchPFOS <- glm(
  #cbind(Hatched_eggs, ClutchSize) ~ scale(PFOS) +scale(AVG_turns_hour)+scale(T4), family = binomial(), data = GD1)
#GDHatchPFOS <- glm(
  #cbind(Hatched_eggs, ClutchSize) ~ scale(PFOS) +scale(AVG_Temp_egg_Hour), family = binomial(), data = GD1)

AIC(GDHatchPFOS, GDHatchPFOS1)
summary(GDHatchPFOS)
nobs(GDHatchPFOS)

GDHatchNullPFAS <- glm(cbind(Hatched_eggs, ClutchSize) ~ 1, family = binomial(), data = GDHatchFULL)
AIC(GDHatchPFOS1,GDHatchPFOS2,GDHatchNullPFAS)
anova(GDHatchPFOS, GDHatchNullPFAS, test = "Chisq")

#Model check 
simres <- simulateResiduals(GDHatchPFOS) 
plot(simres)
testDispersion(simres)

mod_lm <- lm(HatchingSuccess ~ scale(PFOS) +scale(AVG_turns_hour)+scale(T4), data = GD1)
vif(mod_lm)
############
##ALTERNATIVE APPROACH 
#Using zer-one adjustment technique to run betaregression 
#epsilon <- 1e-6
#GD1$HatchingSuccess_adj <- (GD1$HatchingSuccess / 100) * (1 - 2 * epsilon) + epsilon
#range(GD1$HatchingSuccess_adj)
#OR
#GD1_clean<- GD1
#n <- nrow(GD1_clean)
#GD1_clean$HatchingSuccess_adj <- (GD1_clean$HatchingSuccess_adj * (n - 1) + 0.5) / n
#range(GD1_clean$HatchingSuccess_adj, na.rm = TRUE)

#GDHatchFULL <- GD1[complete.cases(GD1[c("HatchingSuccess_adj","AVG_turns_hour", "PFAS_SUM","T3","T4", "AVG_Temp_egg_Hour","ClutchSize","BodyCondition" )]), ]
#
#GDHatch1 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)* scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch2 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch3 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)* scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch4 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch5 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+scale(T3_T4)+scale(AVG_Temp_egg_Hour)+ scale(ClutchSize), data=GDHatchFULL)
#GDHatch6 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+scale(T3_T4)+scale(ClutchSize)+ scale(BodyCondition) , data=GDHatchFULL)
#GDHatch7 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition) , data=GDHatchFULL)
#GDHatch8 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour)+scale(ClutchSize)+ scale(BodyCondition) , data=GDHatchFULL)
#GDHatch9 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour)*scale(T3_T4)+scale(ClutchSize)+ scale(BodyCondition) , data=GDHatchFULL)
#GDHatch10 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour)*scale(T3_T4), data=GDHatchFULL)
#GDHatch11 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour)+scale(T3_T4), data=GDHatchFULL)
#GDHatch12 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour), data=GDHatchFULL)
#GDHatch13 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(AVG_Temp_egg_Hour), data=GDHatchFULL)
#GDHatch14 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch15 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)* scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch16 <- betareg(HatchingSuccess_adj~ scale(PFAS_SUM), data=GDHatchFULL)

#Model selection 
#AIC(GDHatch1, GDHatch2, GDHatch3, GDHatch4, GDHatch5, GDHatch6,GDHatch7, GDHatch8,GDHatch9, GDHatch10, GDHatch11, GDHatch12, GDHatch13, GDHatch14, GDHatch15, GDHatch16)

#GDHatchFULL <- GD1[complete.cases(GD1[c("HatchingSuccess_adj","AVG_turns_hour", "PFAS_SUM", "AVG_Temp_egg_Hour")]), ]
#GDHatch1 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)* scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch12 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour), data=GDHatchFULL)
#GDHatch14 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=GDHatchFULL)
#GDHatch16 <- betareg(HatchingSuccess_adj~ scale(PFAS_SUM), data=GDHatchFULL)

#AIC(GDHatch1, GDHatch12, GDHatch14, GDHatch16)

#lrtest(GDHatch1, GDHatch12)# Choosing 12
#lrtest(GDHatch12, GDHatch14) # Sticking with Model 12
#lrtest(GDHatch14, GDHatch16)# 12

#Selected models
#GDHatchFULL2 <- GD1[complete.cases(GD1[c("HatchingSuccess_adj","AVG_turns_hour", "PFAS_SUM", "AVG_Temp_egg_Hour")]), ]
#GDHatch12 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour), data=GDHatchFULL2)
#To check what's the difference between data sets 
#a<- GD1[!complete.cases(GD1[c("T3","T4","ClutchSize","BodyCondition")]), ]
#Checking the influence of the missing row
#GDHatch12_exclude <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour) + scale(PFAS_SUM) + scale(AVG_Temp_egg_Hour), 
                             #data = GD1[GD1$FemaleID != "HT278838", ])  # Replace MISSING_ID with actual ID
#summary(GDHatch12_exclude)
#cooksd <- cooks.distance(GDHatch12_exclude)
#plot(cooksd, type="h", main="Cook's Distance", ylab="Cook's Distance")
#abline(h = 4/length(cooksd), col="red") 

#dfbetas <- dfbetas(GDHatch12)
#plot(dfbetas[, "PFAS_SUM"], main="DFBETAS for PFAS_SUM", ylab="DFBETAS")
#
#summary(GDHatch12)
#nobs(GDHatch12)
#confint(GDHatch12)
#OR
#GDHatchFULL <- GD1[complete.cases(GD1[c("HatchingSuccess_adj","PFAS_SUM", "AVG_Temp_egg_Hour")]), ]
#GDHatch14 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=GD1)
#summary(GDHatch14)
#nobs(GDHatch14)
#OR

#GDHatchFULL <- GD1[complete.cases(GD1[c("HatchingSuccess_adj","PFAS_SUM", "AVG_turns_hour")]), ]
#GDHatch12 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM), data=GDHatchFULL)

# Model check
#GDHatchNull <- betareg(HatchingSuccess_adj ~ 1, data = GDHatchFULL)
#AIC(GDHatch15, GDHatchNull)
#lrtest(GDHatch14, GDHatchNull)

#par(mfrow = c(2, 2))
#plot(GDHatch14)
#plot(GDHatchPFAS)
# Pearson Residuals vs. Fitted Values
#plot(fitted(GDHatch14), residuals(GDHatch14, type = "pearson"),
 #    xlab = "Fitted Values", ylab = "Pearson Residuals",
  #   main = "Residuals vs Fitted")
#abline(h = 0, col = "red", lty = 2)

#qqnorm(residuals(GDHatch14, type = "pearson"), main = "Q-Q Plot")
#qqline(residuals(GDHatch14, type = "pearson"), col = "red")
#par(mfrow = c(1, 1))

# Histogram of Residuals
#hist(residuals(GDHatch14, type = "pearson"), breaks = 20, 
     #main = "Histogram of Residuals", col = "gray",
     #xlab = "Pearson Residuals")

#Checking multicolinearity
#check_collinearity(GDHatch14)

#Model output
#GDHatchFULL <- GD1[complete.cases(GD1[c("HatchingSuccess_adj","PFAS_SUM","AVG_Temp_egg_Hour")]), ]
#GDout <- GD1
#GDout$AVG_Temp_egg_Hour[]
#GDHatch14 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=GD1)
#OR
#GDHatchFULL <- GD1[complete.cases(GD1[c("HatchingSuccess_adj","PFAS_SUM","T4")]), ]
#GDHatch15 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+scale(AVG_Temp_egg_Hour), data=GD1_clean)
#GDHatch15 <- betareg(HatchingSuccess_adj~ scale(PFAS_SUM)+scale(T4), data=GD1_clean)
#summary(GDHatch14)
#nobs(GDHatch15)
#AIC(GDHatch14, GDHatch15)
#########Checking potential infleuntial points
# Extract fitted values
#fitted_values <- fitted(GDHatch15)

# Extract residuals
#residuals <- residuals(GDHatch15)

# Calculate leverage
# Leverage can be obtained from the hat values (which are part of the model diagnostics)
#hat_values <- hatvalues(GDHatch15)

# Combine the information into a data frame for easy inspection
#diagnostic_data <- data.frame(
 # Residuals = residuals,
  #FittedValues = fitted_values,
  #Leverage = hat_values
#)

# Inspect the diagnostic data
#head(diagnostic_data)
# Calculate Cook's distance manually
#p <- length(coef(GDHatch15))  # Number of parameters in the model (including the intercept)
#mse <- sum(residuals^2) / (length(residuals) - p)  # Mean Squared Error

# Cook's distance calculation
#cooks_distance <- (residuals^2 / (p * mse)) * (hat_values / (1 - hat_values)^2)

# Identify influential points (Cook's distance > 1)
#influential_points <- which(cooks_distance > 1)
#influential_points

##Bootstrapping 


#Plot
# Egg temperature on hatching success 
sum(!is.na(GD1$AVG_Temp_egg_Hour)& !is.na(GD1$ClutchSize) & !is.na(GD1$Hatched_eggs))
#GD11 <- GD1
GD1$HatchingSuccess <- GD1$Hatched_eggs / GD1$ClutchSize

temp_seq <- seq(min(GD1$AVG_Temp_egg_Hour, na.rm = TRUE),
                max(GD1$AVG_Temp_egg_Hour, na.rm = TRUE),
                length.out = 100)

new_data <- data.frame(
  AVG_Temp_egg_Hour = temp_seq,
  PFAS_SUM = mean(GD1$PFAS_SUM, na.rm = TRUE)  # fixed PFAS level
)

pfas_center <- attr(scale(GD1$PFAS_SUM), "scaled:center")
pfas_scale <- attr(scale(GD1$PFAS_SUM), "scaled:scale")
temp_center <- attr(scale(GD1$AVG_Temp_egg_Hour), "scaled:center")
temp_scale <- attr(scale(GD1$AVG_Temp_egg_Hour), "scaled:scale")

new_data$PFAS_SUM_scaled <- (new_data$PFAS_SUM - pfas_center) / pfas_scale
new_data$AVG_Temp_egg_Hour_scaled <- (new_data$AVG_Temp_egg_Hour - temp_center) / temp_scale

pred_input <- data.frame(
  PFAS_SUM = new_data$PFAS_SUM_scaled,
  AVG_Temp_egg_Hour = new_data$AVG_Temp_egg_Hour_scaled
)

pred <- predict(GDHatch1, newdata = new_data, type = "link", se.fit = TRUE)
new_data$fit <- pred$fit
new_data$se <- pred$se.fit
new_data$predicted_prob <- plogis(new_data$fit)
new_data$lower <- plogis(new_data$fit - 1.96 * new_data$se)
new_data$upper <- plogis(new_data$fit + 1.96 * new_data$se)

new_data$predicted_prob <- predict(GDHatch1, newdata = new_data, type = "response")


ggplot(new_data, aes(x = AVG_Temp_egg_Hour, y = predicted_prob)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "#B8800B", alpha = 0.2) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_point(data = GD1, aes(x = AVG_Temp_egg_Hour, y = HatchingSuccess),
             inherit.aes = FALSE,color = "#B8800B", alpha = 0.5, size = 2) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = "",
    x = "Average egg temperature (°C)",
    y = "Predicted hatching success"
  )

###Tendency of PFOS on hatching success
sum(!is.na(GD1$HatchingSuccess_adj) & !is.na(GD1$PFOS))

ntercept <- 0.3730
coef_pfos <- -0.6989  # Significant effect
coef_avg_turns <- 0.0626 
range(GD1$PFOS,na.rm=TRUE)

PFOS_range <- c(0.54, 20.87)

PFOS_mean <- mean(GD1$PFOS, na.rm = TRUE)
PFOS_sd <- sd(GD1$PFOS, na.rm = TRUE)
PFOS_values <- seq(PFOS_range[1], PFOS_range[2], length.out = 100)  # Original scale
PFOS_scaled <- (PFOS_values - PFOS_mean) / PFOS_sd  # Standardized

# Compute predicted values using logit link
logit_pred <- intercept + coef_pfos  * PFOS_scaled
hatching_success_pred <- plogis(logit_pred) 

# Approximate confidence intervals (assuming a normal distribution)
se_pred <- 0.3686  # Standard error of the value's coefficient
ci_upper <- plogis(logit_pred + 1.96 * se_pred)
ci_lower <- plogis(logit_pred - 1.96 * se_pred)

# Create a dataframe for plotting
plot_data <- data.frame(PFOS_values, hatching_success_pred, ci_upper, ci_lower)

ggplot(plot_data, aes(x = PFOS_values, y = hatching_success_pred)) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), fill = "#B8800B", alpha = 0.2) + 
  geom_line(color = "#B8800B", size=1.2) +
  geom_point(data = GD1, aes(x =  PFOS, 
                             y = HatchingSuccess_adj), 
             size = 3, color = "#B8800B", alpha = 0.3)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(title = "", x = "PFOS", y = "Predicted hatching success")

#PFASs all and hacthing success
coefs <- bind_rows(
  tidy(GDHatchPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(GDHatchPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(GDHatchPFDoDA, conf.int = TRUE) %>% filter(term == "scale(PFDoDA)") %>% mutate(compound = "PFDoDA"),
  tidy(GDHatchPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    p.value < 0.10  ~ "•",  
    TRUE            ~ ""
  ))

# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFDoDA", "PFNA", "PFUnA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black",position=position_nudge(y=0.15)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "skyblue1",
    high = "firebrick3",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFAS",
    title = "Hatching success (%)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))

#------ For ED------
# Checking whether body condition varies across incuation stages 
hist(ED1$BodyCondition)
levels(ED1$Incubation_stage)
BODY <- lm(BodyCondition~ Incubation_stage, data= ED1)
summary(BODY)

ED1$Incubation_stage <- as.factor(ED1$Incubation_stage)

anova_result <- aov(BodyCondition~ Incubation_stage, data = ED1)
summary(anova_result)

ggplot(ED1, aes(x = Incubation_stage, y = BodyCondition)) +
  geom_boxplot(fill = "cornflowerblue", alpha = 0.6) +
  theme_minimal() +
  labs(x = "Incubation Stage", y = "Body Condition")
#Correlation check
ED1 <- ED1%>%
  rename(Hatched_remains = `Hatched remains`)
ED1$Hatched_remains <- as.numeric(ED1$Hatched_remains)
COR <- ED1[, c("AVG_turns_hour","T3_T4","PFAS_SUM", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "ClutchSize","Hatched_remains")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

#Model
hist(ED1$Hatched_remains)
EDHatchFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "AVG_Temp_egg_Hour", "T3","T4","T3_T4", "BodyCondition")]), ]

EDHatch1 <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) + scale(T3_T4), family = binomial(), data = ED1)

EDHatch2 <- glm(
 cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) + scale(T3), family = binomial(), data = ED1)

EDHatch3 <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) + scale(AVG_turns_hour), family = binomial(), data = ED1)

EDHatch4 <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) * scale(AVG_turns_hour), family = binomial(), data = ED1)

EDHatch5 <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) + scale(AVG_Temp_egg_Hour), family = binomial(), data = ED1)

EDHatch6 <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) + scale(BodyCondition), family = binomial(), data = ED1)

AIC(EDHatch1, EDHatch2, EDHatch3, EDHatch4, EDHatch5, EDHatch6)

summary(EDHatch1)
nobs(EDHatch1)
#Model check
##Selected model##
EDHatch1 <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFAS_SUM) +scale(T3_T4), family = binomial(), data = ED1)

simres <- simulateResiduals(EDHatch1) 
plot(simres)
testDispersion(simres)

check_collinearity(EDHatch1)

EDHatchFULL <- ED1[complete.cases(ED1[c("ClutchSize","Hatched_remains","PFAS_SUM", "T3_T4")]), ]
EDNull <- glm(cbind(Hatched_remains, ClutchSize)~ 1, family= binomial(), data=EDHatchFULL)
AIC(EDNull, EDHatch1)

#OR# 
##Modeling the absolute hatching success 
EDHatchFULL <- ED1[complete.cases(ED1[c("Absolute_Hatch","PFAS_SUM", "T3_T4", "BodyCondition", "AVG_turns_hour", "AVG_Temp_egg_Hour")]), ]

glm_abs1 <- glm(Absolute_Hatch ~ scale(PFAS_SUM) +scale(T3_T4),
               family = binomial(),
               data = ED1)

glm_abs2 <- glm(Absolute_Hatch ~ scale(PFAS_SUM) *scale(BodyCondition),
                family = binomial(),
                data = ED1)

glm_abs3 <- glm(Absolute_Hatch ~ scale(PFAS_SUM) +scale(AVG_turns_hour),
                family = binomial(),
                data = ED1)

glm_abs4 <- glm(Absolute_Hatch ~ scale(PFAS_SUM) +scale(AVG_Temp_egg_Hour),
                family = binomial(),
                data = ED1)

glm_abs5 <- glm(Absolute_Hatch ~ scale(PFAS_SUM) +scale(AVG_turns_hour)+scale(BodyCondition),
                family = binomial(),
                data = ED1)

glm_abs6 <- glm(Absolute_Hatch ~ scale(PFAS_SUM) +scale(T4)*scale(BodyCondition),
                family = binomial(),
                data = ED1)

AIC(glm_abs1, glm_abs2, glm_abs3, glm_abs4, glm_abs5, glm_abs6, EDNull)

summary(glm_abs6)
##Selected model
glm_abs2 <- glm(Absolute_Hatch ~ scale(PFAS_SUM) +scale(BodyCondition)+scale(AVG_Temp_egg_Hour),
                family = binomial(),
                data = ED1)
summary(glm_abs2)
nobs(glm_abs2)
#Model testing 
simres <- simulateResiduals(glm_abs2) 
plot(simres)
testDispersion(simres)

check_collinearity(glm_abs2)

EDHatchFULL <- ED1[complete.cases(ED1[c("Absolute_Hatch","PFAS_SUM", "BodyCondition")]), ]
EDNull <- glm(Absolute_Hatch~ 1, family= binomial(), data=EDHatchFULL)
AIC(EDNull, glm_abs2)

# Individual PFAS # 
COR <- ED1[, c("AVG_turns_hour", "T3_T4" ,"PFOS", "ClutchSize", "BodyCondition", "T3", "T4", "AVG_Temp_egg_Hour", "HatchingSuccess_adj")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

EDHatchFULL <- ED1[complete.cases(ED1[c("ClutchSize", "Hatched_remains","AVG_Temp_egg_Hour","AVG_turns_hour","PFOS", "T3_T4")]), ]

EDHatchPFUnA <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFUnA) + scale(T3_T4) , family = binomial(), data = ED1)
EDHatchPFNA<- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFNA)+ scale(T3_T4) , family = binomial(), data = ED1)
EDHatchPFHxS <- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFHxS)+ scale(T3_T4), family = binomial(), data = ED1)
EDHatchPFOS<- glm(
  cbind(Hatched_remains, ClutchSize) ~ scale(PFOS)+ scale(T3_T4), family = binomial(), data = ED1)


summary(EDHatchPFUnA)
nobs(EDHatchPFOS)

simres <- simulateResiduals(EDHatchPFOS) 
plot(simres)
testDispersion(simres)

check_collinearity(EDHatchPFOS)
#ALTERNATIVE APPROACH#
#Using zer-one adjustment technique to run betaregression 
#epsilon <- 1e-6
#ED1$HatchingSuccess_adj <- (ED1$HatchingSuccess / 100) * (1 - 2 * epsilon) + epsilon
#range(ED1$HatchingSuccess_adj, na.rm = TRUE)
#OR
#ED1_clean<- ED1
#n <- nrow(ED1_clean)
#ED1_clean$HatchingSuccess_adj <- (ED1_clean$HatchingSuccess_adj * (n - 1) + 0.5) / n
#range(ED1_clean$HatchingSuccess_adj, na.rm = TRUE)
#
#EDHatchFULL <- ED1[complete.cases(ED1[c("HatchingSuccess_adj","AVG_turns_hour", "AVG_Temp_egg_Hour", "PFAS_SUM","BodyCondition", "ClutchSize")]), ]
#
#EDHatch1 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)* scale(PFAS_SUM), data=ED1)
#EDHatch2 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(BodyCondition), data=ED1)
#EDHatch3 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(PFAS_SUM)+ scale(BodyCondition), data=ED1)
#EDHatch4 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour)* scale(BodyCondition), data=ED1)
#EDHatch5 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=ED1)
#EDHatch6 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM)+ scale(AVG_turns_hour), data=ED1)
#EDHatch7 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(PFAS_SUM)+ scale(AVG_turns_hour)* scale(BodyCondition), data=ED1)
#EDHatch8 <- betareg(HatchingSuccess_adj ~ scale(AVG_Temp_egg_Hour)* scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour)* scale(BodyCondition), data=ED1)
#EDHatch9 <- betareg(HatchingSuccess_adj ~ scale(AVG_Temp_egg_Hour)* scale(PFAS_SUM)+ scale(AVG_Temp_egg_Hour)* scale(ClutchSize), data=ED1)

#Model Selction 
#AIC(EDHatch1, EDHatch2, EDHatch3, EDHatch4, EDHatch5, EDHatch6,EDHatch7,EDHatch8,EDHatch9)
#Selected models 
#EDHatchFULL <- ED1[complete.cases(ED1[c("HatchingSuccess_adj","AVG_turns_hour", "AVG_Temp_egg_Hour", "PFAS_SUM","BodyCondition")]), ]
#EDHatch1 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)* scale(PFAS_SUM), data=EDHatchFULL )
#EDHatch2 <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFAS_SUM)+ scale(BodyCondition), data=ED1)
#EDHatch3 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(PFAS_SUM)+ scale(BodyCondition), data=ED1)
#EDHatch5 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=EDHatchFULL )
#EDHatch6 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM)+ scale(AVG_turns_hour), data=EDHatchFULL )
#EDHatch7 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(PFAS_SUM)+ scale(AVG_turns_hour)* scale(BodyCondition), data=EDHatchFULL )

#lrtest(EDHatch1, EDHatch5)# 5   
#lrtest(EDHatch1, EDHatch6)# Models are significantly different. Compare AIC
#lrtest(EDHatch1, EDHatch7)# Models are significantly different. Compare AIC
#lrtest(EDHatch5, EDHatch6)# 5
#lrtest(EDHatch5, EDHatch7)# Models are significantly different. Compare AIC
#lrtest(EDHatch6, EDHatch7)# Models are significantly different. Compare AIC

#AIC(EDHatch5, EDHatch6, EDHatch7,EDHatch1)
# Selected model 
#EDHatchFULL <- ED1[complete.cases(ED1[c("HatchingSuccess_adj", "AVG_Temp_egg_Hour", "PFAS_SUM")]), ]
#EDHatch5 <- betareg(HatchingSuccess_adj~ scale(AVG_Temp_egg_Hour)+ scale(PFAS_SUM), data=EDHatchFULL)
#summary(EDHatch5)
#nobs(EDHatch5)
#OR
#EDHatchFULL <- ED1[complete.cases(ED1[c("HatchingSuccess_adj","AVG_turns_hour", "PFAS_SUM")]), ]

#EDHatch7 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(BodyCondition)+ scale(PFAS_SUM), data=ED1_clean)
#OR
#EDHatch7 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(BodyCondition), data=ED1)

#EDHatch7 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(PFAS_SUM)+ scale(AVG_turns_hour)* scale(BodyCondition), data=ED1)
#AIC(EDHatch7, EDHatch8)
#summary(ED1$HatchingSuccess_adj)
#sum(!is.na(ED1$HatchingSuccess_adj))

#vif(EDHatch7)
#summary(EDHatch7)
#nobs(EDHatch7)
#confint(EDHatch7)
#AIC(EDHatch7, EDHatch8)
#EDHatchNULL <- betareg(HatchingSuccess_adj ~1, data=ED1)

#AIC(EDHatch8,EDHatch7,EDHatchNULL)
#lrtest(EDHatch7, EDHatchNULL)
#check_collinearity(EDHatch7)
#Model diagnostics 
#par(mfrow = c(2, 2))
#plot(EDHatchPFAS)
# Pearson Residuals vs. Fitted Values
#plot(fitted(EDHatch7), residuals(EDHatch7, type = "pearson"),
  #   xlab = "Fitted Values", ylab = "Pearson Residuals",
 #    main = "Residuals vs Fitted")
#abline(h = 0, col = "red", lty = 2)

#qqnorm(residuals(EDHatch7, type = "pearson"), main = "Q-Q Plot")
#qqline(residuals(EDHatch7, type = "pearson"), col = "red")

# Histogram of Residuals
#hist(residuals(GDHatch7, type = "pearson"), breaks = 20, 
  #   main = "Histogram of Residuals", col = "gray",
   #  xlab = "Pearson Residuals")

#par(mfrow = c(1, 1))

#Checking potential infleuntial points
# Extract fitted values
#fitted_values <- fitted(EDHatch7)

# Extract residuals
#residuals <- residuals(EDHatch7)

# Calculate leverage
# Leverage can be obtained from the hat values (which are part of the model diagnostics)
#hat_values <- hatvalues(EDHatch7)

# Combine the information into a data frame for easy inspection
#diagnostic_data <- data.frame(
 # Residuals = residuals,
  #FittedValues = fitted_values,
  #Leverage = hat_values
#)

# Inspect the diagnostic data
#head(diagnostic_data)
# Calculate Cook's distance manually
#p <- length(coef(EDHatch7))  # Number of parameters in the model (including the intercept)
#mse <- sum(residuals^2) / (length(residuals) - p)  # Mean Squared Error

# Cook's distance calculation
#cooks_distance <- (residuals^2 / (p * mse)) * (hat_values / (1 - hat_values)^2)

# Identify influential points (Cook's distance > 1)
#influential_points <- which(cooks_distance > 1)
#influential_points
###IF NEEDED, TO RUN THE MODEL ON ANTHER DATASET 
# Show the rows corresponding to influential points
#ED1[influential_points, ]

#ED1subset <- ED1[-1, ]

#EDHatch7 <- betareg(HatchingSuccess_adj ~ scale(AVG_turns_hour)* scale(BodyCondition)+ scale(PFAS_SUM), data=ED1subset)

# Individual PFAS
#EDHatchPFAS <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFOS)+ scale(BodyCondition), data=ED1)
#EDHatchPFUnA <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFUnA), data=ED1)
#EDHatchPFNA <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFNA), data=ED1)
#EDHatchPFHxS <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFHxS), data=ED1)
#EDHatchPFOS <- betareg(HatchingSuccess_adj~ scale(AVG_turns_hour)+ scale(PFOS), data=ED1)
#summary(EDHatchPFHxS)
#nobs(EDHatchPFHxS)
#summary(clutch)
#EDHatchNullPFAS <- betareg(HatchingSuccess_adj ~ 1, data = ED1)
#AIC(EDHatchPFAS, EDHatchNullPFAS )



###Ploting ###
####Interaction effect of average turning frequency and body condition on hatching success
sum(!is.na(ED1$HatchingSuccess_adj) & !is.na(ED1$AVG_turns_hour) & !is.na(ED1$BodyCondition))
library(emmeans)

range(ED1$BodyCondition, na.rm=TRUE)

ED1 <- ED1 %>%
  mutate(AVG_turns_hour_sc = scale(AVG_turns_hour)[,1],
         PFAS_SUM_sc = scale(PFAS_SUM)[,1],
         BodyCondition_sc = scale(BodyCondition)[,1])

# Run the model again with pre-scaled variables
betareg_model <- betareg(HatchingSuccess_adj ~ AVG_turns_hour_sc * PFAS_SUM_sc + 
                           AVG_turns_hour_sc * BodyCondition_sc,
                         data = ED1)

turning_range <- seq(min(ED1$AVG_turns_hour_sc, na.rm = TRUE),
                     max(ED1$AVG_turns_hour_sc, na.rm = TRUE), 
                     length.out = 100)

emm <- emmeans(betareg_model,
               specs = ~ AVG_turns_hour_sc * BodyCondition_sc,
               at = list(AVG_turns_hour_sc = turning_range,
                         BodyCondition_sc = c(-1.66, 0, 2.52)))

emm_df <- as.data.frame(emm)


ggplot(emm_df, aes(x = AVG_turns_hour_sc, y = emmean, color = factor(BodyCondition_sc), group = BodyCondition_sc)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = asymp.LCL, ymax = asymp.UCL, fill = factor(BodyCondition_sc)), alpha = 0.2) +
  labs(x = "Average egg turning rate (Overall/Hour)",
       y = "Predicted Hatching Success",
       color = "Body Condition",
       fill = "Body Condition") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"))+
  scale_color_manual(values = c("#D3D3D3", "#00BFFF", "#4169E1")) +
  scale_fill_manual(values = c("#D3D3D3", "#00BFFF", "#4169E1")) +
  theme(legend.position = "top")

#OR
new_data_interaction <- EDHatchFULL %>%
  select(AVG_turns_hour, BodyCondition) %>%
  mutate(PFAS_SUM = mean(EDHatchFULL$PFAS_SUM, na.rm = TRUE)) %>%
  expand(AVG_turns_hour, BodyCondition, PFAS_SUM)

new_data_interaction$HatchingSuccess_adj_pred <- predict(EDHatch7, 
                                                         newdata = new_data_interaction, 
                                                         type = "response")



ggplot(new_data_interaction, aes(x = AVG_turns_hour, y = BodyCondition, 
                                 fill = HatchingSuccess_adj_pred)) +
  geom_tile() +
  scale_fill_gradient(low="midnightblue", high="lightgoldenrodyellow") + 
  labs(title= "", x = "Average hourly egg turning frequency", y = "Body condition index", 
       fill = "Predicted Hatching success") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"))

####PFHxS on hatching success 
sum(!is.na(ED1$HatchingSuccess_adj) & !is.na(ED1$PFHxS))

intercept <- -0.45480
coef_pfhxs <- 1.18482  # Significant effect
coef_avg_turns <- 0.07491 

pfhxs_range <- c(0.22, 4.80)

pfhxs_mean <- mean(ED1$PFHxS, na.rm = TRUE)
pfhxs_sd <- sd(ED1$PFHxS, na.rm = TRUE)
pfhxs_values <- seq(pfhxs_range[1], pfhxs_range[2], length.out = 100)  # Original scale
pfhxs_scaled <- (pfhxs_values - pfhxs_mean) / pfhxs_sd  # Standardized

# Compute predicted values using logit link
logit_pred <- intercept + coef_pfhxs * pfhxs_scaled
hatching_success_pred <- plogis(logit_pred) 

# Approximate confidence intervals (assuming a normal distribution)
se_pred <- 0.31765  # Standard error of PFHxS coefficient
ci_upper <- plogis(logit_pred + 1.96 * se_pred)
ci_lower <- plogis(logit_pred - 1.96 * se_pred)

# Create a dataframe for plotting
plot_data <- data.frame(pfhxs_values, hatching_success_pred, ci_upper, ci_lower)


ggplot(plot_data, aes(x = pfhxs_values, y = hatching_success_pred)) +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), fill = "cornflowerblue", alpha = 0.2) + 
  geom_line(color = "cornflowerblue", size=1.2) +
  geom_point(data = ED1, aes(x =  PFHxS, 
                             y = HatchingSuccess_adj), 
             size = 3, color = "cornflowerblue", alpha = 0.3)+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(title = "", x = "PFHxS", y = "Predicted hatching success")


#PFASs all and hatching success
coefs <- bind_rows(
  tidy(EDHatchPFUnA, conf.int = TRUE) %>% filter(term == "scale(PFUnA)") %>% mutate(compound = "PFUnA"),
  tidy(EDHatchPFHxS, conf.int = TRUE) %>% filter(term == "scale(PFHxS)") %>% mutate(compound = "PFHxS"),
  tidy(EDHatchPFNA, conf.int = TRUE) %>% filter(term == "scale(PFNA)") %>% mutate(compound = "PFNA"),
  tidy(EDHatchPFOS, conf.int = TRUE) %>% filter(term == "scale(PFOS)") %>% mutate(compound = "PFOS")
)

coefs <- coefs %>%
  mutate(sig_label = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01  ~ "**",
    p.value < 0.05  ~ "*",
    p.value < 0.10  ~ "•",  
    TRUE            ~ ""
  ))
# Assign gradient values 
concentration_rank <- tibble(
  compound = c("PFUnA", "PFHxS", "PFNA", "PFOS"),
  conc_level = c(1, 2, 3, 4)  # Higher = higher concentration
)

# Merge with coefficients
coefs <- coefs %>%
  left_join(concentration_rank, by = "compound")

ggplot(coefs, aes(x = estimate, y = reorder(compound, estimate), color = conc_level)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  geom_text(aes(label = sig_label), hjust = -0.8, vjust = 0.2, size = 6, color = "black", position=position_nudge(y=0.15)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  scale_color_gradient(
    low = "skyblue1",
    high = "firebrick3",
    name = "Mean PFAS\nConcentration",
    breaks = c(1, 2, 3, 4),
    labels = c("Lowest", "", "", "Highest")
  ) +
  labs(
    x = "Standardized Regression Coefficient (± 95% CI)",
    y = "PFASs",
    title = "Hatching success (%)",
  ) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA))

#----Q6) PFAS and thyroid ----
#------In goldeneye------
COR <- GD1[, c("T3","T4","PFAS_SUM", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# Normality testing for distribution selection 
Shapiro <- shapiro.test(GD1$T3)
Shapiro
var <- var(GD1$T3, na.rm=TRUE)
mean <- mean(GD1$T3, na.rm=TRUE)
dispersion <- var/mean 
hist(GD1$T3)
range(GD1$T3,na.rm=TRUE)
# Going for a gamma distribution since T3 is positive skewed 
# Since there are missing values, I run the model also with the subset of data to make sure the output is the same:
GDthyFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "T3","ClutchSize", "BodyCondition")]), ]

GDThy1 <- glm(T3~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )
GDThy2 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )
GDThy3 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )
GDThy4 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(PFAS_SUM)*scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL)
GDThy5 <-  glm(T3~ scale(PFAS_SUM),family=Gamma(link="log"), data=GDthyFULL )

summary(GDThy1)
#Models comparison
AIC(GDThy1, GDThy2, GDThy3,GDThy4, GDThy5)

#Short listing models with stepwise AIC
stepwise_model <- stepAIC(GDThy5, direction = "backward", trace = TRUE)
GDthyFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "T3","ClutchSize", "BodyCondition")]), ]

GDThy1 <- glm(T3~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=GD1)
GDThy2 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize),family=Gamma(link="log"), data=GD1)
GDThy3 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=GD1 )
GDThy5 <-  glm(T3~ scale(PFAS_SUM),family=Gamma(link="log"), data=GD1 )

#Comparing with the null
GDThyNULL <- lm(T3~ 1,family=Gamma(link="log"), data=GD1)

AIC(GDThy1, GDThy2 , GDThy3, GDThy5,GDThyNULL)
#Final model: 
GDthyFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "T3","T4")]), ]
GDThyT3<- lm(log(T3)~ scale(PFAS_SUM)+scale(T4), data=GD1)
#OR
GDThyT3<- lm(log(T3)~ scale(PFAS_SUM), data=GD1)
#GDThy3 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=GD1)
#GDThy4 <- lm(log(T3)~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition), data=GD1)
#GDThy4 <- lm(log(T3)~ scale(PFAS_SUM)+scale(T4), data=GD1)
AIC(GDThyT3, GDThyT4)
GDThyT3T4<- lm(log(T3_T4)~ scale(PFAS_SUM), data=GD1)

range(GD1$T3,na.rm=TRUE)
GD1$T3_LOG <- log(GD1$T3)
range(GD1$T3_LOG,na.rm=TRUE)
GDThyT3<- lm(log(T3)~ scale(PFAS_SUM), data=GD1)

AIC(GDThyNULL, GDThyT3)

summary(GDThyT3T4)
exp(coef(GDThyT3))  
nobs(GDThyT4)
confint(GDThyT3)
GDThyNULL <- lm(T3~ 1, data=GDthyFULL)
drop1(GDThy3, test = "Chisq")
# Model diagnostics 
par(mfrow = c(2, 2))  
plot(GDThyT3)  
shapiro.test(residuals(GDThyT3))
hist(residuals(GDThyT3), breaks = 20, main = "Histogram of Residuals")

#Multicolinearity 
vif(GDThyT3)
#Individual PFAS 9
GDThyT3<- lm(log(T3)~ scale(PFUnA)+scale(T4), data=GD1)
#### FOR T4
Shapiro <- shapiro.test(GD1$T4)
Shapiro
var <- var(GD1$T4, na.rm=TRUE)
mean <- mean(GD1$T4, na.rm=TRUE)
dispersion <- var/mean 
hist(GD1$T4)
range(GD1$T4,na.rm=TRUE)
#
GDthyFULL <- GD1[complete.cases(GD1[c("PFAS_SUM", "T4","ClutchSize", "BodyCondition")]), ]

GDThy1 <- glm(T4~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )
GDThy2 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )
GDThy3 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )
GDThy4 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(PFAS_SUM)*scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL)
GDThy5 <-  glm(T4~ scale(PFAS_SUM),family=Gamma(link="log"), data=GDthyFULL )

AIC(GDThy1, GDThy2, GDThy3,GDThy4, GDThy5)
#Short listing models with stepwise AIC
stepwise_model <- stepAIC(GDThy3, direction = "backward", trace = TRUE)

GDThy1 <- glm(T4~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )
GDThy3 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=GDthyFULL )

AIC(GDThy1, GDThy2,GDThy3)
#Comparing with the null
GDThyNULL <- lm(T4~ 1,family=Gamma(link="log"), data=GDthyFULL)

AIC(GDThy1, GDThy3, GDThyNULL)
#Final model: 
GDThyT4<- lm(log(T4)~ scale(PFAS_SUM), data=GD1)
#OR
GDThyT4<- lm(log(T4)~ scale(PFAS_SUM)+scale(T3), data=GD1)
#GDThy1 <- glm(T4~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=GD1)
#OR
#GDThySIMPLE <- lm(log(T4)~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition), data=GD1)
GDThyT3T4<- lm(log(T3_T4)~ scale(PFAS_SUM), data=GD1)

summary(GDThyT3T4)
nobs(GDThyT4)
confint(GDThy1)
AIC(GDThyNULL, GDThySIMPLE)
GDThyNULL <- lm(log(T4)~ 1, data=GD1)
# Model diagnostics 
par(mfrow = c(2, 2))  
plot(GDTH1 )  
shapiro.test(residuals(GDTH1 ))
hist(residuals(GDThyT4), breaks = 20, main = "Histogram of Residuals")

#Multicolinearity 
vif(GDThyT4)
#Individual PFAS 
GDthyFULL <- GD1[complete.cases(GD1[c("T4","PFOS", "BodyCondition")]), ]
GDThyT4<- lm(log(T4)~ scale(PFDoDA)+scale(BodyCondition), data=GD1)
GDThyNULL <- lm(T4~ 1, data=GDthyFULL)
library(car)
influencePlot(GDThyT4)  # Plots influence, labels extreme cases

cooksd <- cooks.distance(GDThyT4)
which(cooksd > 1)
GD1SUB <- GD1[-6,]

AIC(GDThyT4, GDThyNULL)

###Plot: PFAS on T3
sum(!is.na(GD1$PFAS_SUM) & !is.na(GD1$T3))

new_data <- new_data %>%
  mutate(PFAS_SUM_scaled = (PFAS_SUM - mean(GD1$PFAS_SUM, na.rm = TRUE)) / 
           sd(GD1$PFAS_SUM, na.rm = TRUE))

colnames(new_data)[colnames(new_data) == "PFAS_SUM_scaled"] <- "scale(PFAS_SUM)"

Tem_predict <- predict(GDThy3, newdata = new_data, type = "response", se.fit = TRUE)

new_data <- new_data %>%
  mutate(
    Predicted = Tem_predict$fit,
    SE = Tem_predict$se.fit,
    Lower = Predicted - 1.96 * SE,
    Upper = Predicted + 1.96 * SE
  )


ggplot(new_data, aes(x = PFAS_SUM, y = Predicted)) +
  geom_line(color = "#B8800B", size = 1.2) +
  geom_point(data = GD1, aes(x =  PFAS_SUM, 
                             y = T3), 
             size = 3, color = "#B8800B", alpha = 0.5)+
  geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = "#B8800B", alpha = 0.3) +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.94, 0.86),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(title = "", x = "PFAS concentration (Sum)", y = "Predicted egg temperature (avg/hr)")

#------In Eider------ 
COR <- ED1[, c("T3","T4","PFAS_SUM", "ClutchSize", "BodyCondition")]
correlation_matrix <- cor(COR, method="spearman", use = "complete.obs")

# Normality testing for distribution selection 
shapiro.test(ED1$T3)
var <- var(ED1$T3, na.rm=TRUE)
mean <- mean(ED1$T3, na.rm=TRUE)
dispersion <- var/mean 
hist(ED1$T3)
range(ED1$T3,na.rm=TRUE)
# Going for a gamma distribution since T3 is positive skewed 
# Since there are missing values, I run the model also with the subset of data to make sure the output is the same:
EDthyFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "T3","ClutchSize", "BodyCondition")]), ]

EDThy1 <- glm(T3~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL )
EDThy2 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL )
EDThy3 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL )
EDThy4 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(PFAS_SUM)*scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL)
EDThy5 <-  glm(T3~ scale(PFAS_SUM),family=Gamma(link="log"), data=EDthyFULL )

summary(EDThy1)
#Models comparison
AIC(EDThy1, EDThy2, EDThy3,EDThy4, EDThy5)

#Short listing models with stepwise AIC
stepwise_model <- stepAIC(EDThy5, direction = "backward", trace = TRUE)
EDthyFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "T3","ClutchSize", "BodyCondition")]), ]

EDThy1 <- glm(T3~ scale(PFAS_SUM)+ scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL  )
EDThy3 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL  )
EDThy4 <- glm(T3~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(PFAS_SUM)*scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL )
EDThy5 <-  glm(T3~ scale(PFAS_SUM),family=Gamma(link="log"), data=EDthyFULL )

AIC(EDThy1,EDThy3,EDThy4, EDThy5)

#Comparing with the null
EDThyNULL <- lm(T3~ 1,family=Gamma(link="log"), data=EDthyFULL)

AIC(EDThy1, EDThy5,EDThyNULL)
#Final model: 
EDThyT3<- lm(log(T3)~ scale(PFAS_SUM)+scale(T4), data=ED1)
#OR
#EDThy5 <-  glm(T3~ scale(PFAS_SUM),family=Gamma(link="log"), data=ED1 )
#OR
EDThyT3T4<- lm(log(T3_T4)~ scale(PFAS_SUM), data=ED1)
range(ED1$T3_T4,na.rm=TRUE)

summary(EDThyT3T4)
nobs(EDThyT3)
confint(EDThyT3)
EDThyNULL <- lm(T3~ 1,family=Gamma(link="log"), data=ED1)

# Model diagnostics 
par(mfrow = c(2, 2))  
plot(EDThyT3)  
shapiro.test(residuals(EDThyT3))
hist(residuals(EDThyT3), breaks = 20, main = "Histogram of Residuals")

#Multicolinearity 
vif(EDThyT3)
#Individual PFAS
EDThyT3<- lm(log(T3)~ scale(PFHxS)+scale(Weight), data=ED1)
##FOR T4
shapiro.test(ED1$T4)
var <- var(ED1$T4, na.rm=TRUE)
mean <- mean(ED1$T4, na.rm=TRUE)
dispersion <- var/mean 
hist(ED1$T4)
range(ED1$T4,na.rm=TRUE)
##
EDthyFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "T4","ClutchSize", "BodyCondition")]), ]

EDThy1 <- glm(T4~ scale(PFAS_SUM)+ scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL )
EDThy2 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL )
EDThy3 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL )
EDThy4 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)+ scale(PFAS_SUM)*scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL)
EDThy5 <-  glm(T4~ scale(PFAS_SUM),family=Gamma(link="log"), data=EDthyFULL)

summary(EDThy1)
#Models comparison
AIC(EDThy1, EDThy2, EDThy3,EDThy4, EDThy5)

#Short listing models with stepwise AIC
stepwise_model <- stepAIC(EDThy5, direction = "backward", trace = TRUE)
EDthyFULL <- ED1[complete.cases(ED1[c("PFAS_SUM", "T3","ClutchSize", "BodyCondition")]), ]

EDThy3 <- glm(T4~ scale(PFAS_SUM)* scale(ClutchSize)* scale(BodyCondition),family=Gamma(link="log"), data=EDthyFULL  )
EDThy4 <- glm(T4~ scale(PFAS_SUM)+scale(BodyCondition),family=Gamma(link="log"), data=ED1 )
EDThy5 <-  glm(T4~ scale(PFAS_SUM),family=Gamma(link="log"), data=ED1 )

AIC(EDThy3,EDThy4, EDThy5)

#Comparing with the null
EDThyNULL <- lm(T4~ 1,family=Gamma(link="log"), data=EDthyFULL)

AIC(EDThy3, EDThy4,EDThy5,EDThyNULL)
#Final model: 
EDThyT4<- lm(log(T4)~ scale(PFAS_SUM), data=ED1)
EDThyT3T4<- lm(log(T3_T4)~ scale(PFAS_SUM), data=ED1)
summary(EDThyT3T4)
nobs(EDThyT4)
confint(EDThyT4)
EDThyNULL <- lm(T4~ 1, data=ED1)
AIC(EDThyNULL, EDThyT4)
# Model diagnostics 
par(mfrow = c(2, 2))  
plot(EDThyT4)  
shapiro.test(residuals(EDThyT4))
hist(residuals(EDThyT4), breaks = 20, main = "Histogram of Residuals")

#Multicolinearity 
vif(EDThyT4)

#Individual PFAS 
EDThyT4<- lm(log(T4)~ scale(PFUnA)+scale(BodyCondition), data=ED1)








#### Additional plots #### 
#From the raw data. Individual example
#Cumpative hourly turns as a function of euler angle change in an individual
library(circular)
library(lubridate)
library(tidyverse)

GD1$`Overall mean angular change` <- as.numeric(GD1$`Overall mean angular change`)

#1)
#Euler angle based on Euler theorom
GDEX <- `GD11(K07)`

GDEX <- GDEX %>%
  mutate(FemaleID = "HT107525")

GDEX <- GDEX %>%
  mutate(AVG_turns_hour = 1.306)

GDEX <- GDEX %>%
  mutate(`Overall mean angular change` = 17.021)

GDEX <- GDEX %>%
  mutate(Euler_Angle = circular(sqrt(Roll^2 + Pitch^2 + Yaw^2), units="degrees")) 

GDSUM1 <- GDEX %>%
  group_by(FemaleID) %>%
  arrange(FemaleID) %>%
  mutate(
    cum_turns = cumsum(AVG_turns_hour),
    cum_angular_change = cumsum(`Overall mean angular change`)
  )


ggplot(GDSUM1, aes(x = cum_angular_change, y = cum_turns, color = as.factor(FemaleID))) +
  geom_line(size = 1, alpha = 0.6) + 
  geom_point() +  
  geom_smooth(method = "loess", aes(group = 1), color = "black", se = TRUE) + 
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    legend.position = c(0.96, 0.32),
    axis.line = element_line(color = "black"),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = "",
    x = "Cumulative Angular Change (degrees)",
    y = "Cumulative Egg Turns (per hour)",
    color = "FemaleID"
  )





##Trnaslation of the code from Matlab
install.packages("R.matlab")
library(R.matlab)
#5 example eider females 
dAngle1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle1.mat")
dataSave1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave1.mat")
deltaAngle1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle1.mat")
time1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time1.mat")
startInd1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd1.mat")
endInd1<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd1.mat")
#
dAngle2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle2.mat")
dataSave2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave2.mat")
deltaAngle2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle2.mat")
time2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time2.mat")
startInd2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd2.mat")
endInd2<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd2.mat")
# 
dAngle3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle3.mat")
dataSave3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave3.mat")
deltaAngle3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle3.mat")
time3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time3.mat")
startInd3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd3.mat")
endInd3<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd3.mat")
#
dAngle4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle4.mat")
dataSave4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave4.mat")
deltaAngle4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle4.mat")
time4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time4.mat")
startInd4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd4.mat")
endInd4<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd4.mat")
#
dAngle5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dAngle5.mat")
dataSave5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\dataSave5.mat")
deltaAngle5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\deltaAngle5.mat")
time5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\time5.mat")
startInd5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\startInd5.mat")
endInd5<- readMat("C:\\Users\\svasha\\Desktop\\Sajjad_Vakili\\Articles\\Artifical eggs comparison and thyroid\\endInd5.mat")

#2)
#dAngle <- dAngle1$dAngle
#dataSave <- dataSave1$dataSave
#deltaAngle <- deltaAngle1$deltaAngle
#time <- time1$time
#startInd <- startInd1$startInd
#endInd <- endInd1$endInd
individuals_data <- list(
  list(dAngle = dAngle1$dAngle, dataSave=dataSave1$dataSave, deltaAngle = deltaAngle1$deltaAngle, time = time1$time, startInd = startInd1$startInd, endInd = endInd1$endInd),
  list(dAngle = dAngle2$dAngle, dataSave=dataSave2$dataSave, deltaAngle = deltaAngle2$deltaAngle, time = time2$time, startInd = startInd2$startInd, endInd = endInd2$endInd),
  list(dAngle = dAngle3$dAngle, dataSave=dataSave3$dataSave, deltaAngle = deltaAngle3$deltaAngle, time = time3$time, startInd = startInd3$startInd, endInd = endInd3$endInd),
list(dAngle = dAngle4$dAngle, dataSave=dataSave4$dataSave, deltaAngle = deltaAngle4$deltaAngle, time = time4$time, startInd = startInd4$startInd, endInd = endInd4$endInd),
list(dAngle = dAngle5$dAngle, dataSave=dataSave5$dataSave, deltaAngle = deltaAngle5$deltaAngle, time = time5$time, startInd = startInd5$startInd, endInd = endInd5$endInd))
#3)

#threshold_deg <- 10
#threshold_rad <- threshold_deg * pi / 180

#indices_greater_than_threshold <- which(deltaAngle > threshold_rad)

#start_times <- time1[startInd[indices_greater_than_threshold]]
#end_times <- time1[endInd[indices_greater_than_threshold]]
all_num_events_per_hr <- list()
all_dAngle <- list()

#plot((dataSave[5, startInd] + dataSave[5, endInd]) / 2 / 3600, 
     #deltaAngle * 180 / pi, 
     #main = "Angle Change vs. Time", 
    # xlab = "Time [hr]", 
   #  ylab = "Change in Orientation [deg]", 
  #   pch = 20, 
 #    col = "blue")
#grid()

dAngle <- seq(0, 180, by = 1) * pi / 180
num_events_per_hr <- sapply(dAngle, function(angle) {
  3600 * sum(deltaAngle > angle) / (max(time) - min(time))
})

smooth_fit <- smooth.spline(dAngle * 180 / pi, num_events_per_hr, spar = 0.7)
#plot(dAngle * 180 / pi, num_events_per_hr, 
#   type = "l", 
#    col = "#B8800B", 
#   lwd=2,
#    main = "Rotations per Hour vs. Angular Threshold", 
#    xlab = "Angle Threshold [deg]", 
#   ylab = "Rotations per Hour", 
#   xaxp = c(0, 180, 9))

for (i in 1:length(individuals_data)) {
  # Access individual data
  individual <- individuals_data[[i]]
  
  deltaAngle <- individual$deltaAngle
  time <- individual$time
  startInd <- individual$startInd
  endInd <- individual$endInd
  
  # Calculate number of events per hour for this individual
  num_events_per_hr_individual <- sapply(dAngle, function(angle) {
    3600 * sum(deltaAngle > angle) / (max(time) - min(time))
  })
  
  # Store results
  all_num_events_per_hr[[i]] <- num_events_per_hr_individual
  all_dAngle[[i]] <- dAngle
}

combined_num_events_per_hr <- do.call(cbind, all_num_events_per_hr)
combined_dAngle <- all_dAngle[[1]]  # Assuming the same angles for all individuals

mean_num_events_per_hr <- apply(combined_num_events_per_hr, 1, mean)
sd_num_events_per_hr <- apply(combined_num_events_per_hr, 1, sd)
ci_lower <- mean_num_events_per_hr - 1.96 * (sd_num_events_per_hr / sqrt(ncol(combined_num_events_per_hr)))
ci_upper <- mean_num_events_per_hr + 1.96 * (sd_num_events_per_hr / sqrt(ncol(combined_num_events_per_hr)))


combined_dAngle_deg <- combined_dAngle * 180 / pi
x_value <- 10
y_value_at_x_10 <- approx(combined_dAngle_deg, mean_num_events_per_hr, xout = x_value)$y

y_lim <- range(c(mean_num_events_per_hr, ci_upper, ci_lower), na.rm = TRUE)

plot(combined_dAngle * 180 / pi, mean_num_events_per_hr, 
     type = "l", 
     col = "#B8800B", 
     lwd = 4,
     main = "", 
     xlab = "Anglular change [deg]", 
     ylab = "Cumulative turns per hour", 
     xaxp = c(0, 180, 9),
     bty="n",
     ylim=y_lim)

lines(combined_dAngle * 180 / pi, ci_upper, 
      col = "red", 
      lty = 2,  # Dashed line for upper CI
      lwd = 2)

lines(combined_dAngle * 180 / pi, ci_lower, 
      col = "red", 
      lty = 2,  # Dashed line for lower CI
      lwd = 2)

points(x_value, y_value_at_x_10, col = "black", pch = 20, cex = 1.5)


### Example of daily temperature 
#GD 1:
GDTem <- `GD11(K07)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#random_date <- sample(unique(GDTem$Date), 1)
#print(random_date)
random_date<- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span=0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = paste("Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 2: 
GDTem <- `GD81(K05)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 3: 
GDTem <- `GD219(K16)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#GD 4: 
GDTem <- `GD96(K08)`

GDTem$Date <- as.Date(GDTem$Date)  
GDTem$Time <- as.POSIXct(paste(GDTem$Date, GDTem$Time), format="%Y-%m-%d %H:%M:%S") 

selected_date <- as.Date("2022-05-15")
print(selected_date)

GD_24h <- GDTem %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

ggplot(GD_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("Date:", selected_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )




### Eiders###
#ED 1:
EDTem <- `ED(B108W1.4)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#Either an assigned date
random_date <- as.Date("2023-05-29")
print(random_date)
#OR a random date
#random_date <- sample(unique(EDTem$Date), 1)
#print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span=0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)) +
  labs(
    title = paste("(Late breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#ED 2: 
EDTem <- `ED(B102W2.4)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Late breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )
#ED3
EDTem <- `ED(B22W1.3)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

#random_date <- sample(unique(EDTem$Date), 1)
#print(random_date)

ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Early breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

#ED4

EDTem <- `ED(B23W2.3)`

EDTem$Date <- as.Date(EDTem$Date)  
EDTem$Time <- as.POSIXct(paste(EDTem$Date, EDTem$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)


ED_24h <- EDTem %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "blue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title = paste("(Early breeder), Date:", random_date),
    x = "Time",
    y = "Egg Temperature (°C)"
  )

##### Daily turning movement 
library(circular)
library(lubridate)
library(tidyverse)
#Euler angle 
# Eider 1
EDMove1 <- `ED(B23W2.3)`

EDMove1$Date <- as.Date(EDMove1$Date)  
EDMove1$Time <- as.POSIXct(paste(EDMove1$Date, EDMove1$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

ED_24h <- EDMove1 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable"
  )

# OR
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_line(size = 1, alpha = 0.7) +  # Reduce opacity for better readability
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  )+
  labs(
    title = paste("(Early breeder) - Roll, Yaw, and Pitch, Date:", random_date),
    x = "Time",
    y = "Euler Angles (degrees)",
    color = "Variable"
  )

# Eider 2
EDMove2 <- `ED(B22W1.3)`

EDMove2$Date <- as.Date(EDMove2$Date)  
EDMove2$Time <- as.POSIXct(paste(EDMove2$Date, EDMove2$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-15")
print(random_date)

ED_24h <- EDMove2 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# Eider 3
EDMove3<- `ED(B102W2.4)`

EDMove3$Date <- as.Date(EDMove3$Date)  
EDMove3$Time <- as.POSIXct(paste(EDMove3$Date, EDMove3$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDMove3 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# Eider 4
EDMove4<- `ED(B108W1.4)`

EDMove4$Date <- as.Date(EDMove4$Date)  
EDMove4$Time <- as.POSIXct(paste(EDMove4$Date, EDMove4$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2023-05-29")
print(random_date)

ED_24h <- EDMove4 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "blue", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
ED_24h_long <- ED_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(ED_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

###In goldeneye
#GD1
GDMove1 <- `GD11(K07)`

GDMove1$Date <- as.Date(GDMove1$Date)  
GDMove1$Time <- as.POSIXct(paste(GDMove1$Date, GDMove1$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove1 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD2
GDMove2 <- `GD81(K05)`

GDMove2$Date <- as.Date(GDMove2$Date)  
GDMove2$Time <- as.POSIXct(paste(GDMove2$Date, GDMove2$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove2 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD3
GDMove3 <- `GD219(K16)`

GDMove3$Date <- as.Date(GDMove3$Date)  
GDMove3$Time <- as.POSIXct(paste(GDMove3$Date, GDMove3$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove3 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
GD_24h_long <- GD_24h %>%
  select(Time, Roll, Yaw, Pitch) %>%
  pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")

# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")

# GD4
GDMove4 <- `GD96(K08)`

GDMove4$Date <- as.Date(GDMove4$Date)  
GDMove4$Time <- as.POSIXct(paste(GDMove4$Date, GDMove4$Time), format="%Y-%m-%d %H:%M:%S") 

random_date <- as.Date("2022-05-15")
print(random_date)

GD_24h <- GDMove4 %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))
##Euler angle (It has problem with smoothing. So I just use line plot)
ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha=0.8) + 
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +  # Instead of geom_smooth
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title="",
    x = "Time",
    y = "Euler angle change"
  )
#
#Roll, Pitch, Yaw
# Convert dataset to long format
library(dplyr)
library(tidyr)

GD_24h_long <- GD_24h %>%
  dplyr::select(Time, Roll, Yaw, Pitch) %>%
  tidyr::pivot_longer(cols = c(Roll, Yaw, Pitch), names_to = "Variable", values_to = "Value")


# 
ggplot(GD_24h_long, aes(x = Time, y = Value, color = Variable)) +
  geom_smooth(method = "loess", span = 0.2, size=1,alpha=0.8, se = FALSE) +  # Smooth curves
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  scale_y_continuous(limits=c(-180,180), breaks=seq(-180,180,by=45))+
  theme(
    panel.background = element_rect(fill = "transparent", colour = NA),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.background = element_rect(fill = "transparent", colour = NA)
  ) +
  labs(
    title ="",
    x = "Time",
    y = "Turning attitudes (degrees)",
    color = "Variable")
#######
#GD4
library(patchwork)

GDData <- `GD96(K08)`
GDData <- `GD72(K26)`
# Convert Date and Time
GDData$Date <- as.Date(GDData$Date)  
GDData$Time <- as.POSIXct(paste(GDData$Date, GDData$Time), format="%Y-%m-%d %H:%M:%S")

# Select Date
selected_date <- as.Date("2022-05-16")
#start_date <- as.Date("2022-05-15 00:00:00")
#end_date <- as.Date("2022-05-19 00:00:00")
#GD_MultiDay <- GDData %>%
 # filter(Date >= start_date & Date <= end_date)
# Filter Data for 24 hours
GD_24h <- GDData %>%
  filter(Time >= as.POSIXct(paste(selected_date, "00:00:00")) & 
           Time < as.POSIXct(paste(selected_date + 1, "00:00:00")))

# First Plot: Egg Temperature
p1 <- ggplot(GDData, aes(x = Time, y = Temp.egg.)) +
  geom_smooth(method = "loess", span = 0.1, color = "#B8800B", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Temperature (°C)",
    x = ""
  ) +
  theme_minimal()
#theme(
 # panel.background = element_rect(fill = "transparent", colour = NA),
  #axis.line = element_line(color = "black"),
  #axis.text.x = element_text(angle = 45, hjust = 1),
  #plot.background = element_rect(fill = "transparent", colour = NA)
#)

# Second Plot: Euler Angle (On its Own Scale)
p2 <- ggplot(GD_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "#B8800B", alpha = 0.8, size = 1) +
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Euler Angle (°)",
    x = "Time"
  ) +
  theme_minimal()

# Combine the two plots with the same X-axis
p1 / p2  # Using `patchwork` to stack them vertically

## ED4

EDdata <- `ED(B108W1.4)`

EDdata$Date <- as.Date(EDdata$Date)  
EDdata$Time <- as.POSIXct(paste(EDdata$Date, EDdata$Time), format="%Y-%m-%d %H:%M:%S") 
#Selecting a random date 
#Either an assigned date
#selected_date <- as.Date("2023-05-29")
#print(selected_date)
#OR a random date
random_date <- sample(unique(EDdata$Date), 1)
print(random_date)

ED_24h <- EDdata %>%
  filter(Time >= as.POSIXct(paste(random_date, "00:00:00")) & 
           Time < as.POSIXct(paste(random_date + 1, "00:00:00")))

p1 <- ggplot(ED_24h, aes(x = Time, y = Temp)) +
  geom_smooth(method = "loess", span = 0.1, color = "cornflowerblue", se = FALSE) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Temperature (°C)",
    x = ""
  ) +
  theme_minimal()
#theme(
# panel.background = element_rect(fill = "transparent", colour = NA),
#axis.line = element_line(color = "black"),
#axis.text.x = element_text(angle = 45, hjust = 1),
#plot.background = element_rect(fill = "transparent", colour = NA)
#)

# Second Plot: Euler Angle (On its Own Scale)
p2 <- ggplot(ED_24h, aes(x = Time, y = Euler_angle)) +
  geom_line(color = "cornflowerblue", alpha = 0.8, size = 1) +
  geom_hline(yintercept = 10, color = "red", linetype = "dashed", size = 1) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  labs(
    title = "",
    y = "Euler Angle (°)",
    x = "Time"
  ) +
  theme_minimal()

# Combine the two plots with the same X-axis
p1 / p2  # Using `patchwork` to stack them vertically
